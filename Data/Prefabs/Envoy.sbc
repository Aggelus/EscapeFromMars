<?xml version="1.0"?>
<Definitions xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <Prefabs>
    <Prefab xsi:type="MyObjectBuilder_PrefabDefinition">
      <Id Type="MyObjectBuilder_PrefabDefinition" Subtype="Envoy" />
      <CubeGrids>
        <CubeGrid>
          <SubtypeName />
          <EntityId>142957195350724188</EntityId>
          <PersistentFlags>CastShadows InScene</PersistentFlags>
          <PositionAndOrientation>
            <Position x="0" y="0" z="0" />
            <Forward x="0.5924005" y="-0.7652789" z="-0.2518131" />
            <Up x="0.6589252" y="0.28039974" z="0.6979925" />
            <Orientation>
              <X>-0.03254445</X>
              <Y>-0.610765338</Y>
              <Z>-0.5989499</Z>
              <W>0.5168806</W>
            </Orientation>
          </PositionAndOrientation>
          <GridSizeEnum>Small</GridSizeEnum>
          <CubeBlocks>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CargoContainer">
              <SubtypeName>SmallBlockMediumContainer</SubtypeName>
              <EntityId>75275205484625661</EntityId>
              <Min x="-1" y="4" z="-1" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyInventoryBase</TypeId>
                    <Component xsi:type="MyObjectBuilder_Inventory">
                      <Items />
                      <nextItemId>0</nextItemId>
                      <Volume>3.375</Volume>
                      <Mass>9223372036854.775807</Mass>
                      <MaxItemCount>2147483647</MaxItemCount>
                      <Size xsi:nil="true" />
                      <InventoryFlags>CanReceive CanSend</InventoryFlags>
                      <RemoveEntityOnEmpty>false</RemoveEntityOnEmpty>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Medium Cargo Container 2</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="2" y="4" z="-2" />
              <BlockOrientation Forward="Up" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="-3" y="4" z="-2" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CargoContainer">
              <SubtypeName>SmallBlockMediumContainer</SubtypeName>
              <EntityId>109189238850159117</EntityId>
              <Min x="-1" y="4" z="2" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyInventoryBase</TypeId>
                    <Component xsi:type="MyObjectBuilder_Inventory">
                      <Items />
                      <nextItemId>0</nextItemId>
                      <Volume>3.375</Volume>
                      <Mass>9223372036854.775807</Mass>
                      <MaxItemCount>2147483647</MaxItemCount>
                      <Size xsi:nil="true" />
                      <InventoryFlags>CanReceive CanSend</InventoryFlags>
                      <RemoveEntityOnEmpty>false</RemoveEntityOnEmpty>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Medium Cargo Container 2</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <ContainerType>CargoLargeTrade1A</ContainerType>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="-2" y="6" z="-2" />
              <BlockOrientation Forward="Down" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_MyProgrammableBlock">
              <SubtypeName>SmallProgrammableBlock</SubtypeName>
              <EntityId>95666956036997728</EntityId>
              <Min x="-1" y="5" z="-2" />
              <BlockOrientation Forward="Right" Up="Backward" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyModStorageComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_ModStorageComponent">
                      <Storage>
                        <dictionary>
                          <item>
                            <Key>74de02b3-27f9-4960-b1c4-27351f2b06d1</Key>
                            <Value>
                              [WORLD]
                              MaxWorldMps=100

                              [GRIDS]
                              NoFollow=NOFOLLOW
                              BlockIgnore=!WCC
                              OrientationBlockContains=[NAV]
                              OrientationBlockNamed=Craft Remote Control
                              GyroIgnore=!NAV

                              [LOGGING]
                              TextPanelReport=Craft Report
                              StatusName=Wico Craft Status
                              LongStatus=Wico Craft Log
                              RangeReport=[RANGE]
                              SledReport=[SMREPORT]
                              GPSTag=[GPS]

                              [CONNECTORS]
                              BaseConnector=[BASE]
                              DockConnector=[DOCK]
                              GearUse=[DOCK]

                              [CAMERAS]
                              CameraViewOnly=[VIEW]

                              [POWER]
                              batterypcthigh=80
                              batterypctlow=20

                              [CARGO]
                              cargopctmin=5

                            </Value>
                          </item>
                        </dictionary>
                      </Storage>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>PB WIco Craft Main</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Program>
                /*
                * Wico craft controller Master Control Script
                *
                * Control Script for Rovers and Drones and Oribtal craft
                *
                * Uncompressed source for this script here: https://github.com/Wicorel/SpaceEngineers/tree/master/MDK%20Craft%20Control
                *
                *
                * Handles:
                * Master timer for sub-modules
                * Calculates ship speed and vectors (obsolete)
                * Calculates simspeed (obsolete)
                * Configure craft_operation settings
                * making sure antenna doesn't get turned off (bug in SE turn off antenna when trying to remotely connect to grid)
                *
                * Calculates cargo and power percentages and cargo multiplier and hydro fill and oxy tank fill
                *
                * Detects grid changes and initiates re-init
                *
                * *
                * MODE_IDLE
                * MODE_ATTENTION
                *
                * Commands:
                *
                * setsimspeed &lt;value&gt;: sets the current simspeed so the calculations can be accurate. (obsolete)
                * init: re-init all blocks
                * idle : force MODE_IDLE
                * coast: turns on/off backward thrusters
                * setvaluef &lt;blockname&gt;:&lt;property&gt;:&lt;value&gt;  -&gt; sets specified block's property to specified value
                * Example:
                *  setvaluef Advanced Rotor:UpperLimit:-24
                *
                * Need:

                * Want:
                *
                * menu management for commands (including sub-modules)
                *
                * minimize serialized data and make sub-modules pass their own seperately, OR support extra data in state
                *
                * common function for 'handle this' combining 'me' grid and an exclusion name check
                *
                * multi-script handling for modes
                *
                * * advanced trigger: only when module handles that mode... (so need mode-&gt;module dictionary)
                * override base modes?
                *
                *
                *
                * WANT:
                * setvalueb
                * Actions
                * Trigger timers on 'events'.
                * set antenna name to match mode?
                * *
                * 2.0 Removed many built-in functions to make script room. These functions were duplicated in sub-modules anyway.
                * 2.0.1
                * 0.2 Remove items from serialize that main control no longer calculates (cargo, battery, etc).
                * if simspeed&gt;1.01, assume 1.0 and recalculate.
                * 0.3 re-org code sections
                * Pass arguments to sub-modules
                * 0.4 (re)integrate power and cargo
                * 0.4a process multiple arguments on a command line
                * 0.4b check mass change and request reinit including sub-modules.
                *
                * 2.1 Code Reorg
                * Cache all blocks and grids.  Support for multi-grid constructions.
                * !Needs handling for grids connected via connectors..
                *
                * .1a Don't force re-init on working projector.
                * .1b Add 'brake' command
                * Add braking for sleds (added wheelinit)
                *
                * 2.2 PB changes in 1.172
                *
                * .2a Added modes. Default PB name
                *
                * 2.3 Start to add Power information
                *
                * .3a Add drills and ejectors to reset motion. Add welders, drills, connectors and grinders to cargo check.
                * don't set PB name because it erases settings.. :(
                *
                * .3b getblocks fixes when called before gridsinit
                *
                * 3.0 remove older items from serialize that are no longer needed
                * removed NAV support
                * fixed battery maxoutput values
                *
                * 3.0a support no remote control blocks. Check for Cryo when getting default controller.
                * 3.0b sBanner
                * 3.0c caching optimizations
                * 3.0d fix connectorsanyconnectors not using localdock
                * 3.0e Add Master Reset command
                * 3.0f
                * check for grid changes and re-init
                * rotor NOFOLLOW
                * ignore projectors with !WCC in name or customdata
                * ignore 'cutter' thrusters
                *
                * 3.0g Fix problem with allBlockCount being loaded after it has changed
                *
                * 3.0H
                * fix problems with docking/undocking and perm re-init
                *
                * 05/13: fix GetBlocksContains&lt;T&gt;()
                *
                * 3.0I MDK Version 08/20/2017   MDK: https://github.com/malware-dev/MDK-SE/
                * Uncompressed source for this script here: https://github.com/Wicorel/SpaceEngineers/tree/master/MDK%20Craft%20Control
                *
                * 3.0J Add moduleDoPreModes() to Main()
                * Move pre-mode to moduleDoPreModes()
                * add clearing of gpsPanel to moduleDoPreModes()
                *
                * 3.0K more init states if larger number of blocks in grid system.
                *
                * 3.0K2  search order for text panels
                *
                * 3.1 Verison for SE 1.185 PB Major changes
                *
                * 3.1A init cycle optimizations
                *
                * 3.1B Handle no controller (stations, etc)
                * 12092017
                *
                * 3.1C 12132017
                * don't count ejectors in cargo%
                * fix bug in DoTriggerMain() causing updates to stop
                *
                * 3.1D Section processing for save information (text panels)
                * fix bug in serialize wrting z,y z, instead of x,y,z (oops)
                *
                * 3.2 INI WCCM 01062018
                *
                * 3.2A
                * FilledRatio Change
                *
                * 3.2B Lots of INI processing
                *
                * 3.3 Handle multiple output panels.
                * Only write to panels at end
                *
                * 3.3A Redo Serlialize.
                * Module Serlialize
                *
                * 3.4
                * add namecameras
                *
                *
                */
                string a="Wico Craft";string b="Master";string c="3.4";const string d="0.00";double e=2;double f=-1;double
                g=5;double h=-1;void i(){ey("clear",ei);ey("clear",gpsPanel);string j="";if(fe&gt;0){j+="Ship\n";}else{
                j+="Station\n";}if(jK())j+="Connected";else j+="Not Connected";if(jJ())j+="\nLocked";else j+=" : Not Locked";
                Echo(j);eK(j);j="";if(kc)Echo("FAST!");if(f&gt;e){f=0;cw();}else{if(f&lt;0){f=e+5;}f+=Runtime.TimeSinceLastRun.TotalSeconds;
                }Echo("Cargo="+cn.ToString()+"%");if(h&gt;g){h=0;G(0,false);}else{if(h&lt;0){h=g+5;}h+=Runtime.TimeSinceLastRun.TotalSeconds;
                }j+="Batteries: #="+y.Count.ToString();if(y.Count&gt;0&amp;&amp;w&gt;0){j+=" : "+(F()/w*100).ToString("0.00")+"%";
                j+="\n Storage="+batteryPercentage.ToString()+"%";}Echo(j);j="";Echo("Solar: #"+hi.Count.ToString()+
                " "+hj.ToString("0.00"+"MW"));float k=0;gK(out k);if(gG.Count&gt;0){j="Reactors: #"+gG.Count.ToString();
                j+=" - "+gF.ToString("0.00")+"MW\n";float l=(float)(k/mQ*100);j+=" Curr Output="+k.ToString("0.00")+
                "MW"+" : "+l.ToString("0.00")+"%";}Echo(j);j="";Echo("TotalMaxPower="+mQ.ToString("0.00"+"MW"));TanksCalculate();
                if(dz&gt;=0){Echo("O:"+dz.ToString("000.0%"));}else Echo("No Oxygen Tanks");if(dy&gt;=0){Echo("H:"+dy.ToString("000.0%"));
                }else Echo("No Hydrogen Tanks");if(dl.Count&gt;0){Echo(dl.Count+" Gas Gens");}if(kk&gt;=0){Echo("Grav="+kk.ToString(d));
                eK("Planet Gravity "+kk.ToString(d)+" g");eK(eL((int)(kk/1.1*100)));}else eK("ERROR: No Remote Control found!");
                ey("clear",gpsPanel);}void m(){kp();}void n(bool o=false){iq(hn);lQ();gq(gf);gq(gg);if(ln is IMyRemoteControl)
                ((IMyRemoteControl)ln).SetAutoPilotEnabled(false);if(ln is IMyShipController)((IMyShipController)ln).DampenersOverride
                =true;if(!o)kv();}void p(){dj();n();gX=0;gY="";sPassedArgument="init";gS.md("");gM();kc=true;}void q()
                {gV=cH;if((gV&amp;cR)==cH){int r=0;if(Me.CustomName.ToLower().Contains("nad"))gV|=cN;if(Me.CustomName.ToLower().Contains("rotor"))
                gV|=cJ;else if(Me.CustomName.ToLower().Contains("sled"))gV|=CRAFT_MODE_SLED;if(hA&gt;0){r++;}if(hB&gt;0){r++;
                }if(hC&gt;0){r++;}if(gf.Count&gt;0&amp;&amp;gg.Count&gt;0)gV|=cJ;if(mV.Count&gt;0&amp;&amp;r&gt;0)gV|=CRAFT_MODE_SLED;if(r&gt;1||Me.CustomName.ToLower().Contains("orbital"))
                gV|=CRAFT_MODE_ORBITAL;if(Me.CustomName.ToLower().Contains("rocket"))gV|=cL;if(Me.CustomName.ToLower().Contains("pet"))
                gV|=cM;if(Me.CustomName.ToLower().Contains("noautogyro"))gV|=cO;if(Me.CustomName.ToLower().Contains("nopower"))
                gV|=cP;if(Me.CustomName.ToLower().Contains("notank"))gV|=cQ;}}void s(){string j="";j+=kf.ToString(d)
                +" m/s";j+=" ("+(kf*3.6).ToString(d)+"km/h)";eK(j);}void t(lR u){}void v(lR u){}double w=-1;int batteryPercentage
                =-1;List&lt;IMyTerminalBlock&gt;y=new List&lt;IMyTerminalBlock&gt;();bool z(IMyTerminalBlock A){if(A is IMyBatteryBlock)
                {IMyBatteryBlock B=A as IMyBatteryBlock;return B.OnlyRecharge;}else return false;}bool C(IMyTerminalBlock
                A){if(A is IMyBatteryBlock){IMyBatteryBlock B=A as IMyBatteryBlock;return B.OnlyDischarge;}else return
                false;}bool D(IMyTerminalBlock A){if(A is IMyBatteryBlock){IMyBatteryBlock B=A as IMyBatteryBlock;return
                B.IsCharging;}else return false;}void E(){y.Clear();batteryPercentage=-1;w=-1;GridTerminalSystem.GetBlocksOfType&lt;IMyBatteryBlock&gt;(y,
                lc);if(y.Count&gt;0)w=0;foreach(var tb in y){IMyBatteryBlock r=tb as IMyBatteryBlock;w+=r.MaxOutput;}}double
                F(){double j=0;foreach(var tb in y){IMyBatteryBlock r=tb as IMyBatteryBlock;j+=r.CurrentOutput;}return
                j;}bool G(int H,bool I=true,bool J=false){float K=0;float L=0;bool M=false;float f1;if(y.Count&lt;1)E();
                if(y.Count&lt;1)return false;batteryPercentage=0;for(int ib=0;ib&lt;y.Count;ib++){float N=0;float O=0;int P
                =100;IMyBatteryBlock b;b=y[ib]as IMyBatteryBlock;f1=b.MaxStoredPower;O+=f1;K+=f1;f1=b.CurrentStoredPower;
                N+=f1;L+=f1;if(O&gt;0){f1=((N*100)/O);f1=(float)Math.Round(f1,0);P=(int)f1;}string s;s="";if(z(y[ib]))s
                +="R";else if(C(y[ib]))s+="D";else s+="a";float Q;Q=b.CurrentInput;if(Q&gt;0)s+="+";else s+=" ";Q=b.CurrentOutput;
                if(Q&gt;0)s+="-";else s+=" ";s+=P+"%";s+=":"+y[ib].CustomName;if(I)Echo(s);if(z(y[ib])&amp;&amp;H&gt;0){if(P&lt;H)M=true;
                else if(P&gt;99)b.OnlyRecharge=false;}if(!b.OnlyRecharge&amp;&amp;P&lt;H&amp;&amp;!M){b.OnlyDischarge=false;b.OnlyRecharge
                =true;b.SemiautoEnabled=false;M=true;}}if(K&gt;0){f1=((L*100)/K);f1=(float)Math.Round(f1,0);batteryPercentage
                =(int)f1;}else batteryPercentage=-1;return M;}void R(bool I=false,bool S=true){Echo(y.Count+" Batteries");
                string s;for(int i=0;i&lt;y.Count;i++){IMyBatteryBlock b;b=y[i]as IMyBatteryBlock;b.OnlyRecharge=!S;b.OnlyDischarge
                =S;b.SemiautoEnabled=false;s=b.CustomName+": ";if(b.OnlyRecharge){s+="RECHARGE/";}else s+="NOTRECHARGE/";
                if(b.OnlyDischarge){s+="DISCHARGE";}else{s+="NOTDISCHARGE";}if(I)Echo(s);}}void T(List&lt;IMyTerminalBlock&gt;
                U,bool V=true){foreach(var b in U){IMyFunctionalBlock f=b as IMyFunctionalBlock;if(f==null)continue;
                f.Enabled=V;}}void W(List&lt;IMyTerminalBlock&gt;U){foreach(var b in U){IMyFunctionalBlock f=b as IMyFunctionalBlock;
                if(f==null)continue;f.Enabled=!f.Enabled;}}string X="[VIEW]";Matrix Y=new Matrix(1,0,0,0,0,1,0,0,0,0,
                1,0,0,0,0,1);List&lt;IMyTerminalBlock&gt;Z=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;ba=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;bb=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;bc=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;bd=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;be=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;bf=new List&lt;IMyTerminalBlock&gt;();IMyTerminalBlock bg=null;private MyDetectedEntityInfo
                bh;string bi="CAMERAS";void bj(lR u){u.mt(bi,"CameraViewOnly",ref X,true);}bool bk(List&lt;IMyTerminalBlock&gt;
                bl,double bm=100,float bn=0,float bo=0){double bp=0;bg=null;for(int i=0;i&lt;bl.Count;i++){double bq=((IMyCameraBlock)bl[i]).AvailableScanRange;
                if(bq&gt;bp){bp=bq;bg=bl[i];}}var br=bg as IMyCameraBlock;if(bg==null){return false;}if(br.CanScan(bm))
                {bh=br.Raycast(bm,bn,bo);bg=br;if(!bh.IsEmpty())db(bh);return true;}else{}return false;}bool bk(List&lt;IMyTerminalBlock&gt;
                bl,Vector3D bs){double bp=0;bg=null;for(int i=0;i&lt;bl.Count;i++){double bq=((IMyCameraBlock)bl[i]).AvailableScanRange;
                if(bq&gt;bp){bp=bq;bg=bl[i];}}var br=bg as IMyCameraBlock;if(bg==null)return false;{bh=br.Raycast(bs);bg
                =br;if(!bh.IsEmpty())db(bh);return true;}}double bt(List&lt;IMyTerminalBlock&gt;bl){double bu=0;for(int i=
                0;i&lt;bl.Count;i++){IMyCameraBlock br=bl[i]as IMyCameraBlock;if(bu&lt;br.AvailableScanRange)bu=br.AvailableScanRange;
                }return bu;}string bv(IMyTerminalBlock bw){Z.Clear();ba.Clear();bb.Clear();bc.Clear();bd.Clear();be.Clear();
                bf.Clear();if(bw==null)return"\nCameras:No OrientationBlock";GridTerminalSystem.GetBlocksOfType&lt;IMyCameraBlock&gt;(bf,
                (x1=&gt;x1.CubeGrid==Me.CubeGrid));Matrix bx;bw.Orientation.GetMatrix(out bx);Matrix.Transpose(ref bx,out
                bx);for(int i=0;i&lt;bf.Count;++i){if(bf[i].CustomName.Contains(X))continue;IMyCameraBlock br=bf[i]as IMyCameraBlock;
                br.EnableRaycast=true;Matrix by;br.Orientation.GetMatrix(out by);Vector3 bz=Vector3.Transform(by.Forward,
                bx);if(bz==Y.Left){bd.Add(bf[i]);}else if(bz==Y.Right){be.Add(bf[i]);}else if(bz==Y.Backward){ba.Add(bf[i]);
                }else if(bz==Y.Forward){Z.Add(bf[i]);}else if(bz==Y.Up){bc.Add(bf[i]);}else if(bz==Y.Down){bb.Add(bf[i]);
                }}string s;s="CS:&lt;";s+="F"+Z.Count.ToString("00");s+="B"+ba.Count.ToString("00");s+="D"+bb.Count.ToString("00");
                s+="U"+bc.Count.ToString("00");s+="L"+bd.Count.ToString("00");s+="R"+be.Count.ToString("00");s+="&gt;";
                return s;}void bA(List&lt;IMyTerminalBlock&gt;bl,string bB){string bC;for(int i=0;i&lt;bl.Count;i++){if(!bl[i].CustomName.Contains(bB))
                {bC="Camera ";if(bl.Count&gt;1)bC+=(i+1).ToString()+" ";bC+=bB;bl[i].CustomName=bC;}}}List&lt;IMyTerminalBlock&gt;
                bD=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;bE=new List&lt;IMyTerminalBlock&gt;();string bF(IMyTerminalBlock
                bw){string s="";if(bf.Count&lt;1)s+=bv(bw);bD.Clear();bE.Clear();foreach(var camera in bb){if(camera.CustomName.ToLower().Contains("fore")
                ||camera.CustomData.ToLower().Contains("fore"))bD.Add(camera);else if(camera.CustomName.ToLower().Contains("aft")
                ||camera.CustomData.ToLower().Contains("aft"))bE.Add(camera);}s+="HCS:&lt;";s+="F"+bD.Count.ToString("00");
                s+="A"+bE.Count.ToString("00");s+="&gt;";return s;}public class bG{bool bH=false;Program bI;public double
                bJ=1250;double bK=5000;float bL=25f;float bM=25f;double bN=5;float bO=3;float bP=0.5f;float bQ=0;float
                bR=0;float bS=0;float bT=0;List&lt;IMyTerminalBlock&gt;bU=new List&lt;IMyTerminalBlock&gt;();private int bV=0;private
                int bW=1;public MyDetectedEntityInfo bh;public List&lt;MyDetectedEntityInfo&gt;bX=new List&lt;MyDetectedEntityInfo&gt;();
                public IMyTerminalBlock bg=null;public bG(Program pg,List&lt;IMyTerminalBlock&gt;U,double bY=1250,float bZ
                =45f,float ca=45f,float cb=2,float cc=1,float cd=0.5f,double ce=5000){bI=pg;bH=false;bU.Clear();bX.Clear();
                bh=new MyDetectedEntityInfo();foreach(var b in U){if(b is IMyCameraBlock){bU.Add(b);IMyCameraBlock c
                =b as IMyCameraBlock;c.EnableRaycast=true;if(bL&gt;c.RaycastConeLimit)bL=c.RaycastConeLimit;if(bM&gt;c.RaycastConeLimit)
                bM=c.RaycastConeLimit;}}if(bY&gt;ce)ce=bY;bJ=bY;bL=bZ;bM=ca;bN=cb;bO=cc;bP=cd;bK=ce;bQ=0;bR=0;bS=0;bT=0;
                bV=0;bW=bU.Count;}public bool cf(){return bH;}void cg(MyDetectedEntityInfo bh){bool ch=true;for(int i
                =0;i&lt;bX.Count;i++){if(bX[i].EntityId==bh.EntityId)ch=false;}if(ch){bX.Add(bh);}}public bool ci(){if(bU.Count
                &lt;1)bH=true;if(bH)return false;bool cj=false;for(int ck=0;ck&lt;bW;ck++){if(bI.bk(bU,bJ,bT,bS)){bh=bI.bh;
                if(!bh.IsEmpty()){bool cl=true;if((bh.Type==MyDetectedEntityType.LargeGrid)||(bh.Type==MyDetectedEntityType.SmallGrid))
                {if(bI.ld(bh.EntityId)){cl=false;}}if(cl){bI.fc+="\nDoScan HIT!";cg(bh);cj=true;}}bV++;if(bT==0&amp;&amp;bS==
                0){bQ=bP;bR=bP;bV=0;}if(bV&gt;3){bV=0;bR+=Math.Abs(bR/bO)+bP;if(Math.Abs(bR)&gt;bL){bV=0;bR=0;bQ+=Math.Abs(bQ
                /bO)+bP;}if(Math.Abs(bQ)&gt;bM){bQ=0;bR=0;bV=0;{bJ*=bN;if(bJ&gt;bK){bH=true;return false;}}}}switch(bV){case
                0:bT=bQ;bS=bR;break;case 1:bT=-bQ;bS=bR;break;case 2:bT=bQ;bS=-bR;break;case 3:bT=-bQ;bS=-bR;break;}
                }}return cj;}}int cm=5;int cn=-1;double co=-1;string cp="CARGO";void cq(lR u){u.mt(cp,"cargopctmin",
                ref cm,true);}List&lt;IMyTerminalBlock&gt;cr=null;bool cs=false;double ct=0.0;void cu(){var cv=new List&lt;IMyTerminalBlock&gt;();
                if(cr==null)cr=new List&lt;IMyTerminalBlock&gt;();else cr.Clear();li&lt;IMyCargoContainer&gt;(ref cv);cr.AddRange(cv);
                cv.Clear();li&lt;IMyShipConnector&gt;(ref cv);foreach(var c in cv){if(c.CustomName.Contains("Ejector")||c.CustomData.Contains("Ejector"))
                continue;else cr.Add(c);}cv.Clear();li&lt;IMyShipDrill&gt;(ref cv);cr.AddRange(cv);cv.Clear();li&lt;IMyShipWelder&gt;(ref
                cv);cr.AddRange(cv);cv.Clear();li&lt;IMyShipGrinder&gt;(ref cv);cr.AddRange(cv);cn=-1;co=-1;}void cw(){if(cr
                ==null)cu();if(cr.Count&lt;1){cn=-1;co=-1;return;}ct=0.0;double cx=0.0;double cy=0;for(int i=0;i&lt;cr.Count;
                i++){cx+=cz(cr[i]);}if(cx&gt;0){cy=(ct/cx)*100;}else{cy=100;}cn=(int)cy;}double cz(IMyTerminalBlock cA)
                {double O=-1;var cB=cA.InventoryCount;for(var cC=0;cC&lt;cB;cC++){var cD=cA.GetInventory(cC);if(cD!=null)
                {ct+=(double)cD.CurrentVolume;if((double)cD.MaxVolume&gt;9223372036854){cs=true;}else{cs=false;}if(!cs)
                {O=(double)cD.MaxVolume;double cE=cF(cA);if(cE&gt;0)co=O/cE;}else{O=cF(cA)*10;co=9999;}}}return O;}double
                cF(IMyTerminalBlock theContainer){var cD=theContainer.GetInventory(0);string cG=theContainer.BlockDefinition.SubtypeId;
                double O=(double)cD.MaxVolume;if(O&lt;999999999)return O;if(theContainer is IMyCargoContainer){if(cG.Contains("LargeBlockLargeContainer"))
                O=421.875008;else if(cG.Contains("LargeBlockSmallContainer"))O=15.625;else if(cG.Contains("SmallBlockLargeContainer"))
                O=15.625;else if(cG.Contains("SmallBlockMediumContainer"))O=3.375;else if(cG.Contains("SmallBlockSmallContainer"))
                O=0.125;else if(cG.Contains("Azimuth_LargeContainer"))O=7780.8;else if(cG.Contains("Azimuth_MediumLargeContainer"))
                O=1945.2;else if(cG.Contains("Azimuth_MediumContainer"))O=1878.6;else if(cG.Contains("Azimuth_SmallContainer"))
                O=10.125;}else if(cG.Contains("SmallBlockDrill"))O=3.375;else if(cG.Contains("LargeBlockDrill"))O=23.4375;
                else if(cG.Contains("ConnectorMedium"))O=1.152;else if(cG.Contains("ConnectorSmall"))O=0.064;else if
                (cG.Contains("Connector"))O=8.000;else if(cG.Contains("LargeShipWelder"))O=15.625;else if(cG.Contains("LargeShipGrinder"))
                O=15.625;else if(cG.Contains("SmallShipWelder"))O=3.375;else if(cG.Contains("SmallShipGrinder"))O=3.375;
                else{Echo("Not cargo:"+theContainer.DefinitionDisplayNameText+":"+theContainer.BlockDefinition.SubtypeId);
                O=0.125;}return O;}const int cH=0;const int CRAFT_MODE_SLED=2;const int cJ=4;const int CRAFT_MODE_ORBITAL
                =32;const int cL=64;const int cM=128;const int cN=256;const int cO=512;const int cP=1024;const int cQ
                =2048;const int cR=0xfff;string craftOperation(){string cT="FLAGS:";if((gV&amp;CRAFT_MODE_SLED)&gt;0)cT+="SLED ";
                if((gV&amp;CRAFT_MODE_ORBITAL)&gt;0)cT+="ORBITAL ";if((gV&amp;cL)&gt;0)cT+="ROCKET ";if((gV&amp;cJ)&gt;0)cT+="ROTOR ";if((gV
                &amp;cM)&gt;0)cT+="PET ";if((gV&amp;cN)&gt;0)cT+="NAD ";if((gV&amp;cO)&gt;0)cT+="NO Gyro ";if((gV&amp;cQ)&gt;0)cT+="No Tank ";if
                ((gV&amp;cP)&gt;0)cT+="No Power ";return cT;}long cU=0;void cV(){string cW;if(SaveFile==null){cW=Storage;}else
                {cW=SaveFile.GetPublicText();}gS.md(cW);gS.mt(gP,"SaveID",ref cU);if(cX())gS.md("");t(gS);gS.mt(gP,"Mode",
                ref fl,true);gS.mt(gP,"current_state",ref current_state,true);gS.mt(gP,"PassedArgument",ref sPassedArgument,
                true);gS.mt(gP,"AlertStates",ref gX,true);gS.mt(gP,"craft_operation",ref gV,true);gS.mt(gP,"PassedArgument",
                ref sPassedArgument);gS.mt(gP,"ReceivedMessage",ref gY);}bool cX(){if(cU==(long)SaveFile.EntityId)return
                false;else return true;}bool cY(string cZ){cZ=cZ.Trim().ToLower();return(cZ=="True"||cZ=="true");}Dictionary&lt;long,
                MyDetectedEntityInfo&gt;da=new Dictionary&lt;long,MyDetectedEntityInfo&gt;();void db(MyDetectedEntityInfo thisDetectedInfo)
                {if(thisDetectedInfo.EntityId!=0){if(!da.ContainsKey(thisDetectedInfo.EntityId)){da.Add(thisDetectedInfo.EntityId,
                thisDetectedInfo);}else{da[thisDetectedInfo.EntityId]=thisDetectedInfo;}}else Echo("Not adding: Zero Entity");
                }string dd(MyDetectedEntityInfo de){string s="";s+="ETBV";s+=":"+de.EntityId.ToString();s+=":"+de.TimeStamp;
                Vector3D df=de.BoundingBox.Min;s+=":"+hb(df);Vector3D dg=de.BoundingBox.Max;s+=":"+hb(dg);Vector3D dh
                =(Vector3)de.Velocity;s+=":"+hb(dh);return s;}void di(){Echo("mode="+fl.ToString());if(fl==fm)dk();else
                if(fl==fp){ey("clear",ei);ey(b+":ATTENTION!",ei);ey(b+": current_state="+current_state.ToString(),ei);
                ey("\nCraft Needs attention",ei);}}void dj(){ey(DateTime.Now.ToString()+" ACTION: Reset To Idle",eg,
                true);n();gc(fm);if(fe&gt;0&amp;&amp;jK()&amp;&amp;fl!=fr&amp;&amp;fl!=fz&amp;&amp;!((gV&amp;CRAFT_MODE_ORBITAL)&gt;0)&amp;&amp;!((gV&amp;cN)&gt;0))gc(fv);}void
                dk(){ey("clear",ei);ey(a+":"+b+":Manual Control (idle)",ei);if(fe&gt;0&amp;&amp;jK()&amp;&amp;fl!=fr&amp;&amp;fl!=fz&amp;&amp;!((gV&amp;CRAFT_MODE_ORBITAL)
                &gt;0)&amp;&amp;!((gV&amp;cN)&gt;0))gc(fv);}List&lt;IMyTerminalBlock&gt;dl=new List&lt;IMyTerminalBlock&gt;();string dm(){dl.Clear();
                dl=li&lt;IMyGasGenerator&gt;();return"GG"+dl.Count.ToString("00");}void dn(bool V=true){T(dl,V);}bool@do()
                {return true;}void dp(){if(dC()&gt;99){T(dl,false);}else{T(dl,true);}}List&lt;IMyTerminalBlock&gt;dq=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;dr=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;ds=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;dt=new List&lt;IMyTerminalBlock&gt;();const int du=1;const int dv=2;int dw=0;int dx=
                0;double dy=-1;double dz=-1;void TanksCalculate(){dy=dC(dv);dz=dC(du);}string dB(){{dq=new List&lt;IMyTerminalBlock&gt;();
                GridTerminalSystem.GetBlocksOfType&lt;IMyGasTank&gt;(dq,(x=&gt;x.CubeGrid==Me.CubeGrid));}dw=0;dx=0;for(int i
                =0;i&lt;dq.Count;++i){if(dK(dq[i])==du){if(dq[i].CustomName.ToLower().Contains("isolated"))dt.Add(dq[i]);
                else dr.Add(dq[i]);dx++;}else if(dK(dq[i])==dv){ds.Add(dq[i]);dw++;}}return"T"+dq.Count.ToString("00");
                }double dC(List&lt;IMyTerminalBlock&gt;dq){double dD=0;int dE=0;for(int i=0;i&lt;dq.Count;++i){{IMyGasTank dF
                =dq[i]as IMyGasTank;if(dF==null)continue;float dG=(float)dF.FilledRatio;dD+=dG;dE++;}}if(dE&gt;0){return
                dD*100/dE;}else return 0;}double dC(int iTypes=0xff){if(dq.Count&lt;1)dB();if(dq.Count&lt;1)return-1;double
                dI=0;int dE=0;for(int i=0;i&lt;dq.Count;++i){int dJ=dK(dq[i]);if((dJ&amp;iTypes)&gt;0){IMyGasTank dF=dq[i]as IMyGasTank;
                if(dF==null)continue;float dG=(float)dF.FilledRatio;dI+=dG;dE++;}}if(dE&gt;0){return dI/dE;}else return
                -1;}int dK(IMyTerminalBlock dL){if(dL is IMyGasTank){if(dL.BlockDefinition.SubtypeId.Contains("Hydro"))
                return dv;else return du;}return 0;}void dM(bool dN=true,int dH=0xff){if(dq.Count&lt;1)dB();if(dq.Count
                &lt;1)return;for(int i=0;i&lt;dq.Count;++i){int dJ=dK(dq[i]);if((dJ&amp;dH)&gt;0){IMyGasTank dF=dq[i]as IMyGasTank;
                if(dF==null)continue;dF.Stockpile=dN;}}}string dO="[DOCK]";List&lt;IMyTerminalBlock&gt;dP=new List&lt;IMyTerminalBlock&gt;();
                void dQ(lR u){u.mt(jF,"GearUse",ref dO,true);}void dR(){if(dP.Count&lt;1)dP=lk&lt;IMyLandingGear&gt;(dO);if(dP.Count
                &lt;1)dP=li&lt;IMyLandingGear&gt;();return;}string dS(){{dP.Clear();dR();}return"LG"+dP.Count.ToString("00");
                }bool dT(){for(int i=0;i&lt;dP.Count;i++){IMyLandingGear dU;dU=dP[i]as IMyLandingGear;if(dU!=null&amp;&amp;dU.IsLocked)
                return true;}return false;}bool dV(IMyTerminalBlock A){var g=A as IMyLandingGear;if(g==null)return false;
                return((int)g.LockMode==1);}bool dW(){var dX=new StringBuilder();for(int i=0;i&lt;dP.Count;i++){if(dV(dP[i]))
                return true;}return false;}void dY(bool dZ=true){for(int i=0;i&lt;dP.Count;i++){IMyLandingGear g=dP[i]as
                IMyLandingGear;if(g==null)continue;if(dZ)g.Lock();else g.Unlock();}}string ea="LOGGING";void eb(lR u)
                {u.mt(ea,"TextPanelReport",ref sTextPanelReport,true);u.mt(ea,"StatusName",ref ef,true);u.mt(ea,"LongStatus",
                ref eh,true);u.mt(ea,"RangeReport",ref ed,true);u.mt(ea,"SledReport",ref en,true);u.mt(ea,"GPSTag",ref
                el,true);}eq ec=null;string ed="[RANGE]";eq ee=null;string ef="Wico Craft Status";eq eg=null;string eh
                ="Wico Craft Log";eq ei=null;string sTextPanelReport="Craft Report";eq gpsPanel=null;string el="[GPS]";
                eq em=null;string en="[SMREPORT]";bool eo=false;bool ep=false;public class eq{Program bI;string er="";
                List&lt;IMyTextPanel&gt;es=new List&lt;IMyTextPanel&gt;();string et="";string eu="";bool ev=false;bool ew=true;public
                eq(Program pg,string bC,bool ex=false){bI=pg;er=bC;ev=ex;ew=true;et="";eu="";es.Clear();List&lt;IMyTerminalBlock&gt;
                U=new List&lt;IMyTerminalBlock&gt;();U=bI.ll&lt;IMyTextPanel&gt;(er);if(U.Count&lt;1)U=bI.lk&lt;IMyTextPanel&gt;(er);es=U.ConvertAll(x1
                =&gt;(IMyTextPanel)x1);}public void ey(string ez,bool eA=false){if(ez=="clear"){et="";eu="X";ew=false;return;
                }if(ev&amp;&amp;ew){ew=false;if(es.Count&gt;0){et=es[0].GetPublicText();eu="X";}}if(eA){et=ez+"\n"+et;}else et+=
                ez+"\n";}public void eB(){if(eu!=et){ew=true;foreach(var t in es){t.WritePublicText(et);}eu=et;}}}void
                eC(){ee=eH(true);eg=eE(eh,true);;ei=eE(sTextPanelReport);ec=eE(ed);gpsPanel=eE(el,jY);em=eE(en);eo=true;
                }void eD(){if(ee!=null)ee.eB();if(eg!=null)eg.eB();if(ei!=null)ei.eB();if(ec!=null)ec.eB();if(gpsPanel
                !=null)gpsPanel.eB();if(em!=null)em.eB();}eq eE(string stheName,bool bRefresh=false){eq eG=new eq(this,
                stheName,bRefresh);return eG;}eq eH(bool force_update=false){if((ee!=null||eo)&amp;&amp;!force_update)return
                ee;ee=eE(ef);return ee;}void ey(string text,eq wLog,bool bReverse=false){if(wLog==null)return;wLog.ey(text,
                bReverse);}void eK(string ez){ey(ez,eH());if(ep&amp;&amp;ez!="clear")Echo(ez);}string eL(double eM){int eN=75;
                if(eM&lt;0)eM=0;int eO=(int)(eM*eN)/100;if(eO&gt;eN)eO=eN;string cT="["+new String('|',eO)+new String('\'',
                eN-eO)+"]";return cT;}void eP(string bC,Vector3D eQ){string s1;s1="GPS:"+bC+":"+hb(eQ)+":";ey(s1,gpsPanel);
                }string eR(string eS,string eT){string s;int eU=eS.Length;int eV=eT.Length;if(eU+eV&gt;32){if(eV&gt;31)return
                "INVALID";eU=32-eV;}s=eS.Substring(0,eU)+eT;s.Replace(":","_");s.Replace(";","_");return s;}string eW(double
                eX){string eY="";if(eX&gt;1000){eY=eX.ToString("N0")+"km";}else if(eX&gt;10){eY=eX.ToString("0.0")+"m";}else
                {eY=eX.ToString("0.000")+"m";}return eY;}void eZ(){}void fa(lR fb){jG(fb);hL(fb);lr(fb);bj(fb);dQ(fb);
                mS(fb);cq(fb);}string fc="";int fd=0;double fe=0;string doInit(){Echo(kH.Count.ToString()+" Blocks");
                Echo("Init:"+fd);if(fd==0){ey(DateTime.Now.ToString()+" "+a+":"+b+":INIT",eg,true);fc+=kO();eC();iO();
                fc+=SerializeInit();cV();}else if(fd==1){cV();fc+=DefaultOrientationBlockInit();cu();mT();fc+=hM(ln);
                fc+=lN();if(ln is IMyRemoteControl){Vector3D fg;bool fh=((IMyRemoteControl)ln).GetNearestPlayer(out fg);
                IMyRemoteControl fi=(IMyRemoteControl)ln;fi.SetCollisionAvoidance(false);fi.SetDockingMode(false);fi.Direction
                =Base6Directions.Direction.Forward;fi.FlightMode=FlightMode.OneWay;fi.ClearWaypoints();fi.AddWaypoint(fg,
                "Name");}}if(fd==2){fc+=mY(ln);fc+=gh();fc+=jH();fc+=dB();fc+=ks();}if(fd==3){fc+=bv(ln);fc+=ky();fc
                +=iX();fc+=dm();q();kc=false;if(iU)jS="*"+a+":"+b+" V"+c+" ";if(jS.Length&gt;34){jS=a+":"+b+"\nV"+c+" ";
                }if(ln is IMyShipController){MyShipMass fj;fj=((IMyShipController)ln).CalculateShipMass();fe=fj.BaseMass;
                }fc+=fk();ka=true;}fd++;if(ka)fd=0;eK(fc);return fc;}string fk(){return"&gt;";}int fl=0;const int fm=0;
                const int fn=1;const int fo=2;const int fp=3;const int fq=4;const int fr=5;const int fs=7;const int ft
                =8;const int fu=9;const int fv=13;const int fw=10;const int fx=11;const int fy=12;const int fz=14;const
                int fA=15;const int fB=16;const int fC=17;const int fD=18;const int fE=19;const int fF=20;const int fG
                =21;const int fH=22;const int fI=23;const int fJ=24;const int fK=25;const int fL=26;const int fM=27;
                const int fN=28;const int fO=29;const int fP=30;const int fQ=31;const int fR=50;const int fS=60;const
                int fT=111;const int fU=200;const int fV=210;const int fW=220;const int fX=290;const int fY=400;const
                int fZ=410;const int ga=500;const int gb=510;void gc(int gd){if(fl==gd)return;fl=gd;current_state=0;
                iT();}List&lt;IMyTerminalBlock&gt;ge=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;gf=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;gg=new List&lt;IMyTerminalBlock&gt;();string gh(){ge.Clear();gf.Clear();gg.Clear();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(ge,
                lc);for(int i=0;i&lt;ge.Count;i++){if(ge[i].CustomName.Contains("[LEFT]")||ge[i].CustomData.Contains("[LEFT]"))
                {gf.Add(ge[i]);}else if(ge[i].CustomName.Contains("[RIGHT]")||ge[i].CustomData.Contains("[RIGHT]")){
                gg.Add(ge[i]);}}return"NR:L"+gf.Count.ToString("0")+"R"+gg.Count.ToString("0");}bool gi(float gj){if
                (gf.Count&lt;1)return false;float gk=gf[0].GetMaximum&lt;float&gt;("Velocity");float gl=gf[0].GetValueFloat("Velocity");
                float gm=(gl/gk*100);gm=Math.Abs(gm);if(gj&gt;(gm+5f))gj=gm+5;if(gj&lt;(gm-5))gj=gm-5;if(gj&lt;0f)gj=0f;if(gj
                &gt;100f)gj=100f;if(Math.Abs(gj)&gt;0){gi(gf,-gj);gi(gg,gj);return true;}else return false;}bool gi(List&lt;IMyTerminalBlock&gt;
                rotorList,float gj){for(int i=0;i&lt;rotorList.Count;i++){IMyMotorStator go=rotorList[i]as IMyMotorStator;
                float gk=go.GetMaximum&lt;float&gt;("Velocity");if(!go.Enabled)go.Enabled=true;float gp=gk*(gj/100.0f);Echo(go.CustomName
                +":MV="+gk.ToString("0.00")+":V="+gp.ToString("0.00"));go.TargetVelocityRPM=gp;}return true;}bool gq()
                {gq(gf);gq(gg);return true;}bool gq(List&lt;IMyTerminalBlock&gt;rotorList){for(int i=0;i&lt;rotorList.Count;i++)
                {IMyMotorStator go=rotorList[i]as IMyMotorStator;go.TargetVelocityRPM=0;}return true;}bool gr(double
                gs){Echo("DRR:"+gs.ToString());float gj;if(Math.Abs(gs)&gt;1.0){gj=50;}else if(Math.Abs(gs)&gt;.7){gj=50;}
                else if(Math.Abs(gs)&gt;0.5){gj=30;}else if(Math.Abs(gs)&gt;0.1){gj=20;}else if(Math.Abs(gs)&gt;0.01){gj=5;}else
                if(Math.Abs(gs)&gt;0.001){gj=0;}else gj=0;gj/=3;gj=gj*-Math.Sign(gs);if(Math.Abs(gj)&gt;0){Echo("PUPLEFT:"
                +gj.ToString());gi(gf,gj);}if(Math.Abs(gj)&gt;0){Echo("PUPRIGHT:"+gj.ToString());gi(gg,gj);}if(Math.Abs(gj)
                &gt;0)return false;else return true;}bool gt(string gu){string[]gv=gu.Trim().Split(';');for(int gw=0;gw
                &lt;gv.Length;gw++){string[]gx=gv[gw].Trim().Split(' ');if(gx[0]=="timer"){s();}else if(gx[0]=="idle")dj();
                else if(gx[0]=="masterreset")p();else if(gx[0].ToLower()=="coast"){if(hp.Count&gt;1){W(hp);}}else if(gx[0]
                =="setvaluef"){Echo("SetValueFloat");string gy="";for(int i=1;i&lt;gx.Length;i++){gy+=gx[i];if(i&lt;gx.Length
                -1){gy+=" ";}}string[]gz=gy.Trim().Split(':');if(gz.Length&lt;3){Echo("Invalid Args");continue;}IMyTerminalBlock
                A;A=(IMyTerminalBlock)GridTerminalSystem.GetBlockWithName(gz[0]);if(A==null){Echo("Block not found:"
                +gz[0]);continue;}float gA=0;bool gB=float.TryParse(gz[2].Trim(),out gA);if(!gB){Echo("invalid float value:"
                +gz[2]);continue;}Echo("SetValueFloat:"+gz[0]+" "+gz[1]+" to:"+gA.ToString());A.SetValueFloat(gz[1],
                gA);}else if(gx[0]=="brake"){Echo("brake");if(ln is IMyShipController){IMyShipController gC=ln as IMyShipController;
                bool gD=gC.HandBrake;gC.ApplyAction("HandBrake");}else Echo("No Ship Controller found");}else if(gx[0]
                =="namecameras"){bA(Z,"Front");bA(ba,"Back");bA(bb,"Down");bA(bc,"Up");bA(bd,"Left");bA(be,"Right");
                }else if(gx[0]=="wcct"||gx[0]==""){}else{int gE;if(jR.TryGetValue(gx[0].ToLower(),out gE)){gc(gE);}else
                Echo("Unrecognized Command:"+gv[gw]);}}return false;}double gF=-1;List&lt;IMyTerminalBlock&gt;gG=new List&lt;IMyTerminalBlock&gt;();
                void gH(){gG.Clear();li&lt;IMyReactor&gt;(ref gG);float gI;gK(out gI);}double gJ(){double j=0;foreach(var tb
                in gG){IMyReactor r=tb as IMyReactor;j+=r.CurrentOutput;}return j;}bool gK(out float currentOutput){
                currentOutput=0;gF=-1;bool gL=false;if(gG.Count&gt;0)gF=0;foreach(IMyReactor r in gG){currentOutput+=r.CurrentOutput;
                gF+=r.MaxOutput;}return gL;}void gM(){v(gS);gS.mG(gP,"Mode",fl.ToString());gS.mG(gP,"current_state",
                current_state.ToString());gS.mG(gP,"PassedArgument",sPassedArgument);gS.mG(gP,"AlertStates",gX.ToString());
                gS.mG(gP,"craft_operation",gV.ToString());gS.mG(gP,"PassedArgument",sPassedArgument);gS.mG(gP,"ReceivedMessage",
                gY);gS.mG(gP,"SaveID",(long)SaveFile.EntityId);if(gS.mc){if(gS.mc){string gN=gS.mK();if(SaveFile==null)
                {Storage=gN;}else{SaveFile.WritePublicText(gN,false);}}}else{Echo("Not saving: Same");}}string gO="Wico Craft Save";
                string gP="WCCM2";void SerializeInitCustomData(lR iNIHolder){iNIHolder.mt(gP,"SAVE_FILE_NAME",ref gO,
                true);}IMyTextPanel SaveFile=null;lR gS;int current_state=0;long allBlocksCount=0;int gV=cH;string sPassedArgument
                ="";int gX=0;string gY="";string SerializeInit(){string fc="S";SaveFile=null;List&lt;IMyTerminalBlock&gt;U
                =new List&lt;IMyTerminalBlock&gt;();U=lm&lt;IMyTextPanel&gt;(gO);if(U.Count&gt;1)Echo("Multiple blocks found: \""+gO
                +"\"");else if(U.Count==0){U=lk&lt;IMyTextPanel&gt;(gO);if(U.Count==1)SaveFile=U[0]as IMyTextPanel;else{U=
                ll&lt;IMyTextPanel&gt;(gO);if(U.Count==1)SaveFile=U[0]as IMyTextPanel;}}else SaveFile=U[0]as IMyTextPanel;
                gS=new lR(this,"");if(SaveFile==null){fc="-";Echo(gO+" (TextPanel) is missing or Named incorrectly. ");
                }return fc;}bool ha(){return SaveFile!=null;}string hb(Vector3D v){string s;s=v.X.ToString("0.00")+":"
                +v.Y.ToString("0.00")+":"+v.Z.ToString("0.00");return s;}bool hc(string hd,out double x,out double y,
                out double z){string[]he=hd.Trim().Split(',');if(he.Length&lt;3){he=hd.Trim().Split(':');}x=0;y=0;z=0;if
                (he.Length&lt;3)return false;bool hf=double.TryParse(he[0].Trim(),out x);bool hg=double.TryParse(he[1].Trim(),
                out y);bool hh=double.TryParse(he[2].Trim(),out z);if(!hf||!hg||!hh){return false;}return true;}List&lt;IMyTerminalBlock&gt;
                hi=new List&lt;IMyTerminalBlock&gt;();float hj=0;double hk=-1;void hl(){hi.Clear();hk=-1;GridTerminalSystem.GetBlocksOfType&lt;IMySolarPanel&gt;(hi,
                lc);hm();}void hm(){if(hi.Count&gt;0)hk=0;hj=0;foreach(var tb in hi){IMySolarPanel r=tb as IMySolarPanel;
                hk+=r.MaxOutput;hj+=r.CurrentOutput;}}List&lt;IMyTerminalBlock&gt;hn=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                ho=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;hp=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                hq=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;hr=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                hs=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;ht=new List&lt;IMyTerminalBlock&gt;();double hu=0;double
                hv=0;double hw=0;double hx=0;double hy=0;double hz=0;int hA=0;int hB=0;int hC=0;const int hD=1;const
                int hE=2;const int hF=4;const int hG=0xff;Matrix hH=new Matrix(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);string
                hI="IGNORE";string hJ="cutter";string hK="THRUSTERS";void hL(lR iNIHolder){iNIHolder.mt(hK,"IgnoreThruster",
                ref hI);iNIHolder.mt(hK,"CutterThruster",ref hJ);}void hM(IMyTerminalBlock bw,ref List&lt;IMyTerminalBlock&gt;
                ho,ref List&lt;IMyTerminalBlock&gt;hp,ref List&lt;IMyTerminalBlock&gt;hq,ref List&lt;IMyTerminalBlock&gt;hr,ref List&lt;IMyTerminalBlock&gt;
                hs,ref List&lt;IMyTerminalBlock&gt;ht,int hN=hG){ho.Clear();hp.Clear();hq.Clear();hr.Clear();hs.Clear();ht.Clear();
                hn.Clear();if(bw==null)return;var hO=new List&lt;IMyTerminalBlock&gt;();li&lt;IMyThrust&gt;(ref hO);for(int i=0;
                i&lt;hO.Count;i++){if(hO[i].CustomName.ToLower().Contains(hJ)||hO[i].CustomData.ToLower().Contains(hJ))
                continue;if(hO[i].CustomName.ToLower().Contains(hI)||hO[i].CustomData.ToLower().Contains(hI))continue;
                hn.Add(hO[i]);}Matrix bx;bw.Orientation.GetMatrix(out bx);Matrix.Transpose(ref bx,out bx);hu=0;hv=0;
                hw=0;hx=0;hy=0;hz=0;for(int i=0;i&lt;hn.Count;++i){var hP=hn[i]as IMyThrust;Matrix hQ;hP.Orientation.GetMatrix(out
                hQ);Vector3 bz=Vector3.Transform(hQ.Backward,bx);int hR=hS(hn[i]);if(hR==hD)hC++;else if(hR==hE)hB++;
                else if(hR==hF)hA++;if(bz==hH.Left){hy+=hT((IMyThrust)hn[i]);hs.Add(hn[i]);}else if(bz==hH.Right){hz
                +=hT((IMyThrust)hn[i]);ht.Add(hn[i]);}else if(bz==hH.Backward){hv+=hT((IMyThrust)hn[i]);hp.Add(hn[i]);
                }else if(bz==hH.Forward){hu+=hT((IMyThrust)hn[i]);ho.Add(hn[i]);}else if(bz==hH.Up){hx+=hT((IMyThrust)hn[i]);
                hr.Add(hn[i]);}else if(bz==hH.Down){hw+=hT((IMyThrust)hn[i]);hq.Add(hn[i]);}}}string hM(IMyTerminalBlock
                bw){ho.Clear();hp.Clear();hq.Clear();hr.Clear();hs.Clear();ht.Clear();hn.Clear();if(bw==null)return"No Orientation Block";
                var hO=new List&lt;IMyTerminalBlock&gt;();li&lt;IMyThrust&gt;(ref hO);for(int i=0;i&lt;hO.Count;i++){if(hO[i].CustomName.ToLower().Contains(hJ)
                ||hO[i].CustomData.ToLower().Contains(hJ))continue;if(hO[i].CustomName.ToLower().Contains(hI)||hO[i].CustomData.ToLower().Contains(hI))
                continue;hn.Add(hO[i]);}Matrix bx;bw.Orientation.GetMatrix(out bx);Matrix.Transpose(ref bx,out bx);hu
                =0;hv=0;hw=0;hx=0;hy=0;hz=0;for(int i=0;i&lt;hn.Count;++i){var hP=hn[i]as IMyThrust;Matrix hQ;hP.Orientation.GetMatrix(out
                hQ);Vector3 bz=Vector3.Transform(hQ.Backward,bx);int hR=hS(hn[i]);if(hR==hD)hC++;else if(hR==hE)hB++;
                else if(hR==hF)hA++;if(bz==hH.Left){hy+=hT((IMyThrust)hn[i]);hs.Add(hn[i]);}else if(bz==hH.Right){hz
                +=hT((IMyThrust)hn[i]);ht.Add(hn[i]);}else if(bz==hH.Backward){hv+=hT((IMyThrust)hn[i]);hp.Add(hn[i]);
                }else if(bz==hH.Forward){hu+=hT((IMyThrust)hn[i]);ho.Add(hn[i]);}else if(bz==hH.Up){hx+=hT((IMyThrust)hn[i]);
                hr.Add(hn[i]);}else if(bz==hH.Down){hw+=hT((IMyThrust)hn[i]);hq.Add(hn[i]);}}string s;s="&gt;";s+="F"+ho.Count.ToString("00");
                s+="B"+hp.Count.ToString("00");s+="D"+hq.Count.ToString("00");s+="U"+hr.Count.ToString("00");s+="L"+
                hs.Count.ToString("00");s+="R"+ht.Count.ToString("00");s+="&lt;";return s;}int hS(IMyTerminalBlock theBlock)
                {if(theBlock is IMyThrust){if(theBlock.BlockDefinition.SubtypeId.Contains("Atmo"))return hD;else if(theBlock.BlockDefinition.SubtypeId.Contains("Hydro"))
                return hE;else return hF;}return 0;}double hT(IMyThrust thruster){return thruster.MaxEffectiveThrust;
                }double hU(List&lt;IMyTerminalBlock&gt;hV,int dH=hG){double hW=0;for(int hX=0;hX&lt;hV.Count;hX++){int hY=hS(hV[hX]);
                if((hY&amp;dH)&gt;0){IMyThrust hP=hV[hX]as IMyThrust;double hZ=hP.MaxEffectiveThrust;hW+=hZ;}}return hW;}bool
                ia(List&lt;IMyTerminalBlock&gt;hV,out float ib,out float dy,out float ic){ib=0;dy=0;ic=0;double id=hU(hV,hF);
                double ie=hU(hV,hD);double@if=hU(hV,hE);MyShipMass fj;fj=((IMyShipController)ln).CalculateShipMass();
                double ig=0;ig=fj.PhysicalMass*kk*9.810;if(ie&gt;0){if(ie&lt;ig){ib=100;ig-=ie;}else{ib=(float)(ig/ie*100);
                if(ib&gt;0)ig-=(ie*ib/100);}}if(id&gt;0&amp;&amp;ig&gt;0){if(id&lt;ig){ic=100;ig-=id;}else{ic=(float)(ig/id*100);if(ic&gt;0)
                ig-=((id*ic)/100);}}if(@if&gt;0&amp;&amp;ig&gt;0){if(@if&lt;ig){dy=100;ig-=@if;}else{dy=(float)(ig/@if*100);if(dy&gt;0)ig
                -=((@if*dy)/100);;}}if(ig&gt;0)return false;return true;}List&lt;IMyTerminalBlock&gt;ih(string ii){var ij=new
                List&lt;IMyTerminalBlock&gt;();var ik=new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(ik);for(int
                il=0;il&lt;ik.Count;il++){if(ik[il].Name==ii){List&lt;IMyTerminalBlock&gt;hV=null;ik[il].GetBlocks(hV,lc);for
                (int hX=0;hX&lt;hV.Count;hX++){ij.Add(hV[hX]);}break;}}return ij;}int im(List&lt;IMyTerminalBlock&gt;hV,float
                Q,int dH=hG){int@in=0;if(Q&gt;100)Q=100;if(Q&lt;0)Q=0;for(int hX=0;hX&lt;hV.Count;hX++){int hY=hS(hV[hX]);if((hY
                &amp;dH)&gt;0){IMyThrust hP=hV[hX]as IMyThrust;if(!hP.IsWorking){hP.Enabled=true;}@in+=1;hP.ThrustOverridePercentage
                =Q/100f;}}return@in;}int im(List&lt;IMyTerminalBlock&gt;hV,int io=100,int dH=hG){return im(hV,(float)io,dH);
                }bool im(string ip,int io=100,int dH=hG){if(io&gt;100)io=100;var ik=new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(ik);
                for(int il=0;il&lt;ik.Count;il++){if(ik[il].Name==ip){List&lt;IMyTerminalBlock&gt;hV=null;ik[il].GetBlocks(hV,
                lc);return(im(hV,io,dH)&gt;0);}}return false;}int iq(List&lt;IMyTerminalBlock&gt;thrusters,int dH=hG,bool ir=
                false){int@in=0;for(int hX=0;hX&lt;thrusters.Count;hX++){int hY=hS(thrusters[hX]);if((hY&amp;dH)&gt;0){@in++;IMyThrust
                hP=thrusters[hX]as IMyThrust;hP.ThrustOverride=0;if(hP.IsWorking&amp;&amp;ir)hP.Enabled=false;else if(!hP.IsWorking
                &amp;&amp;!ir)hP.Enabled=true;}}return@in;}bool iq(string ip){var ik=new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(ik);
                for(int il=0;il&lt;ik.Count;il++){if(ik[il].Name==ip){List&lt;IMyTerminalBlock&gt;hV=null;ik[il].GetBlocks(hV,
                lc);return(iq(hV)&gt;0);}}return false;}bool im(){return(im(ho)&gt;0);}bool iq(){return(iq(ho)&gt;0);}double@is(List&lt;IMyTerminalBlock&gt;
                it,int dH=hG){for(int i=0;i&lt;it.Count;i++){int hY=hS(it[i]);if((hY&amp;dH)&gt;0&amp;&amp;it[i].IsWorking){var hP=it[i]
                as IMyThrust;return hP.ThrustOverride;}}return 0;}bool iu(List&lt;IMyTerminalBlock&gt;it,int dH=hG){for(int
                i=0;i&lt;it.Count;i++){int hY=hS(it[i]);if((hY&amp;dH)&gt;0&amp;&amp;it[i].IsWorking){return true;}}return false;}int iv(List&lt;IMyTerminalBlock&gt;
                it,int dH=hG){int@in=0;for(int i=0;i&lt;it.Count;i++){int hY=hS(it[i]);if((hY&amp;dH)&gt;0&amp;&amp;it[i].IsWorking){@in++;
                }}return@in;}IMyThrust iw(List&lt;IMyTerminalBlock&gt;ix,int iy=hG){foreach(var thrust in hn){if(thrust is
                IMyThrust&amp;&amp;(hS(thrust)&amp;iy)&gt;0)return thrust as IMyThrust;}return null;}double iz(){if(hC&lt;1)return 0;var
                iA=iw(hn,hD);if(iA==null)return 0;return iA.MaxEffectiveThrust/iA.MaxThrust;}double iB(List&lt;IMyTerminalBlock&gt;
                hr,double iC,double iD){var fj=((IMyShipController)ln).CalculateShipMass();double ig=0;ig=fj.PhysicalMass
                *iD*9.810;double hT=hU(hr);double iE=(hT-ig)/fj.TotalMass;double iF=iC/iE;double iG=iC/2*iF;return iG;
                }string[]iH={"-","\\","|","/","-","\\","|","/"};int iI=99;string iJ(){iI++;if(iI&gt;=iH.Length)iI=0;return
                iH[iI];}const string iK="[WCCT]";const string iL="[WCCS]";const string iM="[WCCM]";Dictionary&lt;string,
                List&lt;IMyTerminalBlock&gt;&gt;iN=new Dictionary&lt;string,List&lt;IMyTerminalBlock&gt;&gt;();void iO(){iN.Clear();}bool
                iP(string iQ="[WCCS]"){bool iR=false;List&lt;IMyTerminalBlock&gt;U=new List&lt;IMyTerminalBlock&gt;();IMyTimerBlock
                iS=null;if(iN.ContainsKey(iQ)){U=iN[iQ];}else{U=lk&lt;IMyTerminalBlock&gt;(iQ);iN.Add(iQ,U);}for(int i=0;i
                &lt;U.Count;i++){iS=U[i]as IMyTimerBlock;if(iS!=null){iS.ApplyAction("TriggerNow");iR=true;}}return iR;
                }void iT(){Runtime.UpdateFrequency|=UpdateFrequency.Once;}bool iU=false;List&lt;IMyRadioAntenna&gt;iV=new List&lt;IMyRadioAntenna&gt;();
                List&lt;IMyLaserAntenna&gt;iW=new List&lt;IMyLaserAntenna&gt;();string iX(){iV.Clear();iW.Clear();li&lt;IMyRadioAntenna&gt;(ref
                iV);li&lt;IMyLaserAntenna&gt;(ref iW);for(int i=0;i&lt;iV.Count;++i){if(iV[i].CustomName.Contains("unused")||
                iV[i].CustomData.Contains("unused"))continue;if(!iU){a="Wico "+iV[i].CustomName.Split('!')[0].Trim();
                iU=true;}}return"A"+iV.Count.ToString("0");}void iY(){for(int i=0;i&lt;iV.Count;i++){iV[i].Enabled=true;
                }}string iZ="";void ja(){if(gY!=""){if(iZ==gY){gY="";}iZ=gY;}else iZ="";}void jb(){}void jc(){float jd
                =0;int je=-1;for(int i=0;i&lt;iV.Count;i++){if(iV[i].AttachedProgrammableBlock==Me.EntityId){je=i;break;
                }if(iV[i].Radius&gt;jd&amp;&amp;iV[i].AttachedProgrammableBlock==0){je=i;jd=iV[i].Radius;}}if(je&gt;=0){if(iV[je].AttachedProgrammableBlock
                !=Me.EntityId)fc+="\nSetting Antenna PB";iV[je].AttachedProgrammableBlock=Me.EntityId;}else{}}void jf(bool
                jg=false){if(iV.Count&lt;1)iX();foreach(var a in iV){a.Radius=200;if(a.AttachedProgrammableBlock&gt;0||jg)
                {a.Enabled=true;}}}void jh(float ji=200,bool jg=false){if(iV.Count&lt;1)iX();foreach(var a in iV){if(a.AttachedProgrammableBlock
                &gt;0||jg){a.Radius=ji;a.Enabled=true;}}}Vector3D jj(){if(iV.Count&lt;1)iX();foreach(var a in iV){if(a.AttachedProgrammableBlock
                ==Me.EntityId){return a.GetPosition();}}foreach(var a in iV){return a.GetPosition();}Vector3D jk=new
                Vector3D();return jk;}void jl(bool jg=false,float jm=float.MaxValue){if(iV.Count&lt;1)iX();if(jm&lt;200)jm
                =200;foreach(var a in iV){if(a.AttachedProgrammableBlock&gt;0||jg){float jn=a.GetMaximum&lt;float&gt;("Radius");
                if(jm&lt;jn)jn=jm;a.Radius=jn;a.Enabled=true;}}}int jo(){if(iV.Count&lt;1)iX();return(iV.Count);}List&lt;string&gt;
                jp=new List&lt;string&gt;();void jq(){if(jp.Count&gt;0){jr(jp[0]);jp.RemoveAt(0);}if(jp.Count&gt;0)kc=true;}void
                jr(string js){bool jt=false;if(iV.Count&lt;1)iX();for(int i=0;i&lt;iV.Count;i++){jt=iV[i].TransmitMessage(js);
                if(jt)break;}if(!jt){if(jo()&gt;0){jp.Add(js);kc=true;}}}List&lt;string&gt;ju=new List&lt;string&gt;();void jv(bool
                jw=false){if(ju.Count&gt;0){if(gY==""){gY=ju[0];ju.RemoveAt(0);if(jw){kc=true;}else{iT();}}}if(ju.Count
                &gt;0){}}void jx(string js){ju.Add(js);jv();}void jy(){if(iV.Count&gt;0){Echo(ju.Count+" Pending Incoming Messages");
                for(int i=0;i&lt;ju.Count;i++)Echo(i+":"+ju[i]);}else Echo("No antennas found");}List&lt;IMyTerminalBlock&gt;
                jz=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;jA=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                jB=new List&lt;IMyTerminalBlock&gt;();bool jC=false;string jD="[BASE]";string jE="[DOCK]";string jF="CONNECTORS";
                void jG(lR iNIHolder){iNIHolder.mt(jF,"BaseConnector",ref jD,true);iNIHolder.mt(jF,"DockConnector",ref
                jE,true);}string jH(){jC=false;jz.Clear();jA.Clear();jB.Clear();jI();return"CL"+jz.Count.ToString()+
                "CD"+jA.Count.ToString()+"CB"+jB.Count.ToString();}void jI(){if(jz.Count&lt;1&amp;&amp;!jC)jz=li&lt;IMyShipConnector&gt;();
                if(jA.Count&lt;1&amp;&amp;!jC)jA=lk&lt;IMyShipConnector&gt;(jE);if(jA.Count&lt;1&amp;&amp;!jC)jA=jz;if(jB.Count&lt;1&amp;&amp;!jC)jB=lk&lt;IMyShipConnector&gt;(jD);
                jC=true;return;}bool jJ(){jI();for(int i=0;i&lt;jA.Count;i++){var sc=jA[i]as IMyShipConnector;if(sc.Status
                ==MyShipConnectorStatus.Connectable)return true;}return false;}bool jK(){jI();for(int i=0;i&lt;jA.Count;
                i++){var sc=jA[i]as IMyShipConnector;if(sc.Status==MyShipConnectorStatus.Connected){var jL=sc.OtherConnector;
                if(jL.CubeGrid==sc.CubeGrid){continue;}else return true;}}return false;}IMyTerminalBlock jM(){jI();if
                (jA.Count&gt;0){return jA[0];}return null;}IMyTerminalBlock jN(bool jO=false){jI();for(int i=0;i&lt;jA.Count;
                i++){var sc=jA[i]as IMyShipConnector;if(sc.Status==MyShipConnectorStatus.Connected){var jL=sc.OtherConnector;
                if(jL.CubeGrid==sc.CubeGrid){continue;}else{if(!jO){return sc.OtherConnector;}else{return jA[i];}}}}
                return null;}void jP(bool jQ=true,bool V=true){jI();for(int i=0;i&lt;jA.Count;i++){var sc=jA[i]as IMyShipConnector;
                if(sc.Status==MyShipConnectorStatus.Connected){var jL=sc.OtherConnector;if(jL.CubeGrid==sc.CubeGrid)
                {continue;}}if(jQ){if(sc.Status==MyShipConnectorStatus.Connectable)sc.ApplyAction("SwitchLock");}else
                {if(sc.Status==MyShipConnectorStatus.Connected)sc.ApplyAction("SwitchLock");}sc.Enabled=V;}return;}Dictionary&lt;string,
                int&gt;jR=new Dictionary&lt;string,int&gt;();string jS="";UpdateFrequency jT=UpdateFrequency.Once;bool jU=true;
                bool jV=true;float jW=100;string jX="WORLD";bool jY=false;void jZ(lR u){u.mt(jX,"MaxWorldMps",ref jW,
                true);}public Program(){eZ();lR fb=new lR(this,Me.CustomData);jZ(fb);kG(fb);eb(fb);fa(fb);if(fb.mc){
                Me.CustomData=fb.mK(true);}jS=a+":"+b+" V"+c+" ";Echo(jS+"Creator");eC();ey("clear",eg,true);if(!iP(iM))
                {Runtime.UpdateFrequency|=UpdateFrequency.Update100;}if(!Me.Enabled){Echo("I am turned OFF!");}}bool
                ka=false;bool kb=false;bool kc=false;bool bWantMedium=false;bool ke=false;double kf;double kg=5;double
                kh=-1;double ki=3;double kj=-1;double kk=-2;void Main(string gu,UpdateType ut){Echo(jS+iJ());kc=false;
                bWantMedium=false;if(kh&gt;kg){kh=0;ke=false;var ix=new List&lt;IMyTerminalBlock&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyProjector&gt;(ix,
                lc);for(int i=0;i&lt;ix.Count;i++){if(ix[i].IsWorking){if(ix[i].CustomName.Contains("!WCC")||ix[i].CustomData.Contains("!WCC"))
                continue;Echo("Working local Projector found!");ke=true;}}}else{if(kh&lt;0){kh=kg+5;}kh+=Runtime.TimeSinceLastRun.TotalSeconds;
                }sPassedArgument="";double kl=0;if(ln is IMyShipController){if(kj&gt;ki||!ka){Echo("DO Grid Check");kj=
                0;MyShipMass fj;fj=((IMyShipController)ln).CalculateShipMass();kl=fj.BaseMass;Echo("New="+kl+" CurrentM="
                +fe);if(fj.BaseMass==0)Echo("No Mass--Station?");if(kl!=fe&amp;&amp;fe&gt;0){Echo("MASS CHANGE");ey(a+":"+b+":MASS CHANGE",
                eg,true);}}else{if(kj&lt;0){kj=ki+5;}kj+=Runtime.TimeSinceLastRun.TotalSeconds;kl=fe;}}else{fe=kl=0;}if
                (gu=="init"||(Math.Abs(kl-fe)&gt;1&amp;&amp;fe&gt;0&amp;&amp;fd==0)||(fd==0&amp;&amp;kM())){eK("INIT or GRID/MASS CHANGE!");Echo("Arg init or grid/mass change!");
                fc="";ka=false;fd=0;sPassedArgument="init";}eK("clear");if(!ka){if(ke){eK("Construction in Progress\nTurn off projector to continue");
                ey("Construction in Progress\nTurn off projector to continue",ei);}else{kc=true;}doInit();kb=true;}else
                {if(jU)cV();sPassedArgument=gu;if(kb){ey(DateTime.Now.ToString()+" "+fc,eg,true);}IMyTerminalBlock km
                =ln;if(ln!=null){}if(ln is IMyShipController){kf=((IMyShipController)ln).GetShipSpeed();Vector3D kn=
                ((IMyShipController)ln).GetNaturalGravity();double ko=kn.Length();kk=ko/9.81;}else{kk=-1.0;}if(gt(gu))
                {eD();return;}i();di();}if(jU)gM();if((SaveFile==null)){if(jU)Echo("Cannot use sub-modules; missing controller and/or SaveFile");
                }else{if(ka){iP();}}if(kc){Echo("FAST!");Runtime.UpdateFrequency|=jT;}else{Runtime.UpdateFrequency&amp;=
                ~(jT);}if(bWantMedium){Runtime.UpdateFrequency|=UpdateFrequency.Update10;}else{Runtime.UpdateFrequency
                &amp;=~(UpdateFrequency.Update10);}kb=false;if(jV)Echo(craftOperation());m();eD();}void kp(string jS=null)
                {float kq=0;kq=Runtime.CurrentInstructionCount/(float)Runtime.MaxInstructionCount;if(jS==null)jS="Instructions=";
                Echo(jS+(kq*100).ToString("0.00")+"%");}List&lt;IMyTerminalBlock&gt;kr=new List&lt;IMyTerminalBlock&gt;();string
                ks(){List&lt;IMyTerminalBlock&gt;kt=new List&lt;IMyTerminalBlock&gt;();kr.Clear();kt=li&lt;IMyShipDrill&gt;();foreach(var
                b in kt)kr.Add(b as IMyTerminalBlock);return"D"+kr.Count.ToString("00");}void ku(){foreach(IMyFunctionalBlock
                b in kr){b.Enabled=true;}}void kv(){if(kr.Count&lt;1)ks();foreach(IMyFunctionalBlock b in kr){b.Enabled
                =false;}}bool kw(){if(kr.Count&lt;1)ks();if(kr.Count&lt;1)return false;return true;}List&lt;IMyTerminalBlock&gt;
                kx=new List&lt;IMyTerminalBlock&gt;();string ky(){List&lt;IMyTerminalBlock&gt;kt=new List&lt;IMyTerminalBlock&gt;();kx.Clear();
                kt=lk&lt;IMyShipConnector&gt;("Ejector");foreach(var b in kt)kx.Add(b as IMyTerminalBlock);return"E"+kx.Count.ToString("00");
                }void kz(){foreach(IMyFunctionalBlock b in kx){b.Enabled=true;}}void kA(){if(kx.Count&lt;1)ky();foreach
                (IMyFunctionalBlock b in kx){b.Enabled=false;}}string kB="NOFOLLOW";string kC="!WCC";string kD="[NAV]";
                string kE="Craft Remote Control";string kF="GRIDS";void kG(lR iNIHolder){iNIHolder.mt(kF,"NoFollow",
                ref kB,true);iNIHolder.mt(kF,"BlockIgnore",ref kC,true);iNIHolder.mt(kF,"OrientationBlockContains",ref
                kD,true);iNIHolder.mt(kF,"OrientationBlockNamed",ref kE,true);}List&lt;IMyTerminalBlock&gt;kH=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyCubeGrid&gt;kI=new List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;kJ=new List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;
                kK=new List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;kL=new List&lt;IMyCubeGrid&gt;();bool kM(){List&lt;IMyTerminalBlock&gt;
                kN=new List&lt;IMyTerminalBlock&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyTerminalBlock&gt;(kN);if(allBlocksCount
                !=kN.Count){return true;}return false;}string kO(){kH.Clear();kL.Clear();kI.Clear();kJ.Clear();kK.Clear();
                GridTerminalSystem.GetBlocksOfType&lt;IMyTerminalBlock&gt;(kH);allBlocksCount=kH.Count;foreach(var block in
                kH){var cv=block.CubeGrid;if(!kL.Contains(cv)){kL.Add(cv);}}kR(Me.CubeGrid);foreach(var grid in kL){
                if(kI.Contains(grid))continue;bool kP=false;List&lt;IMyShipConnector&gt;kQ=new List&lt;IMyShipConnector&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyShipConnector&gt;(kQ,
                (x1=&gt;x1.CubeGrid==grid));foreach(var connector in kQ){if(connector.Status==MyShipConnectorStatus.Connected)
                {if(kI.Contains(connector.OtherConnector.CubeGrid)||kJ.Contains(connector.OtherConnector.CubeGrid)){
                continue;}if(kI.Contains(connector.OtherConnector.CubeGrid))kP=true;else kP=false;}}if(kP){if(!kK.Contains(grid))
                {kK.Add(grid);}}if(!kJ.Contains(grid)){kJ.Add(grid);}}string s="";s+="B"+kH.Count.ToString();s+="G"+
                kL.Count.ToString();s+="L"+kI.Count.ToString();s+="D"+kK.Count.ToString();s+="R"+kJ.Count.ToString();
                return s;}void kR(IMyCubeGrid cv){if(cv==null)return;if(!kI.Contains(cv)){kI.Add(cv);kS(cv);kV(cv);kX(cv);
                kZ(cv);}}void kS(IMyCubeGrid grid){List&lt;IMyMotorStator&gt;kT=new List&lt;IMyMotorStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(kT,
                (x=&gt;x.TopGrid==grid));foreach(var rotor in kT){if(rotor.CustomName.Contains(kB)||rotor.CustomData.Contains(kB))
                continue;kR(rotor.CubeGrid);}List&lt;IMyMotorAdvancedStator&gt;kU=new List&lt;IMyMotorAdvancedStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorAdvancedStator&gt;(kU,
                (x=&gt;x.TopGrid==grid));foreach(var rotor in kU){if(rotor.CustomName.Contains(kB)||rotor.CustomData.Contains(kB))
                continue;kR(rotor.CubeGrid);}}void kV(IMyCubeGrid grid){List&lt;IMyPistonBase&gt;kW=new List&lt;IMyPistonBase&gt;();
                GridTerminalSystem.GetBlocksOfType&lt;IMyPistonBase&gt;(kW,(x=&gt;x.TopGrid==grid));foreach(var piston in kW)
                {kR(piston.CubeGrid);}}void kX(IMyCubeGrid grid){List&lt;IMyMotorStator&gt;kT=new List&lt;IMyMotorStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(kT,
                (x1=&gt;x1.CubeGrid==grid));foreach(var rotor in kT){if(rotor.CustomName.Contains(kB)||rotor.CustomData.Contains(kB))
                continue;IMyCubeGrid kY=rotor.TopGrid;if(kY!=null&amp;&amp;kY!=grid){kR(kY);}}kT.Clear();List&lt;IMyMotorAdvancedStator&gt;
                kU=new List&lt;IMyMotorAdvancedStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorAdvancedStator&gt;(kU,
                (x1=&gt;x1.CubeGrid==grid));foreach(var rotor in kU){if(rotor.CustomName.Contains(kB)||rotor.CustomData.Contains(kB))
                continue;IMyCubeGrid kY=rotor.TopGrid;if(kY!=null&amp;&amp;kY!=grid){kR(kY);}}}void kZ(IMyCubeGrid grid){List&lt;IMyPistonBase&gt;
                kW=new List&lt;IMyPistonBase&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyPistonBase&gt;(kW,(x1=&gt;x1.CubeGrid==
                grid));foreach(var piston in kW){IMyCubeGrid kY=piston.TopGrid;if(kY!=null&amp;&amp;kY!=grid){if(!kI.Contains(kY))
                {kR(kY);}}}}List&lt;IMyCubeGrid&gt;la(){if(kI.Count&lt;1){kO();}return kI;}List&lt;IMyCubeGrid&gt;lb(){if(kI.Count&lt;
                1){kO();}return kK;}bool lc(IMyTerminalBlock block){return la().Contains(block.CubeGrid);}bool ld(long
                le){for(int i=0;i&lt;kI.Count;i++){if((long)kI[i].EntityId==le)return true;}return false;}bool ld(IMyCubeGrid
                le){return la().Contains(le);}bool lf(IMyTerminalBlock A){List&lt;IMyCubeGrid&gt;g=lb();if(g==null)return false;
                return g.Contains(A.CubeGrid);}IMyTerminalBlock lg(string lh){IMyTerminalBlock A;A=(IMyTerminalBlock)GridTerminalSystem.GetBlockWithName(lh);
                if(A==null)throw new Exception(lh+" Not Found");return A;}public List&lt;T&gt;li&lt;T&gt;(ref List&lt;T&gt;kt,string lj
                =null)where T:class{if(kH.Count&lt;1)kO();if(kt==null)kt=new List&lt;T&gt;();else kt.Clear();for(int e=0;e&lt;kH.Count;
                e++){if(lc(kH[e])&amp;&amp;kH[e]is T&amp;&amp;((lj==null)||(lj!=null&amp;&amp;kH[e].CustomName.StartsWith(lj)))){kt.Add((T)kH[e]);
                }}return kt;}public List&lt;IMyTerminalBlock&gt;li&lt;T&gt;(ref List&lt;IMyTerminalBlock&gt;Output,string Keyword=null)where
                T:class{if(kH.Count&lt;1)kO();if(Output==null)Output=new List&lt;IMyTerminalBlock&gt;();else Output.Clear();for
                (int e=0;e&lt;kH.Count;e++){if(lc(kH[e])&amp;&amp;kH[e]is T&amp;&amp;((Keyword==null)||(Keyword!=null&amp;&amp;kH[e].CustomName.StartsWith(Keyword))))
                {Output.Add(kH[e]);}}return Output;}public List&lt;IMyTerminalBlock&gt;li&lt;T&gt;(string Keyword=null)where T:class
                {var kt=new List&lt;IMyTerminalBlock&gt;();li&lt;T&gt;(ref kt,Keyword);return kt;}public List&lt;IMyTerminalBlock&gt;lk&lt;T&gt;(string
                Keyword=null)where T:class{if(kH.Count&lt;1)kO();var kt=new List&lt;IMyTerminalBlock&gt;();for(int e=0;e&lt;kH.Count;
                e++){if(kH[e]is T&amp;&amp;lc(kH[e])&amp;&amp;Keyword!=null&amp;&amp;(kH[e].CustomName.Contains(Keyword)||kH[e].CustomData.Contains(Keyword))
                &amp;&amp;!(kH[e].CustomName.Contains(kC)||kH[e].CustomData.Contains(kC))){kt.Add(kH[e]);}}return kt;}public
                List&lt;IMyTerminalBlock&gt;ll&lt;T&gt;(string lj=null)where T:class{if(kH.Count&lt;1)kO();var kt=new List&lt;IMyTerminalBlock&gt;();
                for(int e=0;e&lt;kH.Count;e++){if(kH[e]is T&amp;&amp;Me.CubeGrid==kH[e].CubeGrid&amp;&amp;lj!=null&amp;&amp;(kH[e].CustomName.Contains(lj)
                ||kH[e].CustomData.Contains(lj))&amp;&amp;!(kH[e].CustomName.Contains(kC)||kH[e].CustomData.Contains(kC))){kt.Add(kH[e]);
                }}return kt;}public List&lt;IMyTerminalBlock&gt;lm&lt;T&gt;(string lj=null)where T:class{if(kH.Count&lt;1)kO();var kt
                =new List&lt;IMyTerminalBlock&gt;();for(int e=0;e&lt;kH.Count;e++){if(kH[e]is T&amp;&amp;lc(kH[e])&amp;&amp;lj!=null&amp;&amp;kH[e].CustomName
                ==lj){kt.Add(kH[e]);}}return kt;}IMyTerminalBlock ln=null;string DefaultOrientationBlockInit(){string
                sInitResults="";var centerSearch=new List&lt;IMyTerminalBlock&gt;();li&lt;IMyTerminalBlock&gt;(ref centerSearch,
                kE);if(centerSearch.Count==0){centerSearch=lk&lt;IMyRemoteControl&gt;(kD);if(centerSearch.Count==0){li&lt;IMyRemoteControl&gt;(ref
                centerSearch);if(centerSearch.Count==0){li&lt;IMyCockpit&gt;(ref centerSearch);int i=0;for(;i&lt;centerSearch.Count;
                i++){Echo("Checking Controller:"+centerSearch[i].CustomName);if(centerSearch[i]is IMyCryoChamber)continue;
                break;}if(i&gt;=centerSearch.Count){sInitResults+="!!NO valid Controller";Echo("No Controller found");}
                else{sInitResults+="S";Echo("Using good ship Controller: "+centerSearch[i].CustomName);}}else{sInitResults
                +="R";Echo("Using First Remote control found: "+centerSearch[0].CustomName);}}}else{sInitResults+="N";
                Echo("Using Named: "+centerSearch[0].CustomName);}if(centerSearch.Count&gt;0)ln=centerSearch[0];return sInitResults;
                }string lq="!NAV";void lr(lR u){u.mt(kF,"GyroIgnore",ref lq,true);}double ls=0.9;int lt=3;int lu=-1;
                IMyShipController lv;List&lt;IMyGyro&gt;lw;float lx=0.01f;bool ly(string lz){if(lv==null)lN();if(lv is IMyShipController)
                {Vector3D lA=(lv as IMyShipController).GetNaturalGravity();return ly(lz,lA,ln);}else{Echo("No Controller for gravity");
                }return true;}bool ly(string lz,Vector3D lB,IMyTerminalBlock lC){bool lD=true;if(lv==null)lN();Matrix
                or;lC.Orientation.GetMatrix(out or);Vector3D lE;lz=lz.ToLower();if(lz.Contains("rocket"))lE=or.Backward;
                else if(lz.Contains("up"))lE=or.Up;else if(lz.Contains("backward"))lE=or.Backward;else if(lz.Contains("forward"))
                lE=or.Forward;else lE=or.Down;lB.Normalize();for(int i=0;i&lt;lw.Count;++i){var g=lw[i];g.Orientation.GetMatrix(out
                or);var lF=Vector3D.Transform(lE,MatrixD.Transpose(or));var lG=Vector3D.Transform(lB,MatrixD.Transpose(g.WorldMatrix.GetOrientation()));
                var lH=Vector3D.Cross(lF,lG);double lI=Vector3D.Dot(lF,lG);double lJ=lH.Length();lJ=Math.Atan2(lJ,Math.Sqrt(Math.Max(0.0,
                1.0-lJ*lJ)));if(lI&lt;0)lJ=Math.PI-lJ;if(lJ&lt;lx){g.GyroOverride=false;continue;}float lK=g.GetMaximum&lt;float&gt;("Yaw");
                double lL=lK*(lJ/Math.PI)*ls;lL=Math.Min(lK,lL);lL=Math.Max(0.01,lL);lH.Normalize();lH*=lL;float bn=
                -(float)lH.X;g.Pitch=bn;float bo=-(float)lH.Y;g.Yaw=bo;float lM=-(float)lH.Z;g.Roll=lM;g.GyroOverride
                =true;lD=false;}return lD;}string lN(){string s="";var l=new List&lt;IMyTerminalBlock&gt;();lv=ln as IMyShipController;
                if(lv==null){if(l.Count&lt;1)return"No RC!";}lQ();GridTerminalSystem.GetBlocksOfType&lt;IMyGyro&gt;(l,x=&gt;x.CubeGrid
                ==ln.CubeGrid);var l2=new List&lt;IMyTerminalBlock&gt;();int lO=0;for(int i=0;i&lt;l.Count;i++){if(l[i].CustomName.Contains(lq)
                ||l[i].CustomData.Contains(lq)){lO++;continue;}l2.Add(l[i]);}lw=l2.ConvertAll(x=&gt;(IMyGyro)x);if(lt&gt;0)
                if(lw.Count&gt;lt)lw.RemoveRange(lt,lw.Count-lt);else if((lu-lO)&gt;0){int lP=lw.Count-(lu-lO);lw.RemoveRange(lP,
                (lu-lO));}lQ();s+="GYRO#"+lw.Count.ToString("00")+"#";return s;}void lQ(){if(lw!=null){for(int i=0;i
                &lt;lw.Count;++i){lw[i].GyroOverride=false;lw[i].Enabled=true;}}}public class lR{Dictionary&lt;string,string&gt;
                lS;Dictionary&lt;string,string[]&gt;lT;Dictionary&lt;string,Dictionary&lt;string,string&gt;&gt;lU;char lV='[';char lW=
                ']';string lX="";MyGridProgram bI;string lY="";static string[]lZ={"true","yes","on","1"};const StringComparison
                ma=StringComparison.OrdinalIgnoreCase;const char mb='=';public bool mc{get;private set;}=false;public
                lR(MyGridProgram pg,string gN){bI=pg;lS=new Dictionary&lt;string,string&gt;();lT=new Dictionary&lt;string,string[]&gt;();
                lU=new Dictionary&lt;string,Dictionary&lt;string,string&gt;&gt;();md(gN);}public int md(string gN){gN.TrimEnd();
                if(lY==gN){return lS.Count;}lS.Clear();lT.Clear();lU.Clear();lX="";mc=false;lY=gN;string[]me=gN.Split('\n');
                for(int mf=0;mf&lt;me.Count();mf++){string mg="";me[mf].Trim();if(me[mf].StartsWith(lV.ToString())){string
                bC="";for(int mh=1;mh&lt;me[mf].Length;mh++)if(me[mf][mh]==lW)break;else bC+=me[mf][mh];if(bC!=""){mg=bC.ToUpper();
                }else continue;mf++;string mi="";var mj=new string[me.Count()-mf];int mk=0;var ml=new Dictionary&lt;string,
                string&gt;();for(;mf&lt;me.Count();mf++){me[mf].Trim();if(me[mf].StartsWith(lV.ToString())){mf--;break;}mi
                +=me[mf]+"\n";mj[mk++]=me[mf];if(me[mf].Contains(mb)){string[]mm=me[mf].Split('=');if(mm.Count()&gt;1){
                string mn=mm[0];string mo="";for(int i1=1;i1&lt;mm.Count();i1++){mo+=mm[i1];if(i1+1&lt;mm.Count())mo+=mb;}
                ml.Add(mn,mo);}}}lU.Add(mg,ml);lT.Add(mg,mj);lS.Add(mg,mi);}else{lX+=me[mf]+"\n";}}return lS.Count;}
                public string mp(string mq){string mi="";if(lS.ContainsKey(mq))mi=lS[mq];return mi;}public string[]mr(string
                mq){string[]ms={""};if(lT.ContainsKey(mq))ms=lT[mq];return ms;}public bool mt(string mq,string mn,ref
                string mu,bool mv=false){if(lU.ContainsKey(mq)){var mw=lU[mq];if(mw.ContainsKey(mn)){mu=mw[mn];return
                true;}}if(mv)mG(mq,mn,mu);return false;}public bool mt(string mq,string mn,ref long mx,bool mv=false)
                {string my="";if(!mt(mq,mn,ref my)){if(mv){mG(mq,mn,mx);}return false;}mx=Convert.ToInt64(my);return
                true;}public bool mt(string mq,string mn,ref int mz,bool mv=false){string my="";if(!mt(mq,mn,ref my))
                {if(mv){mG(mq,mn,mz);}return false;}mz=Convert.ToInt32(my);return true;}public bool mt(string mq,string
                mn,ref double mA,bool mv=false){string my="";if(!mt(mq,mn,ref my)){if(mv){mG(mq,mn,mA);}return false;
                }bool mB=double.TryParse(my,out mA);return true;}public bool mt(string mq,string mn,ref float mC,bool
                mv=false){string my="";if(!mt(mq,mn,ref my)){if(mv){mG(mq,mn,mC.ToString());}return false;}bool mB=float.TryParse(my,
                out mC);return true;}public bool mt(string mq,string mn,ref DateTime mD,bool mv=false){string my="";
                if(!mt(mq,mn,ref my)){if(mv){mG(mq,mn,mD);}return false;}mD=DateTime.Parse(my);return true;}public bool
                mt(string mq,string mn,ref Vector3D mE,bool mv=false){string my="";if(!mt(mq,mn,ref my)){if(mv){mG(mq,
                mn,mE);}return false;}double x1,y1,z1;hc(my,out x1,out y1,out z1);mE.X=x1;mE.Y=y1;mE.Z=z1;return true;
                }public bool mt(string mq,string mn,ref bool mF,bool mv=false){string my="";if(!mt(mq,mn,ref my)){if
                (mv){mG(mq,mn,mF);}return false;}mF=lZ.Any(c=&gt;string.Equals(my,c,ma));return true;}public bool mG(string
                section,string key,string my){if(lS.ContainsKey(section)){lS[section]="";}else{lS.Add(section,"");mc
                =true;}if(lU.ContainsKey(section)){var ml=new Dictionary&lt;string,string&gt;();var mw=lU[section];if(mw.ContainsKey(key))
                {if(mw[key]==my)return false;mw[key]=my;}else{mw.Add(key,my);}mc=true;}else{var ml=new Dictionary&lt;string,
                string&gt;();ml.Add(key,my);lU.Add(section,ml);mc=true;}return true;}public bool mG(string mq,string mn,
                Vector3D mE){mG(mq,mn,hb(mE));return true;}public bool mG(string mq,string mn,bool mF){mG(mq,mn,mF.ToString());
                return true;}public bool mG(string mq,string mn,int mH){mG(mq,mn,mH.ToString());return true;}public bool
                mG(string mq,string mn,long mI){mG(mq,mn,mI.ToString());return true;}public bool mG(string mq,string
                mn,DateTime mD){mG(mq,mn,mD.ToString());return true;}public bool mG(string mq,string mn,float mC){mG(mq,
                mn,mC.ToString());return true;}public bool mG(string mq,string mn,double mA){mG(mq,mn,mA.ToString());
                return true;}public void mJ(string mq,string mi){mi.TrimEnd();mq=mq.ToUpper();if(lS.ContainsKey(mq))
                {if(lS[mq]!=mi){lS[mq]=mi;mc=true;}}else{mc=true;lS.Add(mq,mi);}}public string mK(bool mL=true){string
                mM="";string s1=lX.Trim();if(s1!="")mM=s1+"\n";foreach(var kv in lS){mM+=lV+kv.Key.Trim()+lW+"\n";if
                (kv.Value.TrimEnd()==""){string mN="";if(lU.ContainsKey(kv.Key)){foreach(var dk in lU[kv.Key]){mN+=dk.Key
                +mb+dk.Value+"\n";}}mN+="\n";mM+=mN;}else{mM+=kv.Value.Trim()+"\n\n";}}if(mL){mc=false;lY=mM;}return
                mM;}bool hc(string hd,out double x,out double y,out double z){string[]he=hd.Trim().Split(',');if(he.Length
                &lt;3){he=hd.Trim().Split(':');}x=0;y=0;z=0;if(he.Length&lt;3)return false;bool hf=double.TryParse(he[0].Trim(),
                out x);bool hg=double.TryParse(he[1].Trim(),out y);bool hh=double.TryParse(he[2].Trim(),out z);if(!hf
                ||!hg||!hh){return false;}return true;}string hb(Vector3D v){string s;s=v.X.ToString("0.00")+":"+v.Y.ToString("0.00")
                +":"+v.Z.ToString("0.00");return s;}}int mO=80;int mP=20;double mQ=0;string sPowerSection="POWER";void
                mS(lR iNIHolder){iNIHolder.mt(sPowerSection,"batterypcthigh",ref mO,true);iNIHolder.mt(sPowerSection,
                "batterypctlow",ref mP,true);}void mT(){mQ=0;Echo("Init Reactors");gH();Echo("Init Solar");hl();Echo("Init Batteries");
                E();if(gF&gt;0)mQ+=gF;if(w&gt;0)mQ+=w;}List&lt;IMyTerminalBlock&gt;mU=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                mV=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;mW=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                mX=new List&lt;IMyTerminalBlock&gt;();string mY(IMyTerminalBlock bw){mU.Clear();mV.Clear();mW.Clear();mX.Clear();
                li&lt;IMyMotorSuspension&gt;(ref mU);for(int i=0;i&lt;mU.Count;i++){if(mU[i].CustomName.Contains("[SLED]")||mU[i].CustomData.Contains("[SLED]"))
                {mV.Add(mU[i]);if(mU[i].CustomName.Contains("[REAR]")||mU[i].CustomData.Contains("[FRONT]")){mW.Add(mU[i]);
                }if(mU[i].CustomName.Contains("[FRONT]")||mU[i].CustomData.Contains("[FRONT]")){mX.Add(mU[i]);}}}return
                "W"+mU.Count.ToString("0")+"WS"+mV.Count.ToString("0")+"SR"+mW.Count.ToString("0")+"SF"+mX.Count.ToString("0");
                }bool mZ(){if(mV.Count&gt;0)return true;return false;}void na(){for(int i1=0;i1&lt;mV.Count;i1++){var w1=mV[i1]
                as IMyMotorSuspension;w1.SetValueFloat("Friction",0);}}
              </Program>
              <Storage />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="3" y="6" z="-2" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="5" z="5" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="5" z="5" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="5" z="5" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockLargeAtmosphericThrust</SubtypeName>
              <EntityId>132434314204544965</EntityId>
              <Min x="-1" y="3" z="6" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Large Atmospheric Thruster</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-2" y="5" z="7" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="5" z="9" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="2" y="5" z="7" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="-2" y="4" z="-2" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="2" y="6" z="-2" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_BatteryBlock">
              <SubtypeName>SmallBlockBatteryBlock</SubtypeName>
              <EntityId>136453252890745494</EntityId>
              <Min x="-3" y="4" z="0" />
              <BlockOrientation Forward="Forward" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Battery 2</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <CurrentStoredPower>1.08</CurrentStoredPower>
              <ProducerEnabled>true</ProducerEnabled>
              <MaxStoredPower>0</MaxStoredPower>
              <SemiautoEnabled>false</SemiautoEnabled>
              <OnlyDischargeEnabled>false</OnlyDischargeEnabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_TimerBlock">
              <SubtypeName>TimerBlockSmall</SubtypeName>
              <EntityId>76263049764218654</EntityId>
              <Min x="0" y="5" z="-2" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyModStorageComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_ModStorageComponent">
                      <Storage>
                        <dictionary>
                          <item>
                            <Key>74de02b3-27f9-4960-b1c4-27351f2b06d1</Key>
                            <Value />
                          </item>
                        </dictionary>
                      </Storage>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Timer Block [WCCS]</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Toolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots>
                  <Slot>
                    <Index>0</Index>
                    <Item />
                    <Data xsi:type="MyObjectBuilder_ToolbarItemTerminalBlock">
                      <Action>Run</Action>
                      <Parameters>
                        <MyObjectBuilder_ToolbarItemActionParameter>
                          <TypeCode>String</TypeCode>
                          <Value>wccs</Value>
                        </MyObjectBuilder_ToolbarItemActionParameter>
                      </Parameters>
                      <BlockEntityId>104155146496065227</BlockEntityId>
                    </Data>
                  </Slot>
                </Slots>
              </Toolbar>
              <Delay>10000</Delay>
              <CurrentTime>0</CurrentTime>
              <IsCountingDown>false</IsCountingDown>
              <Silent>false</Silent>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_BatteryBlock">
              <SubtypeName>SmallBlockBatteryBlock</SubtypeName>
              <EntityId>139730556488652266</EntityId>
              <Min x="2" y="4" z="0" />
              <BlockOrientation Forward="Forward" Up="Right" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Battery 3</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <CurrentStoredPower>1.08</CurrentStoredPower>
              <ProducerEnabled>true</ProducerEnabled>
              <MaxStoredPower>0</MaxStoredPower>
              <SemiautoEnabled>false</SemiautoEnabled>
              <OnlyDischargeEnabled>false</OnlyDischargeEnabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="4" z="-3" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="4" z="-2" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-3" y="5" z="-2" />
              <BlockOrientation Forward="Right" Up="Backward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="3" y="5" z="-2" />
              <BlockOrientation Forward="Left" Up="Backward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="5" z="6" />
              <BlockOrientation Forward="Backward" Up="Right" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="5" z="8" />
              <BlockOrientation Forward="Forward" Up="Right" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="2" y="5" z="5" />
              <BlockOrientation Forward="Backward" Up="Right" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="5" z="-2" />
              <BlockOrientation Forward="Right" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="2" y="5" z="9" />
              <BlockOrientation Forward="Forward" Up="Right" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="5" z="9" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="5" z="6" />
              <BlockOrientation Forward="Backward" Up="Left" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-2" y="5" z="5" />
              <BlockOrientation Forward="Backward" Up="Left" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="5" z="8" />
              <BlockOrientation Forward="Forward" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-2" y="5" z="9" />
              <BlockOrientation Forward="Forward" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="5" z="9" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="6" z="-3" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>87486955585817772</EntityId>
              <Min x="-3" y="5" z="6" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Atmospheric Thrusters B</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>99744604371566109</EntityId>
              <Min x="3" y="5" z="6" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Atmospheric Thrusters A</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="5" z="-2" />
              <BlockOrientation Forward="Left" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="6" z="-3" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="-3" y="6" z="-2" />
              <BlockOrientation Forward="Right" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_MyProgrammableBlock">
              <SubtypeName>SmallProgrammableBlock</SubtypeName>
              <EntityId>104155146496065227</EntityId>
              <Min x="1" y="5" z="-2" />
              <BlockOrientation Forward="Left" Up="Backward" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyModStorageComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_ModStorageComponent">
                      <Storage>
                        <dictionary>
                          <item>
                            <Key>74de02b3-27f9-4960-b1c4-27351f2b06d1</Key>
                            <Value>
                              [WORLD]
                              MaxWorldMps=100

                              [GRIDS]
                              NoFollow=NOFOLLOW
                              BlockIgnore=!WCC
                              OrientationBlockContains=[NAV]
                              OrientationBlockNamed=Craft Remote Control
                              GyroIgnore=!NAV

                              [LOGGING]
                              TextPanelReport=Craft Report
                              StatusName=Wico Craft Status
                              LongStatus=Wico Craft Log
                              RangeReport=[RANGE]
                              SledReport=[SMREPORT]
                              GPSTag=[GPS]

                              [CONNECTORS]
                              BaseConnector=[BASE]
                              DockConnector=[DOCK]

                              [CAMERAS]
                              CameraViewOnly=[VIEW]

                              [NAV]
                              DTMDebug=False
                              CameraCollision=True
                              SensorCollision=True
                              NAVEmulateOld=True
                              NAVGravityMinElevation=75

                            </Value>
                          </item>
                        </dictionary>
                      </Storage>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>PB Wico Craft NAV</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Program>
                /* Wico Craft NAV Control sub-module
                *
                * Commands:
                * XXX
                *
                *
                *
                * Handles MODES:
                * MODE_DOCKED
                * MODE_LAUNCH
                * MODE_RELAUNCH
                * MODE_SLEDMOVE
                * MODE_ARRIVEDTARGET
                *
                *
                *
                * 2.0.4 Upate to new save format
                *  .04A Camera Scans for Obstacles...!!!one
                *
                *  2.1 Use new blockInint and localgrids
                *
                *  .1g Add Docked
                *  copy from SLED PATROL
                *  .1h fixed yaw only gyromain
                *  .1i tested in space. Added !NAV to gyro check
                *  .1j add doroll
                *  .1k use (and fix/test) IMyGyroControl
                2.2: Update for 1.72

                2.9 Copy from Sled Dock 2.2

                Needs LOTS of updates.

                3.0 Move code into 3.0

                3.0A Start NAV processing: W and O
                3.0B Add D, S, C
                3.0C Add arrivedtarget

                3.0D 110517  search order for text panels

                3.1 Version for PB Updates SE 1.185
                o Added support for GPS-formatted nav locations
                Ex:  W GPS:Wicorel #1:53970.01:128270.31:-123354.92:

                3.1a
                remove blockApplyActions() and make routines for each block type that needs it

                3.2 Collision Avoidance from Docking module for thruster travel

                Added Rotors

                3.2A travelmovement calculating target speeds and distances with more precision

                3.2B Sled Testing

                3.2C INI Save
                fix bug in serialize wrting z,y z, instead of x,y,z (oops)

                3.2D INI WCCM 01062018

                3.2E Major INI settings

                3.3 Lists of text panels
                Only output to textpanels and end of run

                3.3A Redo Serialize

                3.4 Sled testing

                * TODO:
                */
                string a="Wico Craft";string b="NAV";string c="3.4";const string d="0.00";void e(nO f){gf(f);}void g(nO
                f){ge(f);}void h(){}void i(){iv();}void j(bool k=false){jE(ix);nN();gs(gh);gs(gi);if(nn is IMyRemoteControl)
                ((IMyRemoteControl)nn).SetAutoPilotEnabled(false);if(nn is IMyShipController)((IMyShipController)nn).DampenersOverride
                =true;}m l=new m();class m{public const Base6Directions.Direction n=Base6Directions.Direction.Forward;
                public const Base6Directions.Direction o=Base6Directions.Direction.Backward;public const Base6Directions.Direction
                p=Base6Directions.Direction.Left;public const Base6Directions.Direction q=Base6Directions.Direction.Right;
                public const Base6Directions.Direction Up=Base6Directions.Direction.Up;public const Base6Directions.Direction
                r=Base6Directions.Direction.Down;public float s=30.0f;public List&lt;IMyTerminalBlock&gt;t=new List&lt;IMyTerminalBlock&gt;();
                Base6Directions.Direction u=Up;Base6Directions.Direction v=p;Base6Directions.Direction w=n;Base6Directions.Direction
                x=Up;Base6Directions.Direction y=p;Base6Directions.Direction z=n;public void A(List&lt;IMyTerminalBlock&gt;
                B){t=B;if(t.Count&gt;0)s=t[0].GetMaximum&lt;float&gt;("Yaw");}public void A(List&lt;IMyGyro&gt;B){t.Clear();if(B==null)
                return;for(int i=0;i&lt;B.Count;i++){t.Add((B[i]as IMyTerminalBlock));}if(t.Count&gt;0)s=t[0].GetMaximum&lt;float&gt;("Yaw");
                }public void A(IMyProgrammableBlock PB,IMyGridTerminalSystem C){t.Clear();if((C!=null)&amp;&amp;(PB!=null))C.GetBlocksOfType&lt;IMyGyro&gt;(t,
                x=&gt;((x.CubeGrid==PB.CubeGrid)&amp;&amp;x.IsFunctional));if(t.Count&gt;0)s=t[0].GetMaximum&lt;float&gt;("Yaw");}public
                void D(IMyTerminalBlock E,Base6Directions.Direction F=n,Base6Directions.Direction G=Up){if(Base6Directions.GetAxis(F)
                ==Base6Directions.GetAxis(G))G=Base6Directions.GetPerpendicular(F);if(E==null){}else{Vector3 H=Base6Directions.GetVector(F);
                Vector3.TransformNormal(ref H,E.Orientation,out H);F=Base6Directions.GetDirection(ref H);H=Base6Directions.GetVector(G);
                Vector3.TransformNormal(ref H,E.Orientation,out H);G=Base6Directions.GetDirection(ref H);}x=G;z=F;y=
                Base6Directions.GetLeft(x,z);}public void I(bool J){for(int i=0;i&lt;t.Count;i++){t[i].SetValueBool("Override",
                J);}}public void I(int K,bool J){if(K&lt;t.Count){t[K].SetValueBool("Override",J);}}public void L(float
                M){for(int i=0;i&lt;t.Count;i++){t[i].SetValueFloat("Power",M);}}public void L(int K,float M){if(K&lt;t.Count)
                {t[K].SetValueFloat("Power",M);}}public void N(bool O){for(int i=0;i&lt;t.Count;i++){(t[i]as IMyGyro).Enabled
                =O;}}public void N(int K,bool O){if(K&lt;t.Count){(t[K]as IMyGyro).Enabled=O;}}public void P(bool Q){for
                (int i=0;i&lt;t.Count;i++){t[i].SetValueBool("ShowOnHUD",Q);}}public void P(int K,bool Q){if(K&lt;t.Count)
                {t[K].SetValueBool("ShowOnHUD",Q);}}void R(Base6Directions.Direction S,out string T,out float U){T="Yaw";
                U=-1.0f;if(Base6Directions.GetAxis(u)==Base6Directions.GetAxis(S)){if(u==S)U=1.0f;}if(Base6Directions.GetAxis(v)
                ==Base6Directions.GetAxis(S)){T="Pitch";if(v==S)U=1.0f;}if(Base6Directions.GetAxis(w)==Base6Directions.GetAxis(S))
                {T="Roll";if(w==S){}else U=1.0f;}}public void V(float W){for(int i=0;i&lt;t.Count;i++){string T;float U;
                Vector3 H=Base6Directions.GetVector(Up);Vector3.TransformNormal(ref H,t[i].Orientation,out H);u=Base6Directions.GetDirection(ref
                H);R(x,out T,out U);t[i].SetValueFloat(T,U*W);}}public void X(float Y){for(int i=0;i&lt;t.Count;i++){string
                T;float U;Vector3 H=Base6Directions.GetVector(p);Vector3.TransformNormal(ref H,t[i].Orientation,out H);
                v=Base6Directions.GetDirection(ref H);R(y,out T,out U);t[i].SetValueFloat(T,U*Y);}}public void Z(float
                ba){for(int i=0;i&lt;t.Count;i++){string T;float U;Vector3 H=Base6Directions.GetVector(n);Vector3.TransformNormal(ref
                H,t[i].Orientation,out H);w=Base6Directions.GetDirection(ref H);R(z,out T,out U);t[i].SetValueFloat(T,
                U*ba);}}public void bb(float W,float Y,float ba){for(int i=0;i&lt;t.Count;i++){string T;float U;Vector3
                H=Base6Directions.GetVector(n);Vector3.TransformNormal(ref H,t[i].Orientation,out H);w=Base6Directions.GetDirection(ref
                H);H=Base6Directions.GetVector(p);Vector3.TransformNormal(ref H,t[i].Orientation,out H);v=Base6Directions.GetDirection(ref
                H);H=Base6Directions.GetVector(Up);Vector3.TransformNormal(ref H,t[i].Orientation,out H);u=Base6Directions.GetDirection(ref
                H);R(x,out T,out U);t[i].SetValueFloat(T,U*W);R(y,out T,out U);t[i].SetValueFloat(T,U*Y);R(z,out T,out
                U);t[i].SetValueFloat(T,U*ba);}}}double bc(Vector3D bd,IMyTerminalBlock be){double bf=0;bool bg=false;
                MatrixD bh=bx(be);Vector3D bi=be.GetPosition();Vector3D bj=bi+1.0*Vector3D.Normalize(bh.Backward);Vector3D
                bk=bi+1.0*Vector3D.Normalize(bh.Right);Vector3D bl=bi-1.0*Vector3D.Normalize(bh.Right);double bm=br(bk,
                bd);double bn=br(bl,bd);double bo=br(bk,bl);double bp=Vector3D.DistanceSquared(bi,bd);double bq=Vector3D.DistanceSquared(bj,
                bd);bg=bp&lt;bq;bf=(bn-bm)/bo;Echo("calc Angle="+Math.Round(bf,5));if(!bg){bf+=(bf&lt;0)?-1:1;}return bf;}
                double br(Vector3D a,Vector3D b){return Vector3D.Distance(a,b);}MatrixD bs(IMyCubeGrid bt){Vector3D bu
                =bt.GridIntegerToWorld(new Vector3I(0,0,0));Vector3D bv=bt.GridIntegerToWorld(new Vector3I(0,1,0))-bu;
                Vector3D bw=bt.GridIntegerToWorld(new Vector3I(0,0,1))-bu;return MatrixD.CreateScale(bt.GridSize)*MatrixD.CreateWorld(bu,
                -bw,bv);}MatrixD bx(IMyCubeBlock blk){Matrix bz;blk.Orientation.GetMatrix(out bz);return bz*MatrixD.CreateTranslation(((Vector3D)new
                Vector3D(blk.Min+blk.Max))/2.0)*bs(blk.CubeGrid);}bool bA(double bB,string bC="Roll",float bD=-1,float
                bE=1f){float bF=0;IMyGyro K=nw[0]as IMyGyro;float bG=K.GetMaximum&lt;float&gt;(bC);if(bD&gt;0)bG=bD;if(Math.Abs(bB)
                &gt;1.0){bF=bG*(float)(bB)*bE;}else if(Math.Abs(bB)&gt;.7){bF=bG*(float)(bB)/4;}else if(Math.Abs(bB)&gt;0.5){
                bF=0.11f*Math.Sign(bB);}else if(Math.Abs(bB)&gt;0.1){bF=0.11f*Math.Sign(bB);}else if(Math.Abs(bB)&gt;0.01)
                {bF=0.11f*Math.Sign(bB);}else if(Math.Abs(bB)&gt;0.001){bF=0.09f*Math.Sign(bB);}else bF=0;l.V(bF);if(Math.Abs(bB)
                &lt;nx){l.I(false);}else{l.I(true);l.N(true);return false;}return true;}void bH(List&lt;IMyTerminalBlock&gt;bI,
                bool bJ=true){foreach(var b in bI){IMyFunctionalBlock f=b as IMyFunctionalBlock;if(f==null)continue;
                f.Enabled=bJ;}}void bK(List&lt;IMyTerminalBlock&gt;bI){foreach(var b in bI){IMyFunctionalBlock f=b as IMyFunctionalBlock;
                if(f==null)continue;f.Enabled=!f.Enabled;}}string bL="[VIEW]";Matrix bM=new Matrix(1,0,0,0,0,1,0,0,0,
                0,1,0,0,0,0,1);List&lt;IMyTerminalBlock&gt;bN=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;bO=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;bP=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;bQ=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;bR=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;bS=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;bT=new List&lt;IMyTerminalBlock&gt;();IMyTerminalBlock bU=null;private MyDetectedEntityInfo
                bV;string bW="CAMERAS";void bX(nO f){f.op(bW,"CameraViewOnly",ref bL,true);}bool bY(List&lt;IMyTerminalBlock&gt;
                bZ,double ca=100,float Y=0,float W=0){double cb=0;bU=null;for(int i=0;i&lt;bZ.Count;i++){double cc=((IMyCameraBlock)bZ[i]).AvailableScanRange;
                if(cc&gt;cb){cb=cc;bU=bZ[i];}}var cd=bU as IMyCameraBlock;if(bU==null){return false;}if(cd.CanScan(ca))
                {bV=cd.Raycast(ca,Y,W);bU=cd;if(!bV.IsEmpty())ds(bV);return true;}else{}return false;}bool bY(List&lt;IMyTerminalBlock&gt;
                bZ,Vector3D ce){double cb=0;bU=null;for(int i=0;i&lt;bZ.Count;i++){double cc=((IMyCameraBlock)bZ[i]).AvailableScanRange;
                if(cc&gt;cb){cb=cc;bU=bZ[i];}}var cd=bU as IMyCameraBlock;if(bU==null)return false;{bV=cd.Raycast(ce);bU
                =cd;if(!bV.IsEmpty())ds(bV);return true;}}double cf(List&lt;IMyTerminalBlock&gt;bZ){double cg=0;for(int i=
                0;i&lt;bZ.Count;i++){IMyCameraBlock cd=bZ[i]as IMyCameraBlock;if(cg&lt;cd.AvailableScanRange)cg=cd.AvailableScanRange;
                }return cg;}string ch(IMyTerminalBlock ci){bN.Clear();bO.Clear();bP.Clear();bQ.Clear();bR.Clear();bS.Clear();
                bT.Clear();if(ci==null)return"\nCameras:No OrientationBlock";GridTerminalSystem.GetBlocksOfType&lt;IMyCameraBlock&gt;(bT,
                (x1=&gt;x1.CubeGrid==Me.CubeGrid));Matrix cj;ci.Orientation.GetMatrix(out cj);Matrix.Transpose(ref cj,out
                cj);for(int i=0;i&lt;bT.Count;++i){if(bT[i].CustomName.Contains(bL))continue;IMyCameraBlock cd=bT[i]as IMyCameraBlock;
                cd.EnableRaycast=true;Matrix ck;cd.Orientation.GetMatrix(out ck);Vector3 cl=Vector3.Transform(ck.Forward,
                cj);if(cl==bM.Left){bR.Add(bT[i]);}else if(cl==bM.Right){bS.Add(bT[i]);}else if(cl==bM.Backward){bO.Add(bT[i]);
                }else if(cl==bM.Forward){bN.Add(bT[i]);}else if(cl==bM.Up){bQ.Add(bT[i]);}else if(cl==bM.Down){bP.Add(bT[i]);
                }}string s;s="CS:&lt;";s+="F"+bN.Count.ToString("00");s+="B"+bO.Count.ToString("00");s+="D"+bP.Count.ToString("00");
                s+="U"+bQ.Count.ToString("00");s+="L"+bR.Count.ToString("00");s+="R"+bS.Count.ToString("00");s+="&gt;";
                return s;}void cm(List&lt;IMyTerminalBlock&gt;bZ,string cn){string co;for(int i=0;i&lt;bZ.Count;i++){if(!bZ[i].CustomName.Contains(cn))
                {co="Camera ";if(bZ.Count&gt;1)co+=(i+1).ToString()+" ";co+=cn;bZ[i].CustomName=co;}}}List&lt;IMyTerminalBlock&gt;
                cp=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;cq=new List&lt;IMyTerminalBlock&gt;();string cr(IMyTerminalBlock
                ci){string s="";if(bT.Count&lt;1)s+=ch(ci);cp.Clear();cq.Clear();foreach(var camera in bP){if(camera.CustomName.ToLower().Contains("fore")
                ||camera.CustomData.ToLower().Contains("fore"))cp.Add(camera);else if(camera.CustomName.ToLower().Contains("aft")
                ||camera.CustomData.ToLower().Contains("aft"))cq.Add(camera);}s+="HCS:&lt;";s+="F"+cp.Count.ToString("00");
                s+="A"+cq.Count.ToString("00");s+="&gt;";return s;}public class cs{bool ct=false;Program cu;public double
                cv=1250;double cw=5000;float cx=25f;float cy=25f;double cz=5;float cA=3;float cB=0.5f;float cC=0;float
                cD=0;float cE=0;float cF=0;List&lt;IMyTerminalBlock&gt;cG=new List&lt;IMyTerminalBlock&gt;();private int cH=0;private
                int cI=1;public MyDetectedEntityInfo bV;public List&lt;MyDetectedEntityInfo&gt;cJ=new List&lt;MyDetectedEntityInfo&gt;();
                public IMyTerminalBlock bU=null;public cs(Program pg,List&lt;IMyTerminalBlock&gt;bI,double cK=1250,float cL
                =45f,float cM=45f,float cN=2,float cO=1,float cP=0.5f,double cQ=5000){cu=pg;ct=false;cG.Clear();cJ.Clear();
                bV=new MyDetectedEntityInfo();foreach(var b in bI){if(b is IMyCameraBlock){cG.Add(b);IMyCameraBlock c
                =b as IMyCameraBlock;c.EnableRaycast=true;if(cx&gt;c.RaycastConeLimit)cx=c.RaycastConeLimit;if(cy&gt;c.RaycastConeLimit)
                cy=c.RaycastConeLimit;}}if(cK&gt;cQ)cQ=cK;cv=cK;cx=cL;cy=cM;cz=cN;cA=cO;cB=cP;cw=cQ;cC=0;cD=0;cE=0;cF=0;
                cH=0;cI=cG.Count;}public bool cR(){return ct;}void cS(MyDetectedEntityInfo bV){bool cT=true;for(int i
                =0;i&lt;cJ.Count;i++){if(cJ[i].EntityId==bV.EntityId)cT=false;}if(cT){cJ.Add(bV);}}public bool cU(){if(cG.Count
                &lt;1)ct=true;if(ct)return false;bool cV=false;for(int cW=0;cW&lt;cI;cW++){if(cu.bY(cG,cv,cF,cE)){bV=cu.bV;
                if(!bV.IsEmpty()){bool cX=true;if((bV.Type==MyDetectedEntityType.LargeGrid)||(bV.Type==MyDetectedEntityType.SmallGrid))
                {if(cu.nc(bV.EntityId)){cX=false;}}if(cX){cu.eW+="\nDoScan HIT!";cS(bV);cV=true;}}cH++;if(cF==0&amp;&amp;cE==
                0){cC=cB;cD=cB;cH=0;}if(cH&gt;3){cH=0;cD+=Math.Abs(cD/cA)+cB;if(Math.Abs(cD)&gt;cx){cH=0;cD=0;cC+=Math.Abs(cC
                /cA)+cB;}if(Math.Abs(cC)&gt;cy){cC=0;cD=0;cH=0;{cv*=cz;if(cv&gt;cw){ct=true;return false;}}}}switch(cH){case
                0:cF=cC;cE=cD;break;case 1:cF=-cC;cE=cD;break;case 2:cF=cC;cE=-cD;break;case 3:cF=-cC;cE=-cD;break;}
                }}return cV;}}const int cY=0;const int cZ=2;const int da=4;const int db=32;const int dc=64;const int
                dd=128;const int de=256;const int df=512;const int dg=1024;const int dh=2048;const int di=0xfff;string
                dj(){string dk="FLAGS:";if((hz&amp;cZ)&gt;0)dk+="SLED ";if((hz&amp;db)&gt;0)dk+="ORBITAL ";if((hz&amp;dc)&gt;0)dk+="ROCKET ";
                if((hz&amp;da)&gt;0)dk+="ROTOR ";if((hz&amp;dd)&gt;0)dk+="PET ";if((hz&amp;de)&gt;0)dk+="NAD ";if((hz&amp;df)&gt;0)dk+="NO Gyro ";
                if((hz&amp;dh)&gt;0)dk+="No Tank ";if((hz&amp;dg)&gt;0)dk+="No Power ";return dk;}long dl=0;void dm(){string dn;if
                (SaveFile==null){dn=Storage;}else{dn=SaveFile.GetPublicText();}hw.oa(dn);hw.op(ht,"SaveID",ref dl);if
                (@do())hw.oa("");e(hw);hw.op(ht,"Mode",ref fb,true);hw.op(ht,"current_state",ref current_state,true);
                hw.op(ht,"PassedArgument",ref sPassedArgument,true);hw.op(ht,"AlertStates",ref hB,true);hw.op(ht,"craft_operation",
                ref hz,true);hw.op(ht,"PassedArgument",ref sPassedArgument);hw.op(ht,"ReceivedMessage",ref hC);}bool
                @do(){if(dl==(long)SaveFile.EntityId)return false;else return true;}bool dp(string dq){dq=dq.Trim().ToLower();
                return(dq=="True"||dq=="true");}Dictionary&lt;long,MyDetectedEntityInfo&gt;dr=new Dictionary&lt;long,MyDetectedEntityInfo&gt;();
                void ds(MyDetectedEntityInfo thisDetectedInfo){if(thisDetectedInfo.EntityId!=0){if(!dr.ContainsKey(thisDetectedInfo.EntityId))
                {dr.Add(thisDetectedInfo.EntityId,thisDetectedInfo);}else{dr[thisDetectedInfo.EntityId]=thisDetectedInfo;
                }}else Echo("Not adding: Zero Entity");}string du(MyDetectedEntityInfo dv){string s="";s+="ETBV";s+=
                ":"+dv.EntityId.ToString();s+=":"+dv.TimeStamp;Vector3D dw=dv.BoundingBox.Min;s+=":"+hF(dw);Vector3D
                dx=dv.BoundingBox.Max;s+=":"+hF(dx);Vector3D dy=(Vector3)dv.Velocity;s+=":"+hF(dy);return s;}void dz()
                {Echo("mode="+fb.ToString());if(fb==fi){dG();return;}}void dA(){es(DateTime.Now.ToString()+" ACTION: Reset To Idle",
                ea,true);j();fS(fc);}void dB(){es(b+" Manual Control",ec);}double dC=50;bool dD=true;bool dE=false;bool
                dF=false;void dG(){es("clear",ec);es(b+":Going Target!",ec);es(b+":GT: current_state="+current_state.ToString(),
                ec);Echo("Going Target: state="+current_state.ToString());if(current_state==0){kH();if((hz&amp;cZ)&gt;0){dE
                =true;if(kh&gt;45)kh=45;}else dE=false;if((hz&amp;da)&gt;0){dF=true;if(kh&gt;15)kh=15;}else dF=false;l.D(nn);double
                dH=0;((IMyShipController)nn).TryGetPlanetElevation(MyPlanetElevation.Surface,out dH);if(fV){if(dH&gt;hI.ib())
                {current_state=150;}else current_state=160;}else fS(ff);@in=true;}else if(current_state==150){if(ir&gt;
                0){float dI=nx;nx=0.1f;bool dJ=GyroMain("");Echo("bAligned="+dJ.ToString());nx=dI;if(dJ){current_state
                =160;}@in=true;}else current_state=160;}else if(current_state==160){Echo("Moving to Target");Vector3D
                dK=fU;Vector3D dL=dK-nn.GetPosition();double dM=dL.Length();Echo("distance="+eQ(dM));Echo("velocity="
                +iq.ToString("0.00"));es("clear",eg);es("Moving to Target\nD:"+eQ(dM)+" V:"+iq.ToString(d),eg);if(dD
                &amp;&amp;(dM&lt;dC)){Echo("we have arrived");if(ga){var dN=nk&lt;IMyTerminalBlock&gt;("NAV:");for(int i1=0;i1&lt;dN.Count();
                i1++){if(dN[i1].CustomName.StartsWith("NAV:")){Echo("Found NAV: command:");dN[i1].CustomName="NAV: C Arrived Target";
                }}}j();fV=false;fS(fF);return;}bool dO=true;double dH=0;((IMyShipController)nn).TryGetPlanetElevation(MyPlanetElevation.Surface,
                out dH);if(!dE&amp;&amp;!dF&amp;&amp;gb&gt;0&amp;&amp;dH&lt;gb){jA(iB,100);}if(dO){Echo("Do Travel");kM(dK,3.0f,200,170);}}else if
                (current_state==170){@in=true;Vector3D dK=fU;kH();ld(dK);current_state=172;}else if(current_state==171)
                {@in=false;}else if(current_state==172){Echo("Collision Avoid");es("clear",eg);es("Collision Avoid",
                eg);kM(lc,5.0f,160,173);}else if(current_state==173){if(bV.Type==MyDetectedEntityType.Asteroid||bV.Type
                ==MyDetectedEntityType.LargeGrid||bV.Type==MyDetectedEntityType.SmallGrid){current_state=174;}else current_state
                =170;@in=true;}else if(current_state==174){lw();kH();dtNavStartShip=DateTime.Now;current_state=175;@in
                =true;}else if(current_state==175){DateTime dP=dtNavStartShip.AddSeconds(5.0f);DateTime dQ=DateTime.Now;
                if(DateTime.Compare(dQ,dP)&gt;0){fS(ff);kc();return;}if(lx()){Echo("ESCAPE!");current_state=180;}bWantMedium
                =true;}else if(current_state==180){kM(lc,1f,160,173);}else if(current_state==200){es("clear",eg);es("Arrived at Target",
                eg);j();fV=false;lU(false);oY();fS(fF);if(ga){var dN=nk&lt;IMyTerminalBlock&gt;("NAV:");for(int i1=0;i1&lt;dN.Count();
                i1++){if(dN[i1].CustomName.StartsWith("NAV:")){Echo("Found NAV: command:");dN[i1].CustomName="NAV: C Arrived Target";
                }}}@in=true;kc();}}void dR(float dS){if(dF){gk(dS);}else jA(iy,dS);}void dT(){jE(ix);gs();}string dU
                ="LOGGING";void dV(nO f){f.op(dU,"TextPanelReport",ref sTextPanelReport,true);f.op(dU,"StatusName",ref
                dZ,true);f.op(dU,"LongStatus",ref eb,true);f.op(dU,"RangeReport",ref dX,true);f.op(dU,"SledReport",ref
                ssledReport,true);f.op(dU,"GPSTag",ref ef,true);}ek dW=null;string dX="[RANGE]";ek dY=null;string dZ
                ="Wico Craft Status";ek ea=null;string eb="Wico Craft Log";ek ec=null;string sTextPanelReport="Craft Report";
                ek ee=null;string ef="[GPS]";ek eg=null;string ssledReport="[SMREPORT]";bool ei=false;bool ej=false;
                public class ek{Program cu;string el="";List&lt;IMyTextPanel&gt;em=new List&lt;IMyTextPanel&gt;();string en="";string
                eo="";bool ep=false;bool eq=true;public ek(Program pg,string co,bool er=false){cu=pg;el=co;ep=er;eq=
                true;en="";eo="";em.Clear();List&lt;IMyTerminalBlock&gt;bI=new List&lt;IMyTerminalBlock&gt;();bI=cu.nl&lt;IMyTextPanel&gt;(el);
                if(bI.Count&lt;1)bI=cu.nk&lt;IMyTextPanel&gt;(el);em=bI.ConvertAll(x1=&gt;(IMyTextPanel)x1);}public void es(string
                et,bool eu=false){if(et=="clear"){en="";eo="X";eq=false;return;}if(ep&amp;&amp;eq){eq=false;if(em.Count&gt;0){en
                =em[0].GetPublicText();eo="X";}}if(eu){en=et+"\n"+en;}else en+=et+"\n";}public void ev(){if(eo!=en){
                eq=true;foreach(var t in em){t.WritePublicText(en);}eo=en;}}}void ew(){dY=eB(true);ea=ey(eb,true);;ec
                =ey(sTextPanelReport);dW=ey(dX);ee=ey(ef,ii);eg=ey(ssledReport);ei=true;}void ex(){if(dY!=null)dY.ev();
                if(ea!=null)ea.ev();if(ec!=null)ec.ev();if(dW!=null)dW.ev();if(ee!=null)ee.ev();if(eg!=null)eg.ev();
                }ek ey(string stheName,bool bRefresh=false){ek eA=new ek(this,stheName,bRefresh);return eA;}ek eB(bool
                force_update=false){if((dY!=null||ei)&amp;&amp;!force_update)return dY;dY=ey(dZ);return dY;}void es(string text,
                ek wLog,bool bReverse=false){if(wLog==null)return;wLog.es(text,bReverse);}void eE(string et){es(et,eB());
                if(ej&amp;&amp;et!="clear")Echo(et);}string eF(double eG){int eH=75;if(eG&lt;0)eG=0;int eI=(int)(eG*eH)/100;if(eI
                &gt;eH)eI=eH;string dk="["+new String('|',eI)+new String('\'',eH-eI)+"]";return dk;}void eJ(string co,Vector3D
                eK){string s1;s1="GPS:"+co+":"+hF(eK)+":";es(s1,ee);}string eL(string eM,string eN){string s;int eO=
                eM.Length;int eP=eN.Length;if(eO+eP&gt;32){if(eP&gt;31)return"INVALID";eO=32-eP;}s=eM.Substring(0,eO)+eN;s.Replace(":",
                "_");s.Replace(";","_");return s;}string eQ(double thed){string eS="";if(thed&gt;1000){eS=thed.ToString("N0")
                +"km";}else if(thed&gt;10){eS=thed.ToString("0.0")+"m";}else{eS=thed.ToString("0.000")+"m";}return eS;}
                void eT(){}void eU(nO eV){mp(eV);iV(eV);nr(eV);bX(eV);gd(eV);}string eW="";string eX="";int eY=0;string
                eZ(){nt=1;nx=0.09f;ns=0.75;Echo("Init:"+eY);if(eY==0){es(DateTime.Now.ToString()+a+":"+b+":INIT",ea,
                true);eW+=SerializeInit();dm();eW+=mN();eW+=DefaultOrientationBlockInit();ew();}else if(eY==1){eW+=iW(nn);
                eW+=gj();eW+=pu(nn);eW+=oT();eW+=ch(nn);eW+=mq();}else if(eY==2){eW+=nL();l.A(nw);l.D(nn);eW+=oL();eW
                +=ch(nn);gv(nn);initShipDim(nn);eW+=fa();il=true;}eY++;if(il){eY=0;@in=false;}eE(eW);return eW;}string
                fa(){return"&gt;";}int fb=0;const int fc=0;const int fd=1;const int fe=2;const int ff=3;const int fg=4;
                const int fh=5;const int fi=7;const int fj=8;const int fk=9;const int fl=13;const int fm=10;const int
                fn=11;const int fo=12;const int fp=14;const int fq=15;const int fr=16;const int fs=17;const int ft=18;
                const int fu=19;const int fv=20;const int fw=21;const int fx=22;const int fy=23;const int fz=24;const
                int fA=25;const int fB=26;const int fC=27;const int fD=28;const int fE=29;const int fF=30;const int fG
                =31;const int fH=50;const int fI=60;const int fJ=111;const int fK=200;const int fL=210;const int fM=
                220;const int fN=290;const int fO=400;const int fP=410;const int fQ=500;const int fR=510;void fS(int
                newMode){if(fb==newMode)return;fb=newMode;current_state=0;kc();}Vector3D fU;bool fV=false;DateTime dtNavStartShip;
                bool fX=false;bool fY=true;bool fZ=true;bool ga=true;float gb=-1;string sNavSection="NAV";void gd(nO
                f){f.op(sNavSection,"DTMDebug",ref fX,true);f.op(sNavSection,"CameraCollision",ref fY,true);f.op(sNavSection,
                "SensorCollision",ref fZ,true);f.op(sNavSection,"NAVEmulateOld",ref ga,true);f.op(sNavSection,"NAVGravityMinElevation",
                ref gb,true);}void ge(nO f){f.oC(sNavSection,"vTarget",fU);f.oC(sNavSection,"ValidNavTarget",fV);f.oC(sNavSection,
                "dStartShip",dtNavStartShip);}void gf(nO f){f.op(sNavSection,"vTarget",ref fU,true);f.op(sNavSection,
                "ValidNavTarget",ref fV,true);f.op(sNavSection,"dStartShip",ref dtNavStartShip,true);}List&lt;IMyTerminalBlock&gt;
                gg=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;gh=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                gi=new List&lt;IMyTerminalBlock&gt;();string gj(){gg.Clear();gh.Clear();gi.Clear();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(gg,
                nb);for(int i=0;i&lt;gg.Count;i++){if(gg[i].CustomName.Contains("[LEFT]")||gg[i].CustomData.Contains("[LEFT]"))
                {gh.Add(gg[i]);}else if(gg[i].CustomName.Contains("[RIGHT]")||gg[i].CustomData.Contains("[RIGHT]")){
                gi.Add(gg[i]);}}return"NR:L"+gh.Count.ToString("0")+"R"+gi.Count.ToString("0");}bool gk(float gl){if
                (gh.Count&lt;1)return false;float gm=gh[0].GetMaximum&lt;float&gt;("Velocity");float gn=gh[0].GetValueFloat("Velocity");
                float go=(gn/gm*100);go=Math.Abs(go);if(gl&gt;(go+5f))gl=go+5;if(gl&lt;(go-5))gl=go-5;if(gl&lt;0f)gl=0f;if(gl
                &gt;100f)gl=100f;if(Math.Abs(gl)&gt;0){gk(gh,-gl);gk(gi,gl);return true;}else return false;}bool gk(List&lt;IMyTerminalBlock&gt;
                rotorList,float gl){for(int i=0;i&lt;rotorList.Count;i++){IMyMotorStator gq=rotorList[i]as IMyMotorStator;
                float gm=gq.GetMaximum&lt;float&gt;("Velocity");if(!gq.Enabled)gq.Enabled=true;float gr=gm*(gl/100.0f);Echo(gq.CustomName
                +":MV="+gm.ToString("0.00")+":V="+gr.ToString("0.00"));gq.TargetVelocityRPM=gr;}return true;}bool gs()
                {gs(gh);gs(gi);return true;}bool gs(List&lt;IMyTerminalBlock&gt;rotorList){for(int i=0;i&lt;rotorList.Count;i++)
                {IMyMotorStator gq=rotorList[i]as IMyMotorStator;gq.TargetVelocityRPM=0;}return true;}bool gt(double
                bf){Echo("DRR:"+bf.ToString());float gl;if(Math.Abs(bf)&gt;1.0){gl=50;}else if(Math.Abs(bf)&gt;.7){gl=50;}
                else if(Math.Abs(bf)&gt;0.5){gl=30;}else if(Math.Abs(bf)&gt;0.1){gl=20;}else if(Math.Abs(bf)&gt;0.01){gl=5;}else
                if(Math.Abs(bf)&gt;0.001){gl=0;}else gl=0;gl/=3;gl=gl*-Math.Sign(bf);if(Math.Abs(gl)&gt;0){Echo("PUPLEFT:"
                +gl.ToString());gk(gh,gl);}if(Math.Abs(gl)&gt;0){Echo("PUPRIGHT:"+gl.ToString());gk(gi,gl);}if(Math.Abs(gl)
                &gt;0)return false;else return true;}public gx gu;void gv(IMyTerminalBlock sourceBlock=null){if(sourceBlock
                ==null)sourceBlock=nn;gu=new gx(sourceBlock);}public struct gx{public Vector3D[]gy;Vector3D gz;Vector3D
                gA;public Vector3D gB;static int[]gC={1,3,5,7};static int[]gD={0,2,4,6};static int[]gE={2,3,6,7};static
                int[]gF={0,1,4,5};static int[]gG={4,5,6,7};static int[]gH={0,1,2,3};static int[][]gI={gC,gD,gE,gF,gG,
                gH};public const int gJ=0;public const int gK=1;public const int gL=2;public const int gM=3;public const
                int gN=4;public const int gO=5;public gx(IMyTerminalBlock gP){gy=new Vector3D[8];gA=new Vector3D(gP.CubeGrid.Min)
                -new Vector3D(0.5,0.5,0.5);gA*=gP.CubeGrid.GridSize;gz=new Vector3D(gP.CubeGrid.Max)+new Vector3D(0.5,
                0.5,0.5);gz*=gP.CubeGrid.GridSize;var gQ=gP.WorldMatrix.GetOrientation();var gR=gP.CubeGrid.WorldMatrix.GetOrientation()
                *MatrixD.Transpose(gQ);Vector3D.TransformNormal(ref gA,ref gR,out gA);Vector3D.TransformNormal(ref gz,
                ref gR,out gz);var gS=Vector3D.Min(gA,gz);gz=Vector3D.Max(gA,gz);gA=gS;var gT=gP.CubeGrid.GetPosition();
                Vector3D gU;Vector3D gV;gU=gA;Vector3D.TransformNormal(ref gU,ref gQ,out gU);gU+=gT;gV=gz;Vector3D.TransformNormal(ref
                gV,ref gQ,out gV);gV+=gT;BoundingBox bb=new BoundingBox(gU,gV);gB=bb.Center;Vector3D gW;for(int i=0;
                i&lt;8;i++){gW.X=((i&amp;1)==0?gA:gz).X;gW.Y=((i&amp;2)==0?gA:gz).Y;gW.Z=((i&amp;4)==0?gA:gz).Z;Vector3D.TransformNormal(ref
                gW,ref gQ,out gW);gW+=gT;gy[i]=gW;}}public void gX(int gY,Vector3D[]gZ,int ha=0){gY%=gI.Length;for(int
                i=0;i&lt;gI[gY].Length;i++){gZ[ha++]=gy[gI[gY][i]];}}}bool hb(string hc){eX="";if(hc==""||hc=="timer"||
                hc=="wccs"||hc=="wcct"){if(sPassedArgument!=""&amp;&amp;sPassedArgument!="timer"){hc=sPassedArgument;}if(ga)
                {var dN=nk&lt;IMyTerminalBlock&gt;("NAV:");for(int i1=0;i1&lt;dN.Count();i1++){if(dN[i1].CustomName.StartsWith("NAV:"))
                {Echo("Found NAV: command:");hc=dN[i1].CustomName.Substring("NAV:".Length);break;}}}}if(hc=="init"){
                eW="";il=false;eY=0;eZ();return false;}string[]hd=hc.Trim().Split(';');for(int he=0;he&lt;hd.Length;he++)
                {string[]hf=hd[he].Trim().Split(' ');if(hf[0]=="timer"){}else if(hf[0]=="wccs"){}else if(hf[0]=="wcct")
                {}else if(hf[0]=="W"||hf[0]=="O"){Echo("Args:");for(int hg=0;hg&lt;hf.Length;hg++)Echo(hf[hg]);if(hf.Length
                &lt;1){Echo("Invalid Command:("+hd[he]+")");continue;}string hh=hf[1].Trim();if(hf.Length&gt;2){hh=hf[1];for
                (int kk=2;kk&lt;hf.Length;kk++)hh+=" "+hf[kk];hh=hh.Trim();}string[]hi=hh.Split(',');if(hi.Length&lt;3){hi
                =hh.Split(':');}for(int hg=0;hg&lt;hi.Length;hg++)Echo(hi[hg]);if(hi.Length&lt;3){Echo("Invalid Command:("
                +hd[he]+")");nN();return false;}int hj=0;string hk="Waypoint";if(hi[0]=="GPS"){if(hi.Length&gt;4){hk=hi[1];
                hj=2;}else{Echo("Invalid Command");nN();return false;}}double x,y,z;bool hl=double.TryParse(hi[hj++].Trim(),
                out x);bool hm=double.TryParse(hi[hj++].Trim(),out y);bool hn=double.TryParse(hi[hj++].Trim(),out z);
                if(!hl||!hm||!hn){Echo("Invalid Command:("+hd[he]+")");continue;}fU=new Vector3D(x,y,z);fV=true;if(hf[0]
                =="W")dD=true;else dD=false;fS(fi);}else if(hf[0]=="S"){if(hf.Length&lt;1){Echo("Invalid Command:("+hd[he]
                +")");continue;}double x;bool hl=double.TryParse(hf[1].Trim(),out x);if(hl){kh=x;Echo("Set speed to:"
                +kh.ToString("0.00"));}else{Echo("Invalid Command:("+hd[he]+")");continue;}}else if(hf[0]=="D"){if(hf.Length
                &lt;1){Echo("Invalid Command:("+hd[he]+")");continue;}double x;bool hl=double.TryParse(hf[1].Trim(),out
                x);if(hl){dC=x;Echo("Set arrival distance to:"+dC.ToString("0.00"));}else{Echo("Invalid Command:("+hd[he]
                +")");continue;}}else if(hf[0]=="C"){if(hf.Length&lt;1){Echo("Invalid Command:("+hd[he]+")");continue;}
                else{Echo(hd[he]);}}else{int ho;if(id.TryGetValue(hf[0].ToLower(),out ho)){eX="mode set to "+ho;fS(ho);
                }else{eX="Unknown argument:"+hf[0];}}}return false;}bool hp(string hc){return false;}void hq(){g(hw);
                hw.oC(ht,"Mode",fb.ToString());hw.oC(ht,"current_state",current_state.ToString());hw.oC(ht,"PassedArgument",
                sPassedArgument);hw.oC(ht,"AlertStates",hB.ToString());hw.oC(ht,"craft_operation",hz.ToString());hw.oC(ht,
                "PassedArgument",sPassedArgument);hw.oC(ht,"ReceivedMessage",hC);hw.oC(ht,"SaveID",(long)SaveFile.EntityId);
                if(hw.nZ){if(hw.nZ){string hr=hw.oG();if(SaveFile==null){Storage=hr;}else{SaveFile.WritePublicText(hr,
                false);}}}else{Echo("Not saving: Same");}}string hs="Wico Craft Save";string ht="WCCM2";void SerializeInitCustomData(nO
                iNIHolder){iNIHolder.op(ht,"SAVE_FILE_NAME",ref hs,true);}IMyTextPanel SaveFile=null;nO hw;int current_state
                =0;long allBlocksCount=0;int hz=cY;string sPassedArgument="";int hB=0;string hC="";string SerializeInit()
                {string eW="S";SaveFile=null;List&lt;IMyTerminalBlock&gt;bI=new List&lt;IMyTerminalBlock&gt;();bI=nm&lt;IMyTextPanel&gt;(hs);
                if(bI.Count&gt;1)Echo("Multiple blocks found: \""+hs+"\"");else if(bI.Count==0){bI=nk&lt;IMyTextPanel&gt;(hs);
                if(bI.Count==1)SaveFile=bI[0]as IMyTextPanel;else{bI=nl&lt;IMyTextPanel&gt;(hs);if(bI.Count==1)SaveFile=bI[0]
                as IMyTextPanel;}}else SaveFile=bI[0]as IMyTextPanel;hw=new nO(this,"");if(SaveFile==null){eW="-";Echo(hs
                +" (TextPanel) is missing or Named incorrectly. ");}return eW;}bool hE(){return SaveFile!=null;}string
                hF(Vector3D v){string s;s=v.X.ToString("0.00")+":"+v.Y.ToString("0.00")+":"+v.Z.ToString("0.00");return
                s;}bool hG(string hH,out double x,out double y,out double z){string[]hi=hH.Trim().Split(',');if(hi.Length
                &lt;3){hi=hH.Trim().Split(':');}x=0;y=0;z=0;if(hi.Length&lt;3)return false;bool hl=double.TryParse(hi[0].Trim(),
                out x);bool hm=double.TryParse(hi[1].Trim(),out y);bool hn=double.TryParse(hi[2].Trim(),out z);if(!hl
                ||!hm||!hn){return false;}return true;}hO hI;void initShipDim(IMyTerminalBlock ci){hI=new hO(this,ci);
                }const float hK=0.5f;const float hL=2.5f;const double hM=0.5;const double hN=2.5;public class hO{private
                float hP,hQ,hR;private double hS,hT,hU;private double hV;private Program cu;private gx gu;public hO(Program
                pg,IMyTerminalBlock ci){cu=pg;if(cu.Me.CubeGrid.GridSizeEnum.ToString().ToLower().Contains("small"))
                hV=hM;else hV=hN;gu=new gx(ci);Vector3D[]gZ=new Vector3D[4];gu.gX(gx.gO,gZ);hT=(gZ[0]-gZ[1]).Length();
                hU=(gZ[0]-gZ[2]).Length();gu.gX(0,gZ);hS=(gZ[0]-gZ[2]).Length();hP=(float)(hS/hV);hQ=(float)(hT/hV);
                hR=(float)(hU/hV);}public float hW(){return hP;}public double hX(){return hS;}public float hY(){return
                hQ;}public double hZ(){return hT;}public float ia(){return hR;}public double ib(){return hU;}public double
                ic(){return hV;}}Dictionary&lt;string,int&gt;id=new Dictionary&lt;string,int&gt;();string ie="";UpdateFrequency@if
                =UpdateFrequency.Once;float ig=100;string ih="WORLD";bool ii=true;void ij(nO f){f.op(ih,"MaxWorldMps",
                ref ig,true);}void ik(){nO eV=new nO(this,Me.CustomData);ij(eV);mF(eV);dV(eV);eU(eV);if(eV.nZ){Me.CustomData
                =eV.oG(true);}}public Program(){eT();ik();ie=a+":"+b+" V"+c+" ";Echo(ie+"Creator");if(!Me.CustomName.Contains(b))
                Me.CustomName="PB "+a+" "+b;if(!Me.Enabled){Echo("I am turned OFF!");}}bool il=false;bool im=false;bool
                @in=false;bool bWantMedium=false;bool ip=false;double iq=-1;double ir=-2;void Main(string hc,UpdateType
                ut){Echo(ie+jW());@in=false;bWantMedium=false;ip=false;var@is=new List&lt;IMyTerminalBlock&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyProjector&gt;(@is,
                nb);for(int i=0;i&lt;@is.Count;i++){if(@is[i].IsWorking){Echo("Projector:"+@is[i].CustomName);ip=true;}
                }if(ip)Echo("Working local Projector found!");if(hc!=""&amp;&amp;hc!="timer"&amp;&amp;hc!="wccs")Echo("Arg="+hc);if(hc
                =="init"){eW="";il=false;}if(!il){if(ip){es("clear",ey(sTextPanelReport));es(b+":Construction in Progress\nTurn off projector to continue",
                ec);}@in=true;eZ();im=true;}else{if(im)es(DateTime.Now.ToString()+" "+a+":"+eW,ea,true);dm();if(nn is
                IMyShipController){iq=((IMyShipController)nn).GetShipSpeed();Vector3D it=((IMyShipController)nn).GetNaturalGravity();
                double iu=it.Length();ir=iu/9.81;}if((ut&amp;(UpdateType.Trigger|UpdateType.Terminal))&gt;0){if(hb(hc)){hq();
                ex();return;}}else if((ut&amp;(UpdateType.Mod))&gt;0){if(hb(hc)){hq();ex();return;}}else if((ut&amp;(UpdateType.Script))
                &gt;0){if(hb(hc)){hq();ex();return;}}else if((ut&amp;(UpdateType.Antenna))&gt;0){if(!hp(hc)){mg(hc);}hq();kc();
                ex();return;}else{hc="";}me();lZ();h();dz();}hq();if(@in){Echo("FAST!");Runtime.UpdateFrequency|=@if;
                }else{Runtime.UpdateFrequency&amp;=~(@if);}if(bWantMedium){Echo("MEDIUM");Runtime.UpdateFrequency|=UpdateFrequency.Update10;
                }else{Runtime.UpdateFrequency&amp;=~(UpdateFrequency.Update10);}this.i();im=false;ex();}void iv(string ie
                =null){float iw=0;iw=Runtime.CurrentInstructionCount/(float)Runtime.MaxInstructionCount;if(ie==null)
                ie="Instructions=";Echo(ie+" "+(iw*100).ToString("0.00")+"%");}List&lt;IMyTerminalBlock&gt;ix=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;iy=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;iz=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;iA=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;iB=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;iC=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;iD=new List&lt;IMyTerminalBlock&gt;();
                double iE=0;double iF=0;double iG=0;double iH=0;double iI=0;double iJ=0;int iK=0;int iL=0;int iM=0;const
                int iN=1;const int iO=2;const int iP=4;const int iQ=0xff;Matrix iR=new Matrix(1,0,0,0,0,1,0,0,0,0,1,
                0,0,0,0,1);string iS="IGNORE";string iT="cutter";string iU="THRUSTERS";void iV(nO iNIHolder){iNIHolder.op(iU,
                "IgnoreThruster",ref iS);iNIHolder.op(iU,"CutterThruster",ref iT);}void iW(IMyTerminalBlock ci,ref List&lt;IMyTerminalBlock&gt;
                iy,ref List&lt;IMyTerminalBlock&gt;iz,ref List&lt;IMyTerminalBlock&gt;iA,ref List&lt;IMyTerminalBlock&gt;iB,ref List&lt;IMyTerminalBlock&gt;
                iC,ref List&lt;IMyTerminalBlock&gt;iD,int iX=iQ){iy.Clear();iz.Clear();iA.Clear();iB.Clear();iC.Clear();iD.Clear();
                ix.Clear();if(ci==null)return;var iY=new List&lt;IMyTerminalBlock&gt;();nh&lt;IMyThrust&gt;(ref iY);for(int i=0;
                i&lt;iY.Count;i++){if(iY[i].CustomName.ToLower().Contains(iT)||iY[i].CustomData.ToLower().Contains(iT))
                continue;if(iY[i].CustomName.ToLower().Contains(iS)||iY[i].CustomData.ToLower().Contains(iS))continue;
                ix.Add(iY[i]);}Matrix cj;ci.Orientation.GetMatrix(out cj);Matrix.Transpose(ref cj,out cj);iE=0;iF=0;
                iG=0;iH=0;iI=0;iJ=0;for(int i=0;i&lt;ix.Count;++i){var iZ=ix[i]as IMyThrust;Matrix ja;iZ.Orientation.GetMatrix(out
                ja);Vector3 cl=Vector3.Transform(ja.Backward,cj);int jb=jc(ix[i]);if(jb==iN)iM++;else if(jb==iO)iL++;
                else if(jb==iP)iK++;if(cl==iR.Left){iI+=je((IMyThrust)ix[i]);iC.Add(ix[i]);}else if(cl==iR.Right){iJ
                +=je((IMyThrust)ix[i]);iD.Add(ix[i]);}else if(cl==iR.Backward){iF+=je((IMyThrust)ix[i]);iz.Add(ix[i]);
                }else if(cl==iR.Forward){iE+=je((IMyThrust)ix[i]);iy.Add(ix[i]);}else if(cl==iR.Up){iH+=je((IMyThrust)ix[i]);
                iB.Add(ix[i]);}else if(cl==iR.Down){iG+=je((IMyThrust)ix[i]);iA.Add(ix[i]);}}}string iW(IMyTerminalBlock
                ci){iy.Clear();iz.Clear();iA.Clear();iB.Clear();iC.Clear();iD.Clear();ix.Clear();if(ci==null)return"No Orientation Block";
                var iY=new List&lt;IMyTerminalBlock&gt;();nh&lt;IMyThrust&gt;(ref iY);for(int i=0;i&lt;iY.Count;i++){if(iY[i].CustomName.ToLower().Contains(iT)
                ||iY[i].CustomData.ToLower().Contains(iT))continue;if(iY[i].CustomName.ToLower().Contains(iS)||iY[i].CustomData.ToLower().Contains(iS))
                continue;ix.Add(iY[i]);}Matrix cj;ci.Orientation.GetMatrix(out cj);Matrix.Transpose(ref cj,out cj);iE
                =0;iF=0;iG=0;iH=0;iI=0;iJ=0;for(int i=0;i&lt;ix.Count;++i){var iZ=ix[i]as IMyThrust;Matrix ja;iZ.Orientation.GetMatrix(out
                ja);Vector3 cl=Vector3.Transform(ja.Backward,cj);int jb=jc(ix[i]);if(jb==iN)iM++;else if(jb==iO)iL++;
                else if(jb==iP)iK++;if(cl==iR.Left){iI+=je((IMyThrust)ix[i]);iC.Add(ix[i]);}else if(cl==iR.Right){iJ
                +=je((IMyThrust)ix[i]);iD.Add(ix[i]);}else if(cl==iR.Backward){iF+=je((IMyThrust)ix[i]);iz.Add(ix[i]);
                }else if(cl==iR.Forward){iE+=je((IMyThrust)ix[i]);iy.Add(ix[i]);}else if(cl==iR.Up){iH+=je((IMyThrust)ix[i]);
                iB.Add(ix[i]);}else if(cl==iR.Down){iG+=je((IMyThrust)ix[i]);iA.Add(ix[i]);}}string s;s="&gt;";s+="F"+iy.Count.ToString("00");
                s+="B"+iz.Count.ToString("00");s+="D"+iA.Count.ToString("00");s+="U"+iB.Count.ToString("00");s+="L"+
                iC.Count.ToString("00");s+="R"+iD.Count.ToString("00");s+="&lt;";return s;}int jc(IMyTerminalBlock theBlock)
                {if(theBlock is IMyThrust){if(theBlock.BlockDefinition.SubtypeId.Contains("Atmo"))return iN;else if(theBlock.BlockDefinition.SubtypeId.Contains("Hydro"))
                return iO;else return iP;}return 0;}double je(IMyThrust thruster){return thruster.MaxEffectiveThrust;
                }double jf(List&lt;IMyTerminalBlock&gt;jg,int jh=iQ){double ji=0;for(int jj=0;jj&lt;jg.Count;jj++){int jk=jc(jg[jj]);
                if((jk&amp;jh)&gt;0){IMyThrust iZ=jg[jj]as IMyThrust;double jl=iZ.MaxEffectiveThrust;ji+=jl;}}return ji;}bool
                jm(List&lt;IMyTerminalBlock&gt;jg,out float jn,out float jo,out float jp){jn=0;jo=0;jp=0;double jq=jf(jg,iP);
                double jr=jf(jg,iN);double js=jf(jg,iO);MyShipMass jt;jt=((IMyShipController)nn).CalculateShipMass();
                double ju=0;ju=jt.PhysicalMass*ir*9.810;if(jr&gt;0){if(jr&lt;ju){jn=100;ju-=jr;}else{jn=(float)(ju/jr*100);
                if(jn&gt;0)ju-=(jr*jn/100);}}if(jq&gt;0&amp;&amp;ju&gt;0){if(jq&lt;ju){jp=100;ju-=jq;}else{jp=(float)(ju/jq*100);if(jp&gt;0)
                ju-=((jq*jp)/100);}}if(js&gt;0&amp;&amp;ju&gt;0){if(js&lt;ju){jo=100;ju-=js;}else{jo=(float)(ju/js*100);if(jo&gt;0)ju-=((js
                *jo)/100);;}}if(ju&gt;0)return false;return true;}List&lt;IMyTerminalBlock&gt;jv(string jw){var jx=new List&lt;IMyTerminalBlock&gt;();
                var jy=new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(jy);for(int jz=0;jz&lt;jy.Count;jz++)
                {if(jy[jz].Name==jw){List&lt;IMyTerminalBlock&gt;jg=null;jy[jz].GetBlocks(jg,nb);for(int jj=0;jj&lt;jg.Count;
                jj++){jx.Add(jg[jj]);}break;}}return jx;}int jA(List&lt;IMyTerminalBlock&gt;jg,float dS,int jh=iQ){int jB=
                0;if(dS&gt;100)dS=100;if(dS&lt;0)dS=0;for(int jj=0;jj&lt;jg.Count;jj++){int jk=jc(jg[jj]);if((jk&amp;jh)&gt;0){IMyThrust
                iZ=jg[jj]as IMyThrust;if(!iZ.IsWorking){iZ.Enabled=true;}jB+=1;iZ.ThrustOverridePercentage=dS/100f;}
                }return jB;}int jA(List&lt;IMyTerminalBlock&gt;jg,int jC=100,int jh=iQ){return jA(jg,(float)jC,jh);}bool jA(string
                jD,int jC=100,int jh=iQ){if(jC&gt;100)jC=100;var jy=new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(jy);
                for(int jz=0;jz&lt;jy.Count;jz++){if(jy[jz].Name==jD){List&lt;IMyTerminalBlock&gt;jg=null;jy[jz].GetBlocks(jg,
                nb);return(jA(jg,jC,jh)&gt;0);}}return false;}int jE(List&lt;IMyTerminalBlock&gt;thrusters,int jh=iQ,bool jF=
                false){int jB=0;for(int jj=0;jj&lt;thrusters.Count;jj++){int jk=jc(thrusters[jj]);if((jk&amp;jh)&gt;0){jB++;IMyThrust
                iZ=thrusters[jj]as IMyThrust;iZ.ThrustOverride=0;if(iZ.IsWorking&amp;&amp;jF)iZ.Enabled=false;else if(!iZ.IsWorking
                &amp;&amp;!jF)iZ.Enabled=true;}}return jB;}bool jE(string jD){var jy=new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(jy);
                for(int jz=0;jz&lt;jy.Count;jz++){if(jy[jz].Name==jD){List&lt;IMyTerminalBlock&gt;jg=null;jy[jz].GetBlocks(jg,
                nb);return(jE(jg)&gt;0);}}return false;}bool jA(){return(jA(iy)&gt;0);}bool jE(){return(jE(iy)&gt;0);}double jG(List&lt;IMyTerminalBlock&gt;
                jH,int jh=iQ){for(int i=0;i&lt;jH.Count;i++){int jk=jc(jH[i]);if((jk&amp;jh)&gt;0&amp;&amp;jH[i].IsWorking){var iZ=jH[i]
                as IMyThrust;return iZ.ThrustOverride;}}return 0;}bool jI(List&lt;IMyTerminalBlock&gt;jH,int jh=iQ){for(int
                i=0;i&lt;jH.Count;i++){int jk=jc(jH[i]);if((jk&amp;jh)&gt;0&amp;&amp;jH[i].IsWorking){return true;}}return false;}int jJ(List&lt;IMyTerminalBlock&gt;
                jH,int jh=iQ){int jB=0;for(int i=0;i&lt;jH.Count;i++){int jk=jc(jH[i]);if((jk&amp;jh)&gt;0&amp;&amp;jH[i].IsWorking){jB++;
                }}return jB;}IMyThrust jK(List&lt;IMyTerminalBlock&gt;@is,int jL=iQ){foreach(var thrust in ix){if(thrust is
                IMyThrust&amp;&amp;(jc(thrust)&amp;jL)&gt;0)return thrust as IMyThrust;}return null;}double jM(){if(iM&lt;1)return 0;var
                jN=jK(ix,iN);if(jN==null)return 0;return jN.MaxEffectiveThrust/jN.MaxThrust;}double jO(List&lt;IMyTerminalBlock&gt;
                iB,double jP,double jQ){var jt=((IMyShipController)nn).CalculateShipMass();double ju=0;ju=jt.PhysicalMass
                *jQ*9.810;double je=jf(iB);double jR=(je-ju)/jt.TotalMass;double jS=jP/jR;double jT=jP/2*jS;return jT;
                }string[]jU={"-","\\","|","/","-","\\","|","/"};int jV=99;string jW(){jV++;if(jV&gt;=jU.Length)jV=0;return
                jU[jV];}const string jX="[WCCT]";const string jY="[WCCS]";const string jZ="[WCCM]";Dictionary&lt;string,
                List&lt;IMyTerminalBlock&gt;&gt;ka=new Dictionary&lt;string,List&lt;IMyTerminalBlock&gt;&gt;();void kb(){ka.Clear();}void
                kc(){if(!kd(jX))kd(jZ);}bool kd(string sKeyword="[WCCS]"){bool kf=false;List&lt;IMyTerminalBlock&gt;bI=new
                List&lt;IMyTerminalBlock&gt;();IMyTimerBlock kg=null;if(ka.ContainsKey(sKeyword)){bI=ka[sKeyword];}else{bI
                =nk&lt;IMyTerminalBlock&gt;(sKeyword);ka.Add(sKeyword,bI);}for(int i=0;i&lt;bI.Count;i++){kg=bI[i]as IMyTimerBlock;
                if(kg!=null){kg.ApplyAction("TriggerNow");kf=true;}}return kf;}double kh=100;double tmCameraElapsedMs
                =-1;double kj=0.50;double kk=-1;IMyShipController kl=null;double km=85;List&lt;IMyTerminalBlock&gt;kn=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;ko=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;kp=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;kq=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;kr=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;ks=new List&lt;IMyTerminalBlock&gt;();IMySensorBlock kt=null;bool ku=false;bool kv=false;
                bool kw=false;double kx=100;double ky=50;double kz=15;double kA=100;double kB=100*0.5;double kC=100*
                0.25;double kD=5;float kE=50f;bool kF=false;bool kG=false;void kH(){kl=null;oY();nx=0.01f;kk=0;tmCameraElapsedMs
                =-1;}void kI(Vector3D dK,double maxSpeed,IMyTerminalBlock kK,int jb=iQ){km=maxSpeed;if(km&gt;ig)km=ig;if
                ((hz&amp;cZ)&gt;0){kG=true;pw();}else kG=false;if((hz&amp;da)&gt;0){kF=true;}else kF=false;kl=kK as IMyShipController;
                Vector3D dL=dK-kl.CenterOfMass;double dM=dL.Length();iW(kl,ref ko,ref kn,ref ks,ref kr,ref kp,ref kq,
                jb);oY();if(oO.Count&gt;0){kt=oO[0];if(kF||kG)kt.DetectAsteroids=false;else kt.DetectAsteroids=true;kt.DetectEnemy
                =true;kt.DetectLargeShips=true;kt.DetectSmallShips=true;kt.DetectStations=true;kt.DetectPlayers=false;
                kE=kt.GetMaximum&lt;float&gt;("Front");}else{kt=null;kE=0;}ku=false;kv=false;kw=false;double kL=km;if(!kG&amp;&amp;
                !kF)kL=la(kn,dM);if(kL&lt;km)km=kL;eW+="\nDistance="+eQ(dM)+" OptimalV="+kL;kA=km;kB=km*0.50;kC=km*0.25;
                if(kC&lt;5)kC=5;if(kC&gt;kB)kB=kC;if(kC&gt;kA)kA=kC;kz=jO(kn,kC+(kB-kC)/2,0);ky=jO(kn,kB+(kA-kB)/2,0);kx=jO(kn,
                kA,0);tmCameraElapsedMs=-1;kk=0;nx=0.01f;}void kM(Vector3D dK,float arrivalDistance,int kO,int colDetectState,
                bool kQ=false){if(fX)Echo("dTM:"+kO);if(kl==null){kI(dK,kh,nn);}if(tmCameraElapsedMs&gt;=0)tmCameraElapsedMs
                +=Runtime.TimeSinceLastRun.TotalMilliseconds;if(kk&gt;=0)kk+=Runtime.TimeSinceLastRun.TotalMilliseconds;
                Vector3D dL=dK-kl.CenterOfMass;double dM=dL.Length();if(fX){Echo("dTM:distance="+eQ(dM));Echo("dTM:velocity="
                +iq.ToString("0.00"));Echo("dTM:tmMaxSpeed="+km.ToString("0.00"));}if(dM&lt;arrivalDistance){j();current_state
                =kO;kH();@in=true;return;}eJ("TargetLocation",dK);List&lt;IMySensorBlock&gt;kR=null;double kS=jO(kn,iq,0);
                Echo("StoppingD="+eQ(kS));if(oO.Count&gt;0){float kT=Math.Min(50f,(float)kS*1.5f);pa(kt,0,0,0,0,kT,0);}
                else Echo("No Sensors for Travel movement");bool kU=false;if(kG||kF){double kV=-999;kV=bc(dK,nn);Echo("yawangle="
                +kV.ToString());if(kG){Echo("Sled");bA(kV,"Yaw");}else if(kF){Echo("Rotor");gt(kV);}kU=Math.Abs(kV)&lt;
                .05;}else{kU=ny("forward",dL,nn);}kl.DampenersOverride=true;if((dM-kS)&lt;arrivalDistance){nx=0.005f;Echo("Waiting for stop");
                if(!kU)@in=true;j();return;}if(kU){bWantMedium=true;Echo("Aimed");nN();if(fZ&amp;&amp;(kk&gt;oQ||kk&lt;0)){kk=0;kR
                =oW();if(kR.Count&gt;0){var kW=new List&lt;MyDetectedEntityInfo&gt;();string s="";for(int i1=0;i1&lt;kR.Count;i1++)
                {kR[i1].DetectedEntities(kW);int j1=0;bool kX=false;if(kW.Count&gt;0)kX=true;for(;j1&lt;kW.Count;j1++){s="\nSensor TRIGGER!";
                s+="\nName: "+kW[j1].Name;s+="\nType: "+kW[j1].Type;s+="\nRelationship: "+kW[j1].Relationship;s+="\n";
                if(fX){Echo(s);es(s,ea);}if(kW[j1].Type==MyDetectedEntityType.Planet){kX=false;}if(kW[j1].Type==MyDetectedEntityType.LargeGrid
                ||kW[j1].Type==MyDetectedEntityType.SmallGrid){if(kW[j1].BoundingBox.Contains(dK)!=ContainmentType.Disjoint)
                {if(fX)Echo("Ignoring collision because we want to be INSIDE");kX=false;}}if(kX)break;}if(kX){bV=kW[j1];
                kH();current_state=colDetectState;@in=true;j();return;}}}else bV=new MyDetectedEntityInfo();}double kY
                =kS*2;{if(kY&lt;100)if(dM&lt;1000)kY=dM;else kY=1000;kY=Math.Min(dM,kY);}{Echo("Scanning distance="+kY);}if
                (fY&amp;&amp;(tmCameraElapsedMs&gt;kj||tmCameraElapsedMs&lt;0)&amp;&amp;dM&gt;kE){if(bY(bN,kY)){tmCameraElapsedMs=0;if(!bV.IsEmpty())
                {bool kX=true;if(kQ){if(bV.Type==MyDetectedEntityType.Asteroid){if(bV.BoundingBox.Contains(dK)!=ContainmentType.Disjoint)
                {kX=false;double kZ=((Vector3D)bV.HitPosition-nn.GetPosition()).Length();if((kZ-kS)&lt;arrivalDistance)
                {j();current_state=kO;kH();return;}}}else if(bV.Type==MyDetectedEntityType.Planet){kX=false;}else{}}
                if(fX){Echo("raycast hit:"+bV.Type.ToString());es("Camera Trigger collision",ea);}if(kX){kH();current_state
                =colDetectState;@in=true;j();return;}}else{if(fX){es("Camera Scan Clear",ea);}}}else{if(fX){es("No Scan Available",
                ea);}}}else Echo("Raycast delay");if(fX)Echo("dtmFar="+eQ(kx));if(fX)Echo("dtmApproach="+eQ(ky));if(fX)
                Echo("dtmPrecision="+eQ(kz));if(dM&gt;kx&amp;&amp;!ku){Echo("dtmFar");lC(kA,100f);}else if(dM&gt;ky&amp;&amp;!kv){Echo("Approach");
                ku=true;lC(kB,100f);}else if(dM&gt;kz&amp;&amp;!kw){Echo("Precision");if(!kv)nx=0.005f;kv=true;lC(kC,55f);}else
                {Echo("Close");if(!kw)nx=0.005f;kw=true;lC(kD,55f);}}else{if(fX)Echo("Aiming");@in=true;kl.DampenersOverride
                =true;if(iq&lt;5){jE(ix);}else{jE(kn,iQ,true);}}}double la(List&lt;IMyTerminalBlock&gt;lb,double dM){Echo("#thrusters="
                +lb.Count.ToString());if(lb.Count&lt;1)return ig;MyShipMass jt;jt=((IMyShipController)nn).CalculateShipMass();
                double je=jf(lb);double jR=je/jt.PhysicalMass;double kL,jS,jT;kL=((dM*.75)/2)/(jR);Echo("COS");do{Echo("COS:DO");
                jS=kL/jR;jT=kL/2*jS;if(jT&gt;dM){kL*=0.85;}Echo("stoppingM="+jT.ToString("F1")+" distance="+dM.ToString("N1"));
                }while(jT&gt;dM);Echo("COS:X");return kL;}Vector3D lc;void ld(Vector3D dK){if(tmCameraElapsedMs&gt;=0)tmCameraElapsedMs
                +=Runtime.TimeSinceLastRun.TotalMilliseconds;if(kk&gt;=0)kk+=Runtime.TimeSinceLastRun.TotalMilliseconds;
                Vector3D le;if(bV.HitPosition.HasValue){le=(Vector3D)bV.HitPosition;}else{le=nn.GetPosition();}Vector3D
                bi=bV.Position;Vector3D dL=(bi-le);dL.Normalize();Vector3D lf=bV.BoundingBox.Min;Vector3D lg=bV.BoundingBox.Max;
                double lh=(bi-lf).Length();double li=lh+hI.hZ()*5;Vector3D lj;lj=Vector3D.Cross(dK,le);lj.Normalize();
                lj=le+lj*li;lc=lj;}bool lk=true;bool ll=true;bool lm=true;bool ln=true;bool lo=true;bool lp=true;MyDetectedEntityInfo
                lq=new MyDetectedEntityInfo();MyDetectedEntityInfo lr=new MyDetectedEntityInfo();MyDetectedEntityInfo
                ls=new MyDetectedEntityInfo();MyDetectedEntityInfo lt=new MyDetectedEntityInfo();MyDetectedEntityInfo
                lu=new MyDetectedEntityInfo();MyDetectedEntityInfo lv=new MyDetectedEntityInfo();void lw(){if(tmCameraElapsedMs
                &gt;=0)tmCameraElapsedMs+=Runtime.TimeSinceLastRun.TotalMilliseconds;if(kk&gt;=0)kk+=Runtime.TimeSinceLastRun.TotalMilliseconds;
                lk=true;ll=true;lm=true;ln=true;lo=false;lp=true;lq=new MyDetectedEntityInfo();lr=new MyDetectedEntityInfo();
                ls=new MyDetectedEntityInfo();lt=new MyDetectedEntityInfo();lu=new MyDetectedEntityInfo();lv=new MyDetectedEntityInfo();
                if(bV.Type==MyDetectedEntityType.LargeGrid||bV.Type==MyDetectedEntityType.SmallGrid){}if(bR.Count&lt;1)
                lk=false;if(bS.Count&lt;1)ll=false;if(bQ.Count&lt;1)lm=false;if(bP.Count&lt;1)ln=false;if(bN.Count&lt;1)lp=false;
                if(bO.Count&lt;1)lo=false;}bool lx(){if(tmCameraElapsedMs&gt;=0)tmCameraElapsedMs+=Runtime.TimeSinceLastRun.TotalMilliseconds;
                if(kk&gt;=0)kk+=Runtime.TimeSinceLastRun.TotalMilliseconds;MatrixD ly=nn.WorldMatrix;Vector3D dL=ly.Forward;
                Echo("ScanEscape()");if(lk){if(bY(bR,200)){lk=false;lq=bV;if(bV.IsEmpty()){dL=ly.Left;dL.Normalize();
                lc=nn.GetPosition()+dL*200;return true;}}}if(ll){if(bY(bS,200)){ll=false;lr=bV;if(bV.IsEmpty()){dL=ly.Right;
                dL.Normalize();lc=nn.GetPosition()+dL*200;return true;}}}if(lm){if(bY(bQ,200)){ls=bV;lm=false;if(bV.IsEmpty())
                {dL=ly.Up;dL.Normalize();lc=nn.GetPosition()+dL*200;return true;}}}if(ln){if(bY(bP,200)){lt=bV;ln=false;
                if(bV.IsEmpty()){dL=ly.Down;dL.Normalize();lc=nn.GetPosition()+dL*200;return true;}}}if(lo){if(bY(bO,
                200)){lu=bV;lo=false;if(bV.IsEmpty()){dL=ly.Backward;dL.Normalize();lc=nn.GetPosition()+dL*200;return
                true;}}}if(lp){if(bY(bN,200)){lp=false;if(bV.IsEmpty()){dL=ly.Forward;dL.Normalize();lc=nn.GetPosition()
                +dL*200;return true;}}}if(lp||lo||lm||ln||lk||ll){Echo("More scans");return false;}Echo("Scans done. Choose longest");
                MyDetectedEntityInfo lz=lu;Vector3D lA=nn.GetPosition();dL=ly.Backward;if(lz.HitPosition==null||lq.HitPosition
                !=null&amp;&amp;Vector3D.DistanceSquared(lA,(Vector3D)lz.HitPosition)&lt;Vector3D.DistanceSquared(lA,(Vector3D)lq.HitPosition))
                {dL=ly.Left;lz=lq;}if(lz.HitPosition==null||lr.HitPosition!=null&amp;&amp;Vector3D.DistanceSquared(lA,(Vector3D)lz.HitPosition)
                &lt;Vector3D.DistanceSquared(lA,(Vector3D)lr.HitPosition)){dL=ly.Right;lz=lr;}if(lz.HitPosition==null||
                ls.HitPosition!=null&amp;&amp;Vector3D.DistanceSquared(lA,(Vector3D)lz.HitPosition)&lt;Vector3D.DistanceSquared(lA,
                (Vector3D)ls.HitPosition)){dL=ly.Up;lz=ls;}if(lz.HitPosition==null||lt.HitPosition!=null&amp;&amp;Vector3D.DistanceSquared(lA,
                (Vector3D)lz.HitPosition)&lt;Vector3D.DistanceSquared(lA,(Vector3D)lt.HitPosition)){dL=ly.Down;lz=lt;}if
                (lz.HitPosition==null||lv.HitPosition!=null&amp;&amp;Vector3D.DistanceSquared(lA,(Vector3D)lz.HitPosition)&lt;Vector3D.DistanceSquared(lA,
                (Vector3D)lv.HitPosition)){dL=ly.Forward;lz=lv;}if(lz.HitPosition==null)return false;double dM=Vector3D.Distance(lA,
                (Vector3D)lz.HitPosition);Echo("Distance="+eQ(dM));dL.Normalize();lc=nn.GetPosition()+dL*dM/2;if(dM&gt;
                4){return true;}return false;}void lB(float dS){if(kF){gk(dS);}else jA(ko,dS);}void lC(double maxSpeed,
                float maxThrust){if(!kF){if(iq&lt;1)jA(ko,maxThrust);else if(iq&lt;maxSpeed*.75)jA(ko,25f);else if(iq&lt;maxSpeed
                *.85)jA(ko,15f);else if(iq&lt;=maxSpeed*.98){jA(ko,1f);}else if(iq&gt;=maxSpeed*1.02){jE(ix);}else{jE(ix);
                jE(kn,iQ,true);}}else{lB(maxThrust);}}bool lD=false;List&lt;IMyRadioAntenna&gt;lE=new List&lt;IMyRadioAntenna&gt;();
                List&lt;IMyLaserAntenna&gt;lF=new List&lt;IMyLaserAntenna&gt;();string lG(){lE.Clear();lF.Clear();nh&lt;IMyRadioAntenna&gt;(ref
                lE);nh&lt;IMyLaserAntenna&gt;(ref lF);for(int i=0;i&lt;lE.Count;++i){if(lE[i].CustomName.Contains("unused")||
                lE[i].CustomData.Contains("unused"))continue;if(!lD){a="Wico "+lE[i].CustomName.Split('!')[0].Trim();
                lD=true;}}return"A"+lE.Count.ToString("0");}void lH(){for(int i=0;i&lt;lE.Count;i++){lE[i].Enabled=true;
                }}string lI="";void lJ(){if(hC!=""){if(lI==hC){hC="";}lI=hC;}else lI="";}void lK(){}void lL(){float lM
                =0;int lN=-1;for(int i=0;i&lt;lE.Count;i++){if(lE[i].AttachedProgrammableBlock==Me.EntityId){lN=i;break;
                }if(lE[i].Radius&gt;lM&amp;&amp;lE[i].AttachedProgrammableBlock==0){lN=i;lM=lE[i].Radius;}}if(lN&gt;=0){if(lE[lN].AttachedProgrammableBlock
                !=Me.EntityId)eW+="\nSetting Antenna PB";lE[lN].AttachedProgrammableBlock=Me.EntityId;}else{}}void lO(bool
                lP=false){if(lE.Count&lt;1)lG();foreach(var a in lE){a.Radius=200;if(a.AttachedProgrammableBlock&gt;0||lP)
                {a.Enabled=true;}}}void lQ(float lR=200,bool lP=false){if(lE.Count&lt;1)lG();foreach(var a in lE){if(a.AttachedProgrammableBlock
                &gt;0||lP){a.Radius=lR;a.Enabled=true;}}}Vector3D lS(){if(lE.Count&lt;1)lG();foreach(var a in lE){if(a.AttachedProgrammableBlock
                ==Me.EntityId){return a.GetPosition();}}foreach(var a in lE){return a.GetPosition();}Vector3D lT=new
                Vector3D();return lT;}void lU(bool lP=false,float lV=float.MaxValue){if(lE.Count&lt;1)lG();if(lV&lt;200)lV
                =200;foreach(var a in lE){if(a.AttachedProgrammableBlock&gt;0||lP){float lW=a.GetMaximum&lt;float&gt;("Radius");
                if(lV&lt;lW)lW=lV;a.Radius=lW;a.Enabled=true;}}}int lX(){if(lE.Count&lt;1)lG();return(lE.Count);}List&lt;string&gt;
                lY=new List&lt;string&gt;();void lZ(){if(lY.Count&gt;0){ma(lY[0]);lY.RemoveAt(0);}if(lY.Count&gt;0)@in=true;}void
                ma(string mb){bool mc=false;if(lE.Count&lt;1)lG();for(int i=0;i&lt;lE.Count;i++){mc=lE[i].TransmitMessage(mb);
                if(mc)break;}if(!mc){if(lX()&gt;0){lY.Add(mb);@in=true;}}}List&lt;string&gt;md=new List&lt;string&gt;();void me(bool
                mf=false){if(md.Count&gt;0){if(hC==""){hC=md[0];md.RemoveAt(0);if(mf){@in=true;}else{kc();}}}if(md.Count
                &gt;0){}}void mg(string mb){md.Add(mb);me();}void mh(){if(lE.Count&gt;0){Echo(md.Count+" Pending Incoming Messages");
                for(int i=0;i&lt;md.Count;i++)Echo(i+":"+md[i]);}else Echo("No antennas found");}List&lt;IMyTerminalBlock&gt;
                mi=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;mj=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                mk=new List&lt;IMyTerminalBlock&gt;();bool ml=false;string mm="[BASE]";string mn="[DOCK]";string mo="CONNECTORS";
                void mp(nO iNIHolder){iNIHolder.op(mo,"BaseConnector",ref mm,true);iNIHolder.op(mo,"DockConnector",ref
                mn,true);}string mq(){ml=false;mi.Clear();mj.Clear();mk.Clear();mr();return"CL"+mi.Count.ToString()+
                "CD"+mj.Count.ToString()+"CB"+mk.Count.ToString();}void mr(){if(mi.Count&lt;1&amp;&amp;!ml)mi=nh&lt;IMyShipConnector&gt;();
                if(mj.Count&lt;1&amp;&amp;!ml)mj=nk&lt;IMyShipConnector&gt;(mn);if(mj.Count&lt;1&amp;&amp;!ml)mj=mi;if(mk.Count&lt;1&amp;&amp;!ml)mk=nk&lt;IMyShipConnector&gt;(mm);
                ml=true;return;}bool ms(){mr();for(int i=0;i&lt;mj.Count;i++){var sc=mj[i]as IMyShipConnector;if(sc.Status
                ==MyShipConnectorStatus.Connectable)return true;}return false;}bool mt(){mr();for(int i=0;i&lt;mj.Count;
                i++){var sc=mj[i]as IMyShipConnector;if(sc.Status==MyShipConnectorStatus.Connected){var mu=sc.OtherConnector;
                if(mu.CubeGrid==sc.CubeGrid){continue;}else return true;}}return false;}IMyTerminalBlock mv(){mr();if
                (mj.Count&gt;0){return mj[0];}return null;}IMyTerminalBlock mw(bool mx=false){mr();for(int i=0;i&lt;mj.Count;
                i++){var sc=mj[i]as IMyShipConnector;if(sc.Status==MyShipConnectorStatus.Connected){var mu=sc.OtherConnector;
                if(mu.CubeGrid==sc.CubeGrid){continue;}else{if(!mx){return sc.OtherConnector;}else{return mj[i];}}}}
                return null;}void my(bool mz=true,bool bJ=true){mr();for(int i=0;i&lt;mj.Count;i++){var sc=mj[i]as IMyShipConnector;
                if(sc.Status==MyShipConnectorStatus.Connected){var mu=sc.OtherConnector;if(mu.CubeGrid==sc.CubeGrid)
                {continue;}}if(mz){if(sc.Status==MyShipConnectorStatus.Connectable)sc.ApplyAction("SwitchLock");}else
                {if(sc.Status==MyShipConnectorStatus.Connected)sc.ApplyAction("SwitchLock");}sc.Enabled=bJ;}return;}
                string mA="NOFOLLOW";string mB="!WCC";string mC="[NAV]";string mD="Craft Remote Control";string mE="GRIDS";
                void mF(nO iNIHolder){iNIHolder.op(mE,"NoFollow",ref mA,true);iNIHolder.op(mE,"BlockIgnore",ref mB,true);
                iNIHolder.op(mE,"OrientationBlockContains",ref mC,true);iNIHolder.op(mE,"OrientationBlockNamed",ref mD,
                true);}List&lt;IMyTerminalBlock&gt;mG=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyCubeGrid&gt;mH=new List&lt;IMyCubeGrid&gt;();
                List&lt;IMyCubeGrid&gt;mI=new List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;mJ=new List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;
                mK=new List&lt;IMyCubeGrid&gt;();bool mL(){List&lt;IMyTerminalBlock&gt;mM=new List&lt;IMyTerminalBlock&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyTerminalBlock&gt;(mM);
                if(allBlocksCount!=mM.Count){return true;}return false;}string mN(){mG.Clear();mK.Clear();mH.Clear();
                mI.Clear();mJ.Clear();GridTerminalSystem.GetBlocksOfType&lt;IMyTerminalBlock&gt;(mG);allBlocksCount=mG.Count;
                foreach(var block in mG){var bt=block.CubeGrid;if(!mK.Contains(bt)){mK.Add(bt);}}mQ(Me.CubeGrid);foreach
                (var grid in mK){if(mH.Contains(grid))continue;bool mO=false;List&lt;IMyShipConnector&gt;mP=new List&lt;IMyShipConnector&gt;();
                GridTerminalSystem.GetBlocksOfType&lt;IMyShipConnector&gt;(mP,(x1=&gt;x1.CubeGrid==grid));foreach(var connector
                in mP){if(connector.Status==MyShipConnectorStatus.Connected){if(mH.Contains(connector.OtherConnector.CubeGrid)
                ||mI.Contains(connector.OtherConnector.CubeGrid)){continue;}if(mH.Contains(connector.OtherConnector.CubeGrid))
                mO=true;else mO=false;}}if(mO){if(!mJ.Contains(grid)){mJ.Add(grid);}}if(!mI.Contains(grid)){mI.Add(grid);
                }}string s="";s+="B"+mG.Count.ToString();s+="G"+mK.Count.ToString();s+="L"+mH.Count.ToString();s+="D"
                +mJ.Count.ToString();s+="R"+mI.Count.ToString();return s;}void mQ(IMyCubeGrid bt){if(bt==null)return;
                if(!mH.Contains(bt)){mH.Add(bt);mR(bt);mU(bt);mW(bt);mY(bt);}}void mR(IMyCubeGrid grid){List&lt;IMyMotorStator&gt;
                mS=new List&lt;IMyMotorStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(mS,(x=&gt;x.TopGrid==grid));
                foreach(var rotor in mS){if(rotor.CustomName.Contains(mA)||rotor.CustomData.Contains(mA))continue;mQ(rotor.CubeGrid);
                }List&lt;IMyMotorAdvancedStator&gt;mT=new List&lt;IMyMotorAdvancedStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorAdvancedStator&gt;(mT,
                (x=&gt;x.TopGrid==grid));foreach(var rotor in mT){if(rotor.CustomName.Contains(mA)||rotor.CustomData.Contains(mA))
                continue;mQ(rotor.CubeGrid);}}void mU(IMyCubeGrid grid){List&lt;IMyPistonBase&gt;mV=new List&lt;IMyPistonBase&gt;();
                GridTerminalSystem.GetBlocksOfType&lt;IMyPistonBase&gt;(mV,(x=&gt;x.TopGrid==grid));foreach(var piston in mV)
                {mQ(piston.CubeGrid);}}void mW(IMyCubeGrid grid){List&lt;IMyMotorStator&gt;mS=new List&lt;IMyMotorStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(mS,
                (x1=&gt;x1.CubeGrid==grid));foreach(var rotor in mS){if(rotor.CustomName.Contains(mA)||rotor.CustomData.Contains(mA))
                continue;IMyCubeGrid mX=rotor.TopGrid;if(mX!=null&amp;&amp;mX!=grid){mQ(mX);}}mS.Clear();List&lt;IMyMotorAdvancedStator&gt;
                mT=new List&lt;IMyMotorAdvancedStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorAdvancedStator&gt;(mT,
                (x1=&gt;x1.CubeGrid==grid));foreach(var rotor in mT){if(rotor.CustomName.Contains(mA)||rotor.CustomData.Contains(mA))
                continue;IMyCubeGrid mX=rotor.TopGrid;if(mX!=null&amp;&amp;mX!=grid){mQ(mX);}}}void mY(IMyCubeGrid grid){List&lt;IMyPistonBase&gt;
                mV=new List&lt;IMyPistonBase&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyPistonBase&gt;(mV,(x1=&gt;x1.CubeGrid==
                grid));foreach(var piston in mV){IMyCubeGrid mX=piston.TopGrid;if(mX!=null&amp;&amp;mX!=grid){if(!mH.Contains(mX))
                {mQ(mX);}}}}List&lt;IMyCubeGrid&gt;mZ(){if(mH.Count&lt;1){mN();}return mH;}List&lt;IMyCubeGrid&gt;na(){if(mH.Count&lt;
                1){mN();}return mJ;}bool nb(IMyTerminalBlock block){return mZ().Contains(block.CubeGrid);}bool nc(long
                nd){for(int i=0;i&lt;mH.Count;i++){if((long)mH[i].EntityId==nd)return true;}return false;}bool nc(IMyCubeGrid
                nd){return mZ().Contains(nd);}bool ne(IMyTerminalBlock gP){List&lt;IMyCubeGrid&gt;g=na();if(g==null)return
                false;return g.Contains(gP.CubeGrid);}IMyTerminalBlock nf(string ng){IMyTerminalBlock gP;gP=(IMyTerminalBlock)GridTerminalSystem.GetBlockWithName(ng);
                if(gP==null)throw new Exception(ng+" Not Found");return gP;}public List&lt;T&gt;nh&lt;T&gt;(ref List&lt;T&gt;ni,string
                nj=null)where T:class{if(mG.Count&lt;1)mN();if(ni==null)ni=new List&lt;T&gt;();else ni.Clear();for(int e=0;e&lt;
                mG.Count;e++){if(nb(mG[e])&amp;&amp;mG[e]is T&amp;&amp;((nj==null)||(nj!=null&amp;&amp;mG[e].CustomName.StartsWith(nj)))){ni.Add((T)mG[e]);
                }}return ni;}public List&lt;IMyTerminalBlock&gt;nh&lt;T&gt;(ref List&lt;IMyTerminalBlock&gt;ni,string nj=null)where T:
                class{if(mG.Count&lt;1)mN();if(ni==null)ni=new List&lt;IMyTerminalBlock&gt;();else ni.Clear();for(int e=0;e&lt;mG.Count;
                e++){if(nb(mG[e])&amp;&amp;mG[e]is T&amp;&amp;((nj==null)||(nj!=null&amp;&amp;mG[e].CustomName.StartsWith(nj)))){ni.Add(mG[e]);
                }}return ni;}public List&lt;IMyTerminalBlock&gt;nh&lt;T&gt;(string nj=null)where T:class{var ni=new List&lt;IMyTerminalBlock&gt;();
                nh&lt;T&gt;(ref ni,nj);return ni;}public List&lt;IMyTerminalBlock&gt;nk&lt;T&gt;(string Keyword=null)where T:class{if(mG.Count
                &lt;1)mN();var ni=new List&lt;IMyTerminalBlock&gt;();for(int e=0;e&lt;mG.Count;e++){if(mG[e]is T&amp;&amp;nb(mG[e])&amp;&amp;Keyword
                !=null&amp;&amp;(mG[e].CustomName.Contains(Keyword)||mG[e].CustomData.Contains(Keyword))&amp;&amp;!(mG[e].CustomName.Contains(mB)
                ||mG[e].CustomData.Contains(mB))){ni.Add(mG[e]);}}return ni;}public List&lt;IMyTerminalBlock&gt;nl&lt;T&gt;(string
                nj=null)where T:class{if(mG.Count&lt;1)mN();var ni=new List&lt;IMyTerminalBlock&gt;();for(int e=0;e&lt;mG.Count;
                e++){if(mG[e]is T&amp;&amp;Me.CubeGrid==mG[e].CubeGrid&amp;&amp;nj!=null&amp;&amp;(mG[e].CustomName.Contains(nj)||mG[e].CustomData.Contains(nj))
                &amp;&amp;!(mG[e].CustomName.Contains(mB)||mG[e].CustomData.Contains(mB))){ni.Add(mG[e]);}}return ni;}public
                List&lt;IMyTerminalBlock&gt;nm&lt;T&gt;(string nj=null)where T:class{if(mG.Count&lt;1)mN();var ni=new List&lt;IMyTerminalBlock&gt;();
                for(int e=0;e&lt;mG.Count;e++){if(mG[e]is T&amp;&amp;nb(mG[e])&amp;&amp;nj!=null&amp;&amp;mG[e].CustomName==nj){ni.Add(mG[e]);}
                }return ni;}IMyTerminalBlock nn=null;string DefaultOrientationBlockInit(){string sInitResults="";var
                centerSearch=new List&lt;IMyTerminalBlock&gt;();nh&lt;IMyTerminalBlock&gt;(ref centerSearch,mD);if(centerSearch.Count
                ==0){centerSearch=nk&lt;IMyRemoteControl&gt;(mC);if(centerSearch.Count==0){nh&lt;IMyRemoteControl&gt;(ref centerSearch);
                if(centerSearch.Count==0){nh&lt;IMyCockpit&gt;(ref centerSearch);int i=0;for(;i&lt;centerSearch.Count;i++){Echo("Checking Controller:"
                +centerSearch[i].CustomName);if(centerSearch[i]is IMyCryoChamber)continue;break;}if(i&gt;=centerSearch.Count)
                {sInitResults+="!!NO valid Controller";Echo("No Controller found");}else{sInitResults+="S";Echo("Using good ship Controller: "
                +centerSearch[i].CustomName);}}else{sInitResults+="R";Echo("Using First Remote control found: "+centerSearch[0].CustomName);
                }}}else{sInitResults+="N";Echo("Using Named: "+centerSearch[0].CustomName);}if(centerSearch.Count&gt;0)
                nn=centerSearch[0];return sInitResults;}string nq="!NAV";void nr(nO f){f.op(mE,"GyroIgnore",ref nq,true);
                }double ns=0.9;int nt=3;int nu=-1;IMyShipController nv;List&lt;IMyGyro&gt;nw;float nx=0.01f;bool GyroMain(string
                argument){if(nv==null)nL();if(nv is IMyShipController){Vector3D nA=(nv as IMyShipController).GetNaturalGravity();
                return ny(argument,nA,nn);}else{Echo("No Controller for gravity");}return true;}bool ny(string nz,Vector3D
                nB,IMyTerminalBlock nC){bool dJ=true;if(nv==null)nL();Matrix or;nC.Orientation.GetMatrix(out or);Vector3D
                nD;nz=nz.ToLower();if(nz.Contains("rocket"))nD=or.Backward;else if(nz.Contains("up"))nD=or.Up;else if
                (nz.Contains("backward"))nD=or.Backward;else if(nz.Contains("forward"))nD=or.Forward;else nD=or.Down;
                nB.Normalize();for(int i=0;i&lt;nw.Count;++i){var g=nw[i];g.Orientation.GetMatrix(out or);var nE=Vector3D.Transform(nD,
                MatrixD.Transpose(or));var nF=Vector3D.Transform(nB,MatrixD.Transpose(g.WorldMatrix.GetOrientation()));
                var nG=Vector3D.Cross(nE,nF);double nH=Vector3D.Dot(nE,nF);double nI=nG.Length();nI=Math.Atan2(nI,Math.Sqrt(Math.Max(0.0,
                1.0-nI*nI)));if(nH&lt;0)nI=Math.PI-nI;if(nI&lt;nx){g.GyroOverride=false;continue;}float nJ=g.GetMaximum&lt;float&gt;("Yaw");
                double nK=nJ*(nI/Math.PI)*ns;nK=Math.Min(nJ,nK);nK=Math.Max(0.01,nK);nG.Normalize();nG*=nK;float Y=-(float)nG.X;
                g.Pitch=Y;float W=-(float)nG.Y;g.Yaw=W;float ba=-(float)nG.Z;g.Roll=ba;g.GyroOverride=true;dJ=false;
                }return dJ;}string nL(){string s="";var l=new List&lt;IMyTerminalBlock&gt;();nv=nn as IMyShipController;if
                (nv==null){if(l.Count&lt;1)return"No RC!";}nN();GridTerminalSystem.GetBlocksOfType&lt;IMyGyro&gt;(l,x=&gt;x.CubeGrid
                ==nn.CubeGrid);var l2=new List&lt;IMyTerminalBlock&gt;();int nM=0;for(int i=0;i&lt;l.Count;i++){if(l[i].CustomName.Contains(nq)
                ||l[i].CustomData.Contains(nq)){nM++;continue;}l2.Add(l[i]);}nw=l2.ConvertAll(x=&gt;(IMyGyro)x);if(nt&gt;0)
                if(nw.Count&gt;nt)nw.RemoveRange(nt,nw.Count-nt);else if((nu-nM)&gt;0){int ha=nw.Count-(nu-nM);nw.RemoveRange(ha,
                (nu-nM));}nN();s+="GYRO#"+nw.Count.ToString("00")+"#";return s;}void nN(){if(nw!=null){for(int i=0;i
                &lt;nw.Count;++i){nw[i].GyroOverride=false;nw[i].Enabled=true;}}}public class nO{Dictionary&lt;string,string&gt;
                nP;Dictionary&lt;string,string[]&gt;nQ;Dictionary&lt;string,Dictionary&lt;string,string&gt;&gt;nR;char nS='[';char nT=
                ']';string nU="";MyGridProgram cu;string nV="";static string[]nW={"true","yes","on","1"};const StringComparison
                nX=StringComparison.OrdinalIgnoreCase;const char nY='=';public bool nZ{get;private set;}=false;public
                nO(MyGridProgram pg,string hr){cu=pg;nP=new Dictionary&lt;string,string&gt;();nQ=new Dictionary&lt;string,string[]&gt;();
                nR=new Dictionary&lt;string,Dictionary&lt;string,string&gt;&gt;();oa(hr);}public int oa(string hr){hr.TrimEnd();
                if(nV==hr){return nP.Count;}nP.Clear();nQ.Clear();nR.Clear();nU="";nZ=false;nV=hr;string[]ob=hr.Split('\n');
                for(int oc=0;oc&lt;ob.Count();oc++){string od="";ob[oc].Trim();if(ob[oc].StartsWith(nS.ToString())){string
                co="";for(int oe=1;oe&lt;ob[oc].Length;oe++)if(ob[oc][oe]==nT)break;else co+=ob[oc][oe];if(co!=""){od=co.ToUpper();
                }else continue;oc++;string of="";var og=new string[ob.Count()-oc];int oh=0;var oi=new Dictionary&lt;string,
                string&gt;();for(;oc&lt;ob.Count();oc++){ob[oc].Trim();if(ob[oc].StartsWith(nS.ToString())){oc--;break;}of
                +=ob[oc]+"\n";og[oh++]=ob[oc];if(ob[oc].Contains(nY)){string[]oj=ob[oc].Split('=');if(oj.Count()&gt;1){
                string ok=oj[0];string J="";for(int i1=1;i1&lt;oj.Count();i1++){J+=oj[i1];if(i1+1&lt;oj.Count())J+=nY;}oi.Add(ok,
                J);}}}nR.Add(od,oi);nQ.Add(od,og);nP.Add(od,of);}else{nU+=ob[oc]+"\n";}}return nP.Count;}public string
                ol(string om){string of="";if(nP.ContainsKey(om))of=nP[om];return of;}public string[]on(string om){string[]
                oo={""};if(nQ.ContainsKey(om))oo=nQ[om];return oo;}public bool op(string om,string ok,ref string oq,
                bool or=false){if(nR.ContainsKey(om)){var os=nR[om];if(os.ContainsKey(ok)){oq=os[ok];return true;}}if
                (or)oC(om,ok,oq);return false;}public bool op(string om,string ok,ref long ot,bool or=false){string ou
                ="";if(!op(om,ok,ref ou)){if(or){oC(om,ok,ot);}return false;}ot=Convert.ToInt64(ou);return true;}public
                bool op(string om,string ok,ref int ov,bool or=false){string ou="";if(!op(om,ok,ref ou)){if(or){oC(om,
                ok,ov);}return false;}ov=Convert.ToInt32(ou);return true;}public bool op(string om,string ok,ref double
                ow,bool or=false){string ou="";if(!op(om,ok,ref ou)){if(or){oC(om,ok,ow);}return false;}bool ox=double.TryParse(ou,
                out ow);return true;}public bool op(string om,string ok,ref float oy,bool or=false){string ou="";if(!op(om,
                ok,ref ou)){if(or){oC(om,ok,oy.ToString());}return false;}bool ox=float.TryParse(ou,out oy);return true;
                }public bool op(string om,string ok,ref DateTime oz,bool or=false){string ou="";if(!op(om,ok,ref ou))
                {if(or){oC(om,ok,oz);}return false;}oz=DateTime.Parse(ou);return true;}public bool op(string om,string
                ok,ref Vector3D oA,bool or=false){string ou="";if(!op(om,ok,ref ou)){if(or){oC(om,ok,oA);}return false;
                }double x1,y1,z1;hG(ou,out x1,out y1,out z1);oA.X=x1;oA.Y=y1;oA.Z=z1;return true;}public bool op(string
                om,string ok,ref bool oB,bool or=false){string ou="";if(!op(om,ok,ref ou)){if(or){oC(om,ok,oB);}return
                false;}oB=nW.Any(c=&gt;string.Equals(ou,c,nX));return true;}public bool oC(string section,string key,string
                ou){if(nP.ContainsKey(section)){nP[section]="";}else{nP.Add(section,"");nZ=true;}if(nR.ContainsKey(section))
                {var oi=new Dictionary&lt;string,string&gt;();var os=nR[section];if(os.ContainsKey(key)){if(os[key]==ou)return
                false;os[key]=ou;}else{os.Add(key,ou);}nZ=true;}else{var oi=new Dictionary&lt;string,string&gt;();oi.Add(key,
                ou);nR.Add(section,oi);nZ=true;}return true;}public bool oC(string om,string ok,Vector3D oA){oC(om,ok,
                hF(oA));return true;}public bool oC(string om,string ok,bool oB){oC(om,ok,oB.ToString());return true;
                }public bool oC(string om,string ok,int oD){oC(om,ok,oD.ToString());return true;}public bool oC(string
                om,string ok,long oE){oC(om,ok,oE.ToString());return true;}public bool oC(string om,string ok,DateTime
                oz){oC(om,ok,oz.ToString());return true;}public bool oC(string om,string ok,float oy){oC(om,ok,oy.ToString());
                return true;}public bool oC(string om,string ok,double ow){oC(om,ok,ow.ToString());return true;}public
                void oF(string om,string of){of.TrimEnd();om=om.ToUpper();if(nP.ContainsKey(om)){if(nP[om]!=of){nP[om]
                =of;nZ=true;}}else{nZ=true;nP.Add(om,of);}}public string oG(bool oH=true){string oI="";string s1=nU.Trim();
                if(s1!="")oI=s1+"\n";foreach(var kv in nP){oI+=nS+kv.Key.Trim()+nT+"\n";if(kv.Value.TrimEnd()==""){string
                oJ="";if(nR.ContainsKey(kv.Key)){foreach(var dk in nR[kv.Key]){oJ+=dk.Key+nY+dk.Value+"\n";}}oJ+="\n";
                oI+=oJ;}else{oI+=kv.Value.Trim()+"\n\n";}}if(oH){nZ=false;nV=oI;}return oI;}bool hG(string hH,out double
                x,out double y,out double z){string[]hi=hH.Trim().Split(',');if(hi.Length&lt;3){hi=hH.Trim().Split(':');
                }x=0;y=0;z=0;if(hi.Length&lt;3)return false;bool hl=double.TryParse(hi[0].Trim(),out x);bool hm=double.TryParse(hi[1].Trim(),
                out y);bool hn=double.TryParse(hi[2].Trim(),out z);if(!hl||!hm||!hn){return false;}return true;}string
                hF(Vector3D v){string s;s=v.X.ToString("0.00")+":"+v.Y.ToString("0.00")+":"+v.Z.ToString("0.00");return
                s;}}List&lt;IMyTerminalBlock&gt;oK=new List&lt;IMyTerminalBlock&gt;();string oL(){oK.Clear();oK=nh&lt;IMyLightingBlock&gt;();
                return"L"+oK.Count.ToString("00");}void oM(List&lt;IMyTerminalBlock&gt;oK,Color c){for(int i=0;i&lt;oK.Count;
                i++){var oN=oK[i]as IMyLightingBlock;if(oN==null)continue;if(oN.Color.Equals(c)&amp;&amp;oN.Enabled){continue;
                }oN.Color=c;}}List&lt;IMySensorBlock&gt;oO=new List&lt;IMySensorBlock&gt;();string oP="[WICO]";double oQ=0.125;const
                string oR="SENSORS";void oS(nO f){f.op(oR,"SensorUse",ref oP,true);f.op(oR,"SensorSettleWaitMS",ref oQ,
                true);}string oT(bool oU=true){oO.Clear();List&lt;IMyTerminalBlock&gt;oV=nk&lt;IMySensorBlock&gt;(oP);foreach(var
                sb1 in oV){oO.Add(sb1 as IMySensorBlock);}if(oU)oY();return"S"+oO.Count.ToString("00");}List&lt;IMySensorBlock&gt;
                oW(string oX=null){List&lt;IMySensorBlock&gt;oW=new List&lt;IMySensorBlock&gt;();for(int i1=0;i1&lt;oO.Count;i1++){
                IMySensorBlock s=oO[i1]as IMySensorBlock;if(s==null)continue;if(s.IsActive&amp;&amp;s.Enabled&amp;&amp;!s.LastDetectedEntity.IsEmpty())
                {oW.Add(oO[i1]);}}return oW;}void oY(){for(int i1=0;i1&lt;oO.Count;i1++){IMySensorBlock oZ=oO[i1]as IMySensorBlock;
                if(oZ==null)continue;oZ.LeftExtend=oZ.RightExtend=oZ.TopExtend=oZ.BottomExtend=oZ.FrontExtend=oZ.BackExtend
                =1;oZ.Enabled=false;}}void pa(IMyTerminalBlock tb,float pb,float pc,float pd,float pe,float pf,float
                pg){IMySensorBlock oZ=tb as IMySensorBlock;if(oZ==null)return;float ph=oZ.Position.X*0.5f;float pi=oZ.Position.Y
                *0.5f;float pj=oZ.Position.Z*0.5f;Echo("SB.x.y.z="+ph.ToString("0.0")+":"+pi.ToString("0.0")+":"+pj.ToString("0.0"));
                Echo("MIN="+Me.CubeGrid.Min.ToString()+"\nMAX:"+Me.CubeGrid.Max.ToString());float pk;pk=(float)(hI.hZ()
                /2-ph+pb);oZ.LeftExtend=Math.Max(pk,1.0f);pk=(float)(hI.hZ()/2+ph+pc);oZ.RightExtend=Math.Max(pk,1.0f);
                pk=(float)(hI.ib()/2-pi+pd);oZ.TopExtend=Math.Max(pk,1.0f);pk=(float)(hI.ib()/2+pi+pe);oZ.BottomExtend
                =Math.Max(pk,1.0f);pk=(float)(hI.hX()+pj+pf);oZ.FrontExtend=Math.Max(pk,1.0f);pk=(float)(hI.hX()-pj+
                pg);oZ.BackExtend=Math.Max(pk,1.0f);oZ.Enabled=true;}bool pl(IMySensorBlock s1,ref bool pm,ref bool pn,
                ref bool po){pm=false;pn=false;po=false;if(s1!=null&amp;&amp;s1.IsActive&amp;&amp;s1.Enabled&amp;&amp;!s1.LastDetectedEntity.IsEmpty())
                {List&lt;MyDetectedEntityInfo&gt;pp=new List&lt;MyDetectedEntityInfo&gt;();s1.DetectedEntities(pp);for(int j1=0;
                j1&lt;pp.Count;j1++){if(pp[j1].Type==MyDetectedEntityType.Asteroid){pm=true;}else if(pp[j1].Type==MyDetectedEntityType.LargeGrid)
                {pn=true;}else if(pp[j1].Type==MyDetectedEntityType.SmallGrid){po=true;}}}return pm||pn||po;}List&lt;IMyTerminalBlock&gt;
                pq=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;pr=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                ps=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;pt=new List&lt;IMyTerminalBlock&gt;();string pu(IMyTerminalBlock
                ci){pq.Clear();pr.Clear();ps.Clear();pt.Clear();nh&lt;IMyMotorSuspension&gt;(ref pq);for(int i=0;i&lt;pq.Count;
                i++){if(pq[i].CustomName.Contains("[SLED]")||pq[i].CustomData.Contains("[SLED]")){pr.Add(pq[i]);if(pq[i].CustomName.Contains("[REAR]")
                ||pq[i].CustomData.Contains("[FRONT]")){ps.Add(pq[i]);}if(pq[i].CustomName.Contains("[FRONT]")||pq[i].CustomData.Contains("[FRONT]"))
                {pt.Add(pq[i]);}}}return"W"+pq.Count.ToString("0")+"WS"+pr.Count.ToString("0")+"SR"+ps.Count.ToString("0")
                +"SF"+pt.Count.ToString("0");}bool pv(){if(pr.Count&gt;0)return true;return false;}void pw(){for(int i1
                =0;i1&lt;pr.Count;i1++){var w1=pr[i1]as IMyMotorSuspension;w1.SetValueFloat("Friction",0);}}
              </Program>
              <Storage />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="0" y="7" z="-3" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_RemoteControl">
              <SubtypeName>SmallBlockRemoteControl</SubtypeName>
              <EntityId>79668495395310320</EntityId>
              <Min x="0" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Remote Control</CustomName>
              <ShowOnHUD>true</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <UseSingleWeaponMode>false</UseSingleWeaponMode>
              <Toolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots />
              </Toolbar>
              <SelectedGunId xsi:nil="true" />
              <BuildToolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots />
              </BuildToolbar>
              <PreviousControlledEntityId xsi:nil="true" />
              <AutoPilotEnabled>false</AutoPilotEnabled>
              <FlightMode>2</FlightMode>
              <BindedCamera>0</BindedCamera>
              <CurrentWaypointIndex>-1</CurrentWaypointIndex>
              <Waypoints>
                <MyObjectBuilder_AutopilotWaypoint xsi:type="MyObjectBuilder_AutopilotWaypoint">
                  <Coords>
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Coords>
                  <Name>Name</Name>
                  <Actions />
                  <Indexes />
                </MyObjectBuilder_AutopilotWaypoint>
              </Waypoints>
              <Direction>0</Direction>
              <DockingModeEnabled>false</DockingModeEnabled>
              <CollisionAvoidance>false</CollisionAvoidance>
              <Coords />
              <Names />
              <WaypointThresholdDistance>0</WaypointThresholdDistance>
              <IsMainRemoteControl>false</IsMainRemoteControl>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCornerInv</SubtypeName>
              <Min x="-1" y="6" z="-2" />
              <BlockOrientation Forward="Backward" Up="Right" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Gyro">
              <SubtypeName>SmallBlockGyro</SubtypeName>
              <EntityId>136089858824790632</EntityId>
              <Min x="1" y="5" z="-3" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Gyroscope 4</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="4" z="-2" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_TextPanel">
              <SubtypeName>SmallTextPanel</SubtypeName>
              <EntityId>109458321878688310</EntityId>
              <Min x="-1" y="5" z="-3" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Wico Craft Save</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Description />
              <Title>Title</Title>
              <AccessFlag>READ_AND_WRITE_FACTION</AccessFlag>
              <ChangeInterval>0</ChangeInterval>
              <SelectedImages />
              <Font Type="MyObjectBuilder_FontDefinition" Subtype="Debug" />
              <FontSize>1</FontSize>
              <PublicDescription>
                [WCCM2]
                Mode=0
                current_state=0
                PassedArgument=
                AlertStates=0
                craft_operation=0
                ReceivedMessage=
                SaveID=128875857885719138

                [NAV]
                vTarget=0.00:0.00:0.00
                ValidNavTarget=False
                dStartShip=01/01/0001 00:00:00

              </PublicDescription>
              <PublicTitle>Public title</PublicTitle>
              <ShowText>NONE</ShowText>
              <FontColor>
                <PackedValue>4294967295</PackedValue>
                <X>255</X>
                <Y>255</Y>
                <Z>255</Z>
                <R>255</R>
                <G>255</G>
                <B>255</B>
                <A>255</A>
              </FontColor>
              <BackgroundColor>
                <PackedValue>4278190080</PackedValue>
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R>0</R>
                <G>0</G>
                <B>0</B>
                <A>255</A>
              </BackgroundColor>
              <CurrentShownTexture>0</CurrentShownTexture>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="4" z="-2" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="3" y="4" z="-2" />
              <BlockOrientation Forward="Left" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCornerInv</SubtypeName>
              <Min x="1" y="6" z="-2" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="0" y="7" z="-2" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="2" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-2" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="3" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-3" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="4" z="-3" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="4" z="-3" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="6" z="-3" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="6" z="-3" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="3" y="6" z="-3" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-3" y="6" z="-3" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="3" y="4" z="-3" />
              <BlockOrientation Forward="Left" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-3" y="4" z="-3" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="4" z="-3" />
              <BlockOrientation Forward="Left" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="4" z="-3" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="5" z="-4" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_ReflectorLight">
              <SubtypeName>SmallBlockFrontLight</SubtypeName>
              <EntityId>138488112240055304</EntityId>
              <Min x="-4" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Spotlight 4</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Radius>10</Radius>
              <ReflectorRadius>120</ReflectorRadius>
              <ColorRed>0.215686277</ColorRed>
              <ColorGreen>0.270588249</ColorGreen>
              <Falloff>0.3</Falloff>
              <Intensity>3</Intensity>
              <BlinkIntervalSeconds>0</BlinkIntervalSeconds>
              <BlinkLenght>10</BlinkLenght>
              <BlinkOffset>0</BlinkOffset>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="2" y="4" z="-4" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="-2" y="4" z="-4" />
              <BlockOrientation Forward="Up" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="1" y="4" z="-4" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="-1" y="4" z="-4" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="0" y="4" z="-4" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="5" z="-4" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="5" z="-4" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="2" y="6" z="-4" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="-2" y="6" z="-4" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CameraBlock">
              <SubtypeName>SmallCameraBlock</SubtypeName>
              <EntityId>106364110923821491</EntityId>
              <Min x="0" y="5" z="-5" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Camera</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <IsActive>false</IsActive>
              <Fov>1.04719758</Fov>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="0" y="6" z="-4" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="3" y="6" z="-4" />
              <BlockOrientation Forward="Left" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="-3" y="6" z="-4" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="3" y="4" z="-4" />
              <BlockOrientation Forward="Left" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="-3" y="4" z="-4" />
              <BlockOrientation Forward="Right" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="5" z="-4" />
              <BlockOrientation Forward="Left" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="5" z="-4" />
              <BlockOrientation Forward="Right" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="3" y="5" z="-4" />
              <BlockOrientation Forward="Left" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-3" y="5" z="-4" />
              <BlockOrientation Forward="Right" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="1" y="6" z="-4" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="-1" y="6" z="-4" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_ReflectorLight">
              <SubtypeName>SmallBlockFrontLight</SubtypeName>
              <EntityId>114781351882170161</EntityId>
              <Min x="4" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Spotlight 3</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Radius>10</Radius>
              <ReflectorRadius>120</ReflectorRadius>
              <ColorRed>0.215686277</ColorRed>
              <ColorGreen>0.270588249</ColorGreen>
              <Falloff>0.3</Falloff>
              <Intensity>3</Intensity>
              <BlinkIntervalSeconds>0</BlinkIntervalSeconds>
              <BlinkLenght>10</BlinkLenght>
              <BlinkOffset>0</BlinkOffset>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="0" y="7" z="4" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_ReflectorLight">
              <SubtypeName>SmallBlockFrontLight</SubtypeName>
              <EntityId>77080240684802394</EntityId>
              <Min x="-2" y="5" z="3" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Spotlight 6</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Radius>10</Radius>
              <ReflectorRadius>120</ReflectorRadius>
              <ColorRed>0.215686277</ColorRed>
              <ColorGreen>0.270588249</ColorGreen>
              <Falloff>0.3</Falloff>
              <Intensity>3</Intensity>
              <BlinkIntervalSeconds>0</BlinkIntervalSeconds>
              <BlinkLenght>10</BlinkLenght>
              <BlinkOffset>0</BlinkOffset>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>97332459708340550</EntityId>
              <Min x="1" y="3" z="-4" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Atmospheric Thrusters 4</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>79511213691190005</EntityId>
              <Min x="-1" y="3" z="-4" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Atmospheric Thrusters 5</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>140027311827757224</EntityId>
              <Min x="-3" y="4" z="5" />
              <BlockOrientation Forward="Left" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Atmospheric Thrusters 12</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>106642496384470588</EntityId>
              <Min x="1" y="4" z="5" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Atmospheric Thrusters 11</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_TextPanel">
              <SubtypeName>SmallTextPanel</SubtypeName>
              <EntityId>91826653086442976</EntityId>
              <Min x="0" y="5" z="10" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Text panel</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Description />
              <Title>Title</Title>
              <AccessFlag>READ_AND_WRITE_FACTION</AccessFlag>
              <ChangeInterval>0</ChangeInterval>
              <SelectedImages />
              <Font Type="MyObjectBuilder_FontDefinition" Subtype="Debug" />
              <FontSize>1</FontSize>
              <PublicDescription />
              <PublicTitle>Public title</PublicTitle>
              <ShowText>NONE</ShowText>
              <FontColor>
                <PackedValue>4294967295</PackedValue>
                <X>255</X>
                <Y>255</Y>
                <Z>255</Z>
                <R>255</R>
                <G>255</G>
                <B>255</B>
                <A>255</A>
              </FontColor>
              <BackgroundColor>
                <PackedValue>4278190080</PackedValue>
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R>0</R>
                <G>0</G>
                <B>0</B>
                <A>255</A>
              </BackgroundColor>
              <CurrentShownTexture>0</CurrentShownTexture>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>115271771721261125</EntityId>
              <Min x="2" y="4" z="4" />
              <BlockOrientation Forward="Up" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Atmospheric Thrusters 10</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="4" z="5" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="0" y="3" z="5" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="0" y="3" z="4" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="3" z="3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="3" z="2" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="3" z="1" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="3" z="0" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="3" z="-1" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="3" z="-2" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="0" y="3" z="-3" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="0" y="6" z="5" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Beacon">
              <SubtypeName>SmallBlockBeacon</SubtypeName>
              <EntityId>141841945258746886</EntityId>
              <Min x="0" y="6" z="-3" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Beacon</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <BroadcastRadius>100</BroadcastRadius>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_LargeGatlingTurret">
              <SubtypeName>SmallGatlingTurret</SubtypeName>
              <EntityId>115764101657053415</EntityId>
              <Min x="-2" y="7" z="-1" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyInventoryBase</TypeId>
                    <Component xsi:type="MyObjectBuilder_Inventory">
                      <Items>
                        <MyObjectBuilder_InventoryItem>
                          <Amount>20</Amount>
                          <PhysicalContent xsi:type="MyObjectBuilder_AmmoMagazine">
                            <SubtypeName>NATO_25x184mm</SubtypeName>
                            <ProjectilesCount>0</ProjectilesCount>
                          </PhysicalContent>
                          <ItemId>0</ItemId>
                        </MyObjectBuilder_InventoryItem>
                      </Items>
                      <nextItemId>1</nextItemId>
                      <Volume>0.084</Volume>
                      <Mass>9223372036854.775807</Mass>
                      <MaxItemCount>2147483647</MaxItemCount>
                      <Size xsi:nil="true" />
                      <InventoryFlags>CanReceive</InventoryFlags>
                      <RemoveEntityOnEmpty>false</RemoveEntityOnEmpty>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Gatling Turret 3</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <IsShooting>false</IsShooting>
              <IsShootingFromTerminal>false</IsShootingFromTerminal>
              <IsLargeTurret>true</IsLargeTurret>
              <MinFov>0.1</MinFov>
              <MaxFov>1.04719758</MaxFov>
              <Inventory>
                <Items>
                  <MyObjectBuilder_InventoryItem>
                    <Amount>20</Amount>
                    <PhysicalContent xsi:type="MyObjectBuilder_AmmoMagazine">
                      <SubtypeName>NATO_25x184mm</SubtypeName>
                      <ProjectilesCount>0</ProjectilesCount>
                    </PhysicalContent>
                    <ItemId>0</ItemId>
                  </MyObjectBuilder_InventoryItem>
                </Items>
                <nextItemId>1</nextItemId>
                <Volume>0.084</Volume>
                <Mass>9223372036854.775807</Mass>
                <MaxItemCount>2147483647</MaxItemCount>
                <Size xsi:nil="true" />
                <InventoryFlags>CanReceive</InventoryFlags>
                <RemoveEntityOnEmpty>false</RemoveEntityOnEmpty>
              </Inventory>
              <RemainingAmmo>0</RemainingAmmo>
              <Target>0</Target>
              <IsPotentialTarget>true</IsPotentialTarget>
              <PreviousControlledEntityId xsi:nil="true" />
              <Rotation>0</Rotation>
              <Elevation>0</Elevation>
              <GunBase>
                <CurrentAmmoMagazineName>NATO_25x184mm</CurrentAmmoMagazineName>
                <RemainingAmmosList />
                <LastShootTime>0</LastShootTime>
              </GunBase>
              <EnableIdleRotation>true</EnableIdleRotation>
              <PreviousIdleRotationState>true</PreviousIdleRotationState>
              <TargetCharacters>true</TargetCharacters>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="3" y="7" z="1" />
              <BlockOrientation Forward="Down" Up="Right" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="-3" y="7" z="1" />
              <BlockOrientation Forward="Down" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_ReflectorLight">
              <SubtypeName>SmallBlockFrontLight</SubtypeName>
              <EntityId>106497986006080959</EntityId>
              <Min x="2" y="5" z="3" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Spotlight 5</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Radius>10</Radius>
              <ReflectorRadius>120</ReflectorRadius>
              <ColorRed>0.215686277</ColorRed>
              <ColorGreen>0.270588249</ColorGreen>
              <Falloff>0.3</Falloff>
              <Intensity>3</Intensity>
              <BlinkIntervalSeconds>0</BlinkIntervalSeconds>
              <BlinkLenght>10</BlinkLenght>
              <BlinkOffset>0</BlinkOffset>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>84762892101939810</EntityId>
              <Min x="-2" y="4" z="4" />
              <BlockOrientation Forward="Up" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Atmospheric Thrusters 9</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
          </CubeBlocks>
          <XMirroxPlane x="0" y="5" z="1" />
          <ConveyorLines>
            <MyObjectBuilder_ConveyorLine>
              <StartPosition x="0" y="5" z="2" />
              <StartDirection>Forward</StartDirection>
              <EndPosition x="0" y="5" z="1" />
              <EndDirection>Backward</EndDirection>
              <Sections />
              <ConveyorLineType>LARGE_LINE</ConveyorLineType>
            </MyObjectBuilder_ConveyorLine>
          </ConveyorLines>
          <BlockGroups>
            <MyObjectBuilder_BlockGroup>
              <Name>Thrust Forward</Name>
              <Blocks>
                <Vector3I>
                  <X>-3</X>
                  <Y>5</Y>
                  <Z>7</Z>
                </Vector3I>
                <Vector3I>
                  <X>3</X>
                  <Y>5</Y>
                  <Z>7</Z>
                </Vector3I>
              </Blocks>
            </MyObjectBuilder_BlockGroup>
          </BlockGroups>
          <DisplayName>Envoy</DisplayName>
          <DestructibleBlocks>true</DestructibleBlocks>
          <CreatePhysics>false</CreatePhysics>
          <EnableSmallToLargeConnections>false</EnableSmallToLargeConnections>
          <IsRespawnGrid>false</IsRespawnGrid>
          <LocalCoordSys>0</LocalCoordSys>
          <TargetingTargets />
        </CubeGrid>
      </CubeGrids>
    </Prefab>
  </Prefabs>
</Definitions>