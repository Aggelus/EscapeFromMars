<?xml version="1.0"?>
<Definitions xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <Prefabs>
    <Prefab xsi:type="MyObjectBuilder_PrefabDefinition">
      <Id Type="MyObjectBuilder_PrefabDefinition" Subtype="Envoy" />
      <CubeGrids>
        <CubeGrid>
          <SubtypeName />
          <EntityId>101802493018777608</EntityId>
          <PersistentFlags>CastShadows InScene</PersistentFlags>
          <PositionAndOrientation>
            <Position x="1071737.8090153025" y="155702.90353362536" z="1670692.1547722337" />
            <Forward x="0.335206658" y="-0.914947" z="0.224740088" />
            <Up x="0.6575048" y="0.398027837" z="0.639735162" />
            <Orientation>
              <X>0.194894642</X>
              <Y>0.757882655</Y>
              <Z>0.51283747</Z>
              <W>-0.353026479</W>
            </Orientation>
          </PositionAndOrientation>
          <GridSizeEnum>Small</GridSizeEnum>
          <CubeBlocks>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CargoContainer">
              <SubtypeName>SmallBlockMediumContainer</SubtypeName>
              <EntityId>110167472675400672</EntityId>
              <Min x="-1" y="4" z="-1" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyInventoryBase</TypeId>
                    <Component xsi:type="MyObjectBuilder_Inventory">
                      <Items />
                      <nextItemId>0</nextItemId>
                      <Volume>3.375</Volume>
                      <Mass>9223372036854.775807</Mass>
                      <MaxItemCount>2147483647</MaxItemCount>
                      <Size xsi:nil="true" />
                      <InventoryFlags>CanReceive CanSend</InventoryFlags>
                      <RemoveEntityOnEmpty>false</RemoveEntityOnEmpty>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Medium Cargo Container 2</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="2" y="4" z="-2" />
              <BlockOrientation Forward="Up" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="-3" y="4" z="-2" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CargoContainer">
              <SubtypeName>SmallBlockMediumContainer</SubtypeName>
              <EntityId>131930194237864400</EntityId>
              <Min x="-1" y="4" z="2" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyInventoryBase</TypeId>
                    <Component xsi:type="MyObjectBuilder_Inventory">
                      <Items />
                      <nextItemId>0</nextItemId>
                      <Volume>3.375</Volume>
                      <Mass>9223372036854.775807</Mass>
                      <MaxItemCount>2147483647</MaxItemCount>
                      <Size xsi:nil="true" />
                      <InventoryFlags>CanReceive CanSend</InventoryFlags>
                      <RemoveEntityOnEmpty>false</RemoveEntityOnEmpty>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Medium Cargo Container 2</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <ContainerType>CargoLargeTrade1A</ContainerType>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="-2" y="6" z="-2" />
              <BlockOrientation Forward="Down" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_MyProgrammableBlock">
              <SubtypeName>SmallProgrammableBlock</SubtypeName>
              <EntityId>112466411508705149</EntityId>
              <Min x="-1" y="5" z="-2" />
              <BlockOrientation Forward="Right" Up="Backward" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
              <BuiltBy>144115188075855897</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyModStorageComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_ModStorageComponent">
                      <Storage>
                        <dictionary>
                          <item>
                            <Key>74de02b3-27f9-4960-b1c4-27351f2b06d1</Key>
                            <Value>
                              [WORLD]
                              MaxWorldMps=100

                              [GRIDS]
                              NoFollow=NOFOLLOW
                              BlockIgnore=!WCC
                              OrientationBlockContains=[NAV]
                              OrientationBlockNamed=Craft Remote Control
                              GyroIgnore=!NAV
                              LIMIT_GYROS=3
                              LEAVE_GYROS=-1
                              CTRL_COEFF=0.9

                              [LOGGING]
                              TextPanelReport=Craft Report
                              StatusName=Wico Craft Status
                              LongStatus=Wico Craft Log
                              RangeReport=[RANGE]
                              SledReport=[SMREPORT]
                              GPSTag=[GPS]

                              [CONNECTORS]
                              BaseConnector=[BASE]
                              DockConnector=[DOCK]
                              GearUse=[DOCK]

                              [CAMERAS]
                              CameraViewOnly=[VIEW]

                              [POWER]
                              batterypcthigh=80
                              batterypctlow=20

                              [CARGO]
                              cargopctmin=5

                              [WICO CRAFT]
                              EchoOn=True

                              [WICOCRAFT]
                              EchoOn=False
                              DebugUpdate=False
                              SubModules=True
                              SubmoduleTriggerWait=5

                              [WICOTIMERS]
                              FastTimer=[WCCT]
                              SubModuleTimer=[WCCS]
                              MainTimer=[WCCM]

                              [COMMUNICATIONS]
                              CommunicationsStealth=False

                            </Value>
                          </item>
                        </dictionary>
                      </Storage>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>PB WIco Craft Main</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Program>
                /*
                * Wico craft controller Master Control Script
                *
                * Control Script for Rovers and Drones and Oribtal craft
                *
                * Uncompressed source for this script here: https://github.com/Wicorel/SpaceEngineers/tree/master/MDK%20Craft%20Control
                *
                *
                * Handles:
                * Master timer for sub-modules
                * Calculates ship speed and vectors (obsolete)
                * Calculates simspeed (obsolete)
                * Configure craft_operation settings
                * making sure antenna doesn't get turned off (bug in SE turn off antenna when trying to remotely connect to grid)
                *
                * Calculates cargo and power percentages and cargo multiplier and hydro fill and oxy tank fill
                *
                * Detects grid changes and initiates re-init
                *
                * *
                * MODE_IDLE
                * MODE_ATTENTION
                *
                * Commands:
                *
                * setsimspeed &lt;value&gt;: sets the current simspeed so the calculations can be accurate. (obsolete)
                * init: re-init all blocks
                * idle : force MODE_IDLE
                * coast: turns on/off backward thrusters
                * masterreset: attempts to do a master reset of all saved information
                * setvaluef &lt;blockname&gt;:&lt;property&gt;:&lt;value&gt;  -&gt; sets specified block's property to specified value
                * Example:
                *  setvaluef Advanced Rotor:UpperLimit:-24
                * genpatrol [distance [up]]
                * Examples:
                * genpatrol
                * genpatrol 300 150
                * genpatrol 500
                *
                * Need:

                * Want:
                *
                * menu management for commands (including sub-modules)
                *
                * minimize serialized data and make sub-modules pass their own seperately, OR support extra data in state
                *
                * common function for 'handle this' combining 'me' grid and an exclusion name check
                *
                * multi-script handling for modes
                *
                * * advanced trigger: only when module handles that mode... (so need mode-&gt;module dictionary)
                * override base modes?
                *
                *
                *
                * WANT:
                * setvalueb
                * Actions
                * Trigger timers on 'events'.
                * set antenna name to match mode?
                * *
                * 2.0 Removed many built-in functions to make script room. These functions were duplicated in sub-modules anyway.
                * 2.0.1
                * 0.2 Remove items from serialize that main control no longer calculates (cargo, battery, etc).
                * if simspeed&gt;1.01, assume 1.0 and recalculate.
                * 0.3 re-org code sections
                * Pass arguments to sub-modules
                * 0.4 (re)integrate power and cargo
                * 0.4a process multiple arguments on a command line
                * 0.4b check mass change and request reinit including sub-modules.
                *
                * 2.1 Code Reorg
                * Cache all blocks and grids.  Support for multi-grid constructions.
                * !Needs handling for grids connected via connectors..
                *
                * .1a Don't force re-init on working projector.
                * .1b Add 'brake' command
                * Add braking for sleds (added wheelinit)
                *
                * 2.2 PB changes in 1.172
                *
                * .2a Added modes. Default PB name
                *
                * 2.3 Start to add Power information
                *
                * .3a Add drills and ejectors to reset motion. Add welders, drills, connectors and grinders to cargo check.
                * don't set PB name because it erases settings.. :(
                *
                * .3b getblocks fixes when called before gridsinit
                *
                * 3.0 remove older items from serialize that are no longer needed
                * removed NAV support
                * fixed battery maxoutput values
                *
                * 3.0a support no remote control blocks. Check for Cryo when getting default controller.
                * 3.0b sBanner
                * 3.0c caching optimizations
                * 3.0d fix connectorsanyconnectors not using localdock
                * 3.0e Add Master Reset command
                * 3.0f
                * check for grid changes and re-init
                * rotor NOFOLLOW
                * ignore projectors with !WCC in name or customdata
                * ignore 'cutter' thrusters
                *
                * 3.0g Fix problem with allBlockCount being loaded after it has changed
                *
                * 3.0H
                * fix problems with docking/undocking and perm re-init
                *
                * 05/13: fix GetBlocksContains&lt;T&gt;()
                *
                * 3.0I MDK Version 08/20/2017   MDK: https://github.com/malware-dev/MDK-SE/
                * Uncompressed source for this script here: https://github.com/Wicorel/SpaceEngineers/tree/master/MDK%20Craft%20Control
                *
                * 3.0J Add moduleDoPreModes() to Main()
                * Move pre-mode to moduleDoPreModes()
                * add clearing of gpsPanel to moduleDoPreModes()
                *
                * 3.0K more init states if larger number of blocks in grid system.
                *
                * 3.0K2  search order for text panels
                *
                * 3.1 Verison for SE 1.185 PB Major changes
                *
                * 3.1A init cycle optimizations
                *
                * 3.1B Handle no controller (stations, etc)
                * 12092017
                *
                * 3.1C 12132017
                * don't count ejectors in cargo%
                * fix bug in DoTriggerMain() causing updates to stop
                *
                * 3.1D Section processing for save information (text panels)
                * fix bug in serialize wrting z,y z, instead of x,y,z (oops)
                *
                * 3.2 INI WCCM 01062018
                *
                * 3.2A
                * FilledRatio Change
                *
                * 3.2B Lots of INI processing
                *
                * 3.3 Handle multiple output panels.
                * Only write to panels at end
                *
                * 3.3A Redo Serlialize.
                * Module Serlialize
                *
                * 3.4
                * add namecameras
                *
                * 3.4a
                * init optimizations for text panels
                *
                * 3.4B turn off auto-pirate mode.
                *
                * 3.4C options for timer names
                * options for debugupdate
                * options for submodule trigger rate
                *
                * 3.4D Mar 29 2018 Current Source
                * removed ModeScans/MODE_DOSCAN
                *
                * 3.4E Mar 22, 2018
                * Error messages on missing blocks on startup
                * Re-try startup if there are errors.
                *
                * 3.4F
                * handle stations having no propulsion methods
                * increase default sub-module trigger to 5seconds
                * May 27, 2018
                *
                * 3.4G June 08,2018
                * Add setmode and setstate commands
                * Clear all panels on masterreset command
                *
                * 3.4H June 19,2018
                * Add genpatrol command to generate a set of patrol waypoints around this ship.
                * Defaults for distance are 500 and up  is 500
                *
                * 3.4I
                * July 23 SE 1.187 MDK 1.1.16
                *
                * 3.4J Sep 08 2018
                * MDK Update
                * Performance Pass
                *
                *
                * genpatrol [distance [up]]
                * genpatrol
                * genpatrol 300 150
                * genpatrol 500
                *
                * 3.4J
                *
                * 3.5 SE V1.189
                *
                */
                string ʣ="Wico Craft";string ʢ="Master";string ʡ="3.5";const string ʠ="0.00";double ʟ=2;double ʞ=-1;double ʤ=5;double ʝ=
                -1;void ʛ(){ɡ("clear",ɮ);ɡ("clear",ɬ);if(N){Echo("Startup Error Detected"+l);ɡ("Startup Error Detected"+l,ɮ);}else if(l!=
                "")Echo(l);string Ç="";if(ə&gt;0){Ç+="Ship\n";}else if(ə&lt;0){}else{Ç+="Station\n";}if(Ŏ()){if(Ō())Ç+="Connected";else Ç+=
                "Not Connected";if(ō())Ç+="\nLocked";else Ç+=" : Not Locked";}if(Ç!=""){Echo(Ç);Ɏ(Ç);}Ç="";if(M)Echo("FAST!");if(ʞ&gt;ʟ){ʞ=0;ͻ();}else{if(
                ʞ&lt;0){ʞ=ʟ+5;}ʞ+=Runtime.TimeSinceLastRun.TotalSeconds;}if(Ͱ&gt;=0)Echo("Cargo="+Ͱ.ToString()+"%");if(ʝ&gt;ʤ){ʝ=0;ʌ(0,false);}
                else{if(ʝ&lt;0){ʝ=ʤ+5;}ʝ+=Runtime.TimeSinceLastRun.TotalSeconds;}if(ʩ.Count&gt;0&amp;&amp;ʫ&gt;0){Ç+=" : "+(ʋ()/ʫ*100).ToString("0.00")+"%";Ç
                +="\n Storage="+ʪ.ToString()+"%";}if(Ç!="")Echo(Ç);Ç="";float ʚ=0;Ь(out ʚ);if(Я.Count&gt;0){Ç="Reactors: #"+Я.Count.ToString(
                );Ç+=" - "+а.ToString("0.00")+"MW\n";float ʙ=(float)(ʚ/Ɵ*100);Ç+=" Curr Output="+ʚ.ToString("0.00")+"MW"+" : "+ʙ.ToString
                ("0.00")+"%";}if(Ç!="")Echo(Ç);Ç="";ɀ();if(Ɂ&gt;=0){Echo("O:"+Ɂ.ToString("000.0%"));}if(ɂ&gt;=0){Echo("H:"+ɂ.ToString("000.0%")
                );}if(ȵ.Count&gt;0){Echo(ȵ.Count+" Gas Gens");}if(E&gt;=0){Echo("Grav="+E.ToString(ʠ));Ɏ("Planet Gravity "+E.ToString(ʠ)+" g");
                Ɏ(Ɍ((int)(E/1.1*100)));}else Ɏ("ERROR: No Remote Control found!");ɡ("clear",ɬ);}void ʘ(){j();}void ʗ(bool ʜ=false){ħ(Χ);ǵ
                ();ч(й);ч(и);if(ƺ is IMyRemoteControl)((IMyRemoteControl)ƺ).SetAutoPilotEnabled(false);if(ƺ is IMyShipController)((
                IMyShipController)ƺ).DampenersOverride=true;if(!ʜ)X();Ɯ(0);}void ʖ(){ɹ();ȷ();ʗ();Ϋ=0;Ϊ="";ά="init";ί.ǝ("");ϕ();M=true;}void ʥ(){έ=ʳ;{int
                ʯ=0;if(Me.CustomName.ToLower().Contains("nad"))έ|=ˎ;if(Me.CustomName.ToLower().Contains("rotor"))έ|=ʷ;else if(Me.
                CustomName.ToLower().Contains("sled"))έ|=ʲ;if(Ύ&gt;0){ʯ++;}if(Ό&gt;0){ʯ++;}if(Ί&gt;0){ʯ++;}if(й!=null&amp;&amp;й.Count&gt;0&amp;&amp;и.Count&gt;0)έ|=ʷ;if(Ə!=null
                &amp;&amp;Ə.Count&gt;0&amp;&amp;ʯ&gt;0)έ|=ʲ;if(ǌ!=null&amp;&amp;ǌ.Count&gt;0&amp;&amp;!Me.CustomName.ToLower().Contains("nogyros"))έ|=ʾ;if(ʯ&gt;1||Me.CustomName.
                ToLower().Contains("orbital"))έ|=ˑ;if((Ɛ!=null&amp;&amp;Ɛ.Count&gt;0&amp;&amp;!((έ&amp;ʲ)&gt;0))||Me.CustomName.ToLower().Contains("wheel"))έ|=ʱ;if(Me.
                CustomName.ToLower().Contains("rocket"))έ|=ː;if(Me.CustomName.ToLower().Contains("pet"))έ|=ˏ;if(Me.CustomName.ToLower().Contains(
                "noautogyro"))έ|=ˍ;if(Me.CustomName.ToLower().Contains("nopower"))έ|=ˌ;if(Me.CustomName.ToLower().Contains("notank"))έ|=ˋ;}}void ʮ()
                {string Ç="";Ç+=F.ToString(ʠ)+" m/s";Ç+=" ("+(F*3.6).ToString(ʠ)+"km/h)";Ɏ(Ç);}void ʭ(ȉ Í){}void ʬ(ȉ Í){}double ʫ=-1;int
                ʪ=-1;List&lt;IMyTerminalBlock&gt;ʩ=new List&lt;IMyTerminalBlock&gt;();bool ʨ(IMyTerminalBlock æ){if(æ is IMyBatteryBlock){
                IMyBatteryBlock ʕ=æ as IMyBatteryBlock;return(ʕ.ChargeMode==ChargeMode.Recharge);}else return false;}bool ʧ(IMyTerminalBlock æ){if(æ is
                IMyBatteryBlock){IMyBatteryBlock ʕ=æ as IMyBatteryBlock;return(ʕ.ChargeMode==ChargeMode.Discharge);}else return false;}bool ʦ(
                IMyTerminalBlock æ){if(æ is IMyBatteryBlock){IMyBatteryBlock ʕ=æ as IMyBatteryBlock;return ʕ.IsCharging;}else return false;}void ʓ(){ʩ.
                Clear();ʪ=-1;ʫ=-1;GridTerminalSystem.GetBlocksOfType&lt;IMyBatteryBlock&gt;(ʩ,ç);if(ʩ.Count&gt;0)ʫ=0;foreach(var ʊ in ʩ){
                IMyBatteryBlock ʉ=ʊ as IMyBatteryBlock;ʫ+=ʉ.MaxOutput;}}double ʋ(){double Ç=0;foreach(var ʊ in ʩ){IMyBatteryBlock ʉ=ʊ as
                IMyBatteryBlock;Ç+=ʉ.CurrentOutput;}return Ç;}bool ʌ(int ʈ,bool ʆ=true,bool ʅ=false){float ʄ=0;float ʃ=0;bool ʂ=false;float ʁ;if(ʩ.
                Count&lt;1)ʓ();if(ʩ.Count&lt;1)return false;ʪ=0;for(int ʇ=0;ʇ&lt;ʩ.Count;ʇ++){float ʀ=0;float ʍ=0;int ʔ=100;IMyBatteryBlock W;W=ʩ[ʇ]as
                IMyBatteryBlock;ʁ=W.MaxStoredPower;ʍ+=ʁ;ʄ+=ʁ;ʁ=W.CurrentStoredPower;ʀ+=ʁ;ʃ+=ʁ;if(ʍ&gt;0){ʁ=((ʀ*100)/ʍ);ʁ=(float)Math.Round(ʁ,0);ʔ=(int)ʁ;}
                string ý;ý="";if(ʨ(ʩ[ʇ]))ý+="R";else if(ʧ(ʩ[ʇ]))ý+="D";else ý+="a";float ʒ;ʒ=W.CurrentInput;if(ʒ&gt;0)ý+="+";else ý+=" ";ʒ=W.
                CurrentOutput;if(ʒ&gt;0)ý+="-";else ý+=" ";ý+=ʔ+"%";ý+=":"+ʩ[ʇ].CustomName;if(ʆ)Echo(ý);if(ʨ(ʩ[ʇ])&amp;&amp;ʈ&gt;0){if(ʔ&lt;ʈ)ʂ=true;else if(ʔ&gt;99){W.
                ChargeMode=ChargeMode.Recharge;}}if(!(W.ChargeMode==ChargeMode.Recharge)&amp;&amp;ʔ&lt;ʈ&amp;&amp;!ʂ){W.ChargeMode=ChargeMode.Recharge;ʂ=true;}}if(ʄ&gt;
                0){ʁ=((ʃ*100)/ʄ);ʁ=(float)Math.Round(ʁ,0);ʪ=(int)ʁ;}else ʪ=-1;return ʂ;}void ʑ(){for(int G=0;G&lt;ʩ.Count;G++){
                IMyBatteryBlock W;W=ʩ[G]as IMyBatteryBlock;W.ChargeMode=ChargeMode.Auto;}}void ʐ(bool ʆ=false,bool ʏ=true){if(ʆ)Echo(ʩ.Count+
                " Batteries");string ý;for(int G=0;G&lt;ʩ.Count;G++){IMyBatteryBlock W;W=ʩ[G]as IMyBatteryBlock;if(ʏ){W.ChargeMode=ChargeMode.Discharge
                ;}else W.ChargeMode=ChargeMode.Recharge;ý=W.CustomName+": ";if(W.ChargeMode==ChargeMode.Recharge){ý+="RECHARGE/";}else ý
                +="NOTRECHARGE/";if(W.ChargeMode==ChargeMode.Discharge){ý+="DISCHARGE";}else{ý+="NOTDISCHARGE";}if(ʆ)Echo(ý);}}void ʎ(List
                &lt;IMyTerminalBlock&gt;Ė,bool Â=true){foreach(var W in Ė){IMyFunctionalBlock ʰ=W as IMyFunctionalBlock;if(ʰ==null)continue;ʰ.
                Enabled=Â;}}void ʽ(List&lt;IMyTerminalBlock&gt;Ė){foreach(var W in Ė){IMyFunctionalBlock ʰ=W as IMyFunctionalBlock;if(ʰ==null)
                continue;ʰ.Enabled=!ʰ.Enabled;}}int ͱ=5;int Ͱ=-1;double ˮ=-1;string ˬ="CARGO";void Ͳ(ȉ Í){Í.Ż(ˬ,"cargopctmin",ref ͱ,true);}List&lt;
                IMyTerminalBlock&gt;ˤ=null;bool ˣ=false;double ˢ=0.0;void ˡ(){var Ė=new List&lt;IMyTerminalBlock&gt;();if(ˤ==null)ˤ=new List&lt;IMyTerminalBlock&gt;();
                else ˤ.Clear();Ǐ&lt;IMyCargoContainer&gt;(ref Ė);ˤ.AddRange(Ė);Ͱ=-1;ˮ=-1;}void ˠ(){var Ė=new List&lt;IMyTerminalBlock&gt;();Ǐ&lt;
                IMyShipConnector&gt;(ref Ė);foreach(var ų in Ė){if(ų.CustomName.Contains("Ejector")||ų.CustomData.Contains("Ejector"))continue;else ˤ.Add(ų
                );}}void ͳ(){var Ė=new List&lt;IMyTerminalBlock&gt;();Ǐ&lt;IMyShipDrill&gt;(ref Ė);ˤ.AddRange(Ė);}void Ά(){var Ė=new List&lt;
                IMyTerminalBlock&gt;();Ǐ&lt;IMyShipWelder&gt;(ref Ė);ˤ.AddRange(Ė);}void Ϳ(){var Ė=new List&lt;IMyTerminalBlock&gt;();Ǐ&lt;IMyShipGrinder&gt;(ref Ė);ˤ.
                AddRange(Ė);}bool ͽ=true;void ͼ(){var Ė=new List&lt;IMyTerminalBlock&gt;();if(ˤ==null)ˤ=new List&lt;IMyTerminalBlock&gt;();else ˤ.Clear();if
                (!ͽ)GridTerminalSystem.GetBlocksOfType&lt;IMyCargoContainer&gt;(Ė,ç);else Ǐ&lt;IMyCargoContainer&gt;(ref Ė);ˤ.AddRange(Ė);Ė.Clear();
                if(!ͽ)GridTerminalSystem.GetBlocksOfType&lt;IMyShipConnector&gt;(Ė,ç);else Ǐ&lt;IMyShipConnector&gt;(ref Ė);foreach(var ų in Ė){if(ų.
                CustomName.Contains("Ejector")||ų.CustomData.Contains("Ejector"))continue;else if(ų.CustomName.Contains("Sorter")||ų.CustomData.
                Contains("Sorter"))continue;else ˤ.Add(ų);}Ė.Clear();if(!ͽ)GridTerminalSystem.GetBlocksOfType&lt;IMyShipDrill&gt;(Ė,ç);else Ǐ&lt;
                IMyShipDrill&gt;(ref Ė);ˤ.AddRange(Ė);Ė.Clear();if(!ͽ)GridTerminalSystem.GetBlocksOfType&lt;IMyShipWelder&gt;(Ė,ç);else Ǐ&lt;IMyShipWelder&gt;(ref
                Ė);ˤ.AddRange(Ė);Ė.Clear();if(!ͽ)GridTerminalSystem.GetBlocksOfType&lt;IMyShipGrinder&gt;(Ė,ç);else Ǐ&lt;IMyShipGrinder&gt;(ref Ė);ˤ.
                AddRange(Ė);Ͱ=-1;ˮ=-1;}void ͻ(){if(ˤ==null)ͼ();if(ˤ.Count&lt;1){Ͱ=-1;ˮ=-1;return;}ˢ=0.0;double ͺ=0.0;double ͷ=0;bool Ͷ=true;bool ʹ=
                false;for(int G=0;G&lt;ˤ.Count;G++){double ʍ=-1;var ʺ=ˤ[G].InventoryCount;for(var ʹ=0;ʹ&lt;ʺ;ʹ++){var ʵ=ˤ[G].GetInventory(ʹ);if(ʵ!=
                null){ˢ+=(double)ʵ.CurrentVolume;if((double)ʵ.MaxVolume&gt;9223372036854){ˣ=true;}else{ˣ=false;}if(!ˣ){ʍ=(double)ʵ.MaxVolume;
                double ʼ=ʸ(ˤ[G]);if(ʼ&gt;0)ˮ=ʍ/ʼ;}else{ʍ=ʸ(ˤ[G])*10;ˮ=9999;}if((double)ʵ.CurrentVolume&lt;ʍ){if(!(ˤ[G]is IMyShipDrill)){Ͷ=false;}}
                else{if(ˤ[G]is IMyShipDrill){ʹ=true;}}}ͺ+=ʍ;}}if(ͺ&gt;0){ͷ=(ˢ/ͺ)*100;}else{ͷ=100;}Ͱ=(int)ͷ;if(Ͷ&amp;&amp;ʹ)Ͱ=101;}double ʻ(
                IMyTerminalBlock ʶ){double ʍ=-1;var ʺ=ʶ.InventoryCount;for(var ʹ=0;ʹ&lt;ʺ;ʹ++){var ʵ=ʶ.GetInventory(ʹ);if(ʵ!=null){ˢ+=(double)ʵ.
                CurrentVolume;if((double)ʵ.MaxVolume&gt;9223372036854){ˣ=true;}else{ˣ=false;}if(!ˣ){ʍ=(double)ʵ.MaxVolume;double ʼ=ʸ(ʶ);if(ʼ&gt;0)ˮ=ʍ/ʼ;}
                else{ʍ=ʸ(ʶ)*10;ˮ=9999;}}}return ʍ;}double ʸ(IMyTerminalBlock ʶ){var ʵ=ʶ.GetInventory(0);string ʴ=ʶ.BlockDefinition.SubtypeId
                ;double ʍ=(double)ʵ.MaxVolume;if(ʍ&lt;999999999)return ʍ;if(ʶ is IMyCargoContainer){if(ʴ.Contains("LargeBlockLargeContainer"
                ))ʍ=421.875008;else if(ʴ.Contains("LargeBlockSmallContainer"))ʍ=15.625;else if(ʴ.Contains("SmallBlockLargeContainer"))ʍ=
                15.625;else if(ʴ.Contains("SmallBlockMediumContainer"))ʍ=3.375;else if(ʴ.Contains("SmallBlockSmallContainer"))ʍ=0.125;else if(
                ʴ.Contains("Azimuth_LargeContainer"))ʍ=7780.8;else if(ʴ.Contains("Azimuth_MediumLargeContainer"))ʍ=1945.2;else if(ʴ.
                Contains("Azimuth_MediumContainer"))ʍ=1878.6;else if(ʴ.Contains("Azimuth_SmallContainer"))ʍ=10.125;}else if(ʴ.Contains(
                "SmallBlockDrill"))ʍ=3.375;else if(ʴ.Contains("LargeBlockDrill"))ʍ=23.4375;else if(ʴ.Contains("ConnectorMedium"))ʍ=1.152;else if(ʴ.
                Contains("ConnectorSmall"))ʍ=0.064;else if(ʴ.Contains("Connector"))ʍ=8.000;else if(ʴ.Contains("LargeShipWelder"))ʍ=15.625;else
                if(ʴ.Contains("LargeShipGrinder"))ʍ=15.625;else if(ʴ.Contains("SmallShipWelder"))ʍ=3.375;else if(ʴ.Contains(
                "SmallShipGrinder"))ʍ=3.375;else{Echo("Unknown cargo for default Capacity:"+ʶ.DefinitionDisplayNameText+":"+ʶ.BlockDefinition.SubtypeId);ʍ
                =12;}return ʍ;}const int ʳ=0;const int ʲ=2;const int ʷ=4;const int ʱ=8;const int ʾ=16;const int ˑ=32;const int ː=64;const
                int ˏ=128;const int ˎ=256;const int ˍ=512;const int ˌ=1024;const int ˋ=2048;const int ˊ=0xfff;string ˉ(){string Ɉ="FLAGS:";
                if((έ&amp;ʲ)&gt;0)Ɉ+="SLED ";if((έ&amp;ˑ)&gt;0)Ɉ+="ORBITAL ";if((έ&amp;ː)&gt;0)Ɉ+="ROCKET ";if((έ&amp;ʷ)&gt;0)Ɉ+="ROTOR ";if((έ&amp;ʱ)&gt;0)Ɉ+="WHEEL ";if((έ
                &amp;ˏ)&gt;0)Ɉ+="PET ";if((έ&amp;ˎ)&gt;0)Ɉ+="NAD ";if((έ&amp;ˍ)&gt;0)Ɉ+="NO Gyro ";if((έ&amp;ˋ)&gt;0)Ɉ+="No Tank ";if((έ&amp;ˌ)&gt;0)Ɉ+="No Power ";return Ɉ
                ;}long ˈ=0;MyIni ˇ=new MyIni();string ˆ="";string ˁ="";void ˀ(){if(ΰ==null){ˁ=Storage;}else{ˁ=ΰ.GetPublicText();}if(ί==
                null)return;if(ˁ==ˆ){Echo("Load Skip");return;}ˆ=ˁ;ˁ=ˁ.Trim();MyIniParseResult ʿ;if(!ˇ.TryParse(ˁ,out ʿ)){Echo(
                "MyIni:Error parsing INI:"+ʿ.ToString());string[]Ǜ=ˁ.Split('\n');for(int ǟ=0;ǟ&lt;Ǜ.Count();ǟ++){Echo(ǟ+1+":"+Ǜ[ǟ]);}}ί.ǝ(ˁ);ί.Ż(β,"SaveID",ref ˈ);if
                (ɿ()){ί.ǝ("");}ʭ(ί);ί.Ż(β,"Mode",ref Έ,true);ί.Ż(β,"current_state",ref δ,true);ί.Ż(β,"PassedArgument",ref ά,true);ί.Ż(β,
                "AlertStates",ref Ϋ,true);ί.Ż(β,"craft_operation",ref έ,true);ί.Ż(β,"PassedArgument",ref ά);ί.Ż(β,"ReceivedMessage",ref Ϊ);}bool ɿ(){
                if(ΰ==null||Ä)return false;if(ˈ&lt;=0||ˈ==(long)ΰ.EntityId)return false;else return true;}bool Ƞ(string ȹ){ȹ=ȹ.Trim().ToLower
                ();return(ȹ=="True"||ȹ=="true");}void ȸ(){Echo("mode="+Έ.ToString());if(Έ==Љ)ȶ();else if(Έ==Ѕ){ɡ("clear",ɮ);ɡ(ʢ+
                ":ATTENTION!",ɮ);ɡ(ʢ+": current_state="+δ.ToString(),ɮ);ɡ("\nCraft Needs attention",ɮ);}}void ȷ(){ɡ(DateTime.Now.ToString()+
                " ACTION: Reset To Idle",ɰ,true);ʗ();Ϝ(Љ);if(ə&gt;0&amp;&amp;Ō()&amp;&amp;Έ!=Ѓ&amp;&amp;Έ!=ϻ&amp;&amp;!((έ&amp;ˑ)&gt;0)&amp;&amp;!((έ&amp;ˎ)&gt;0))Ϝ(Ͽ);}void ȶ(){ɡ("clear",ɮ);ɡ(ʣ+":"+ʢ+
                ":Manual Control (idle)",ɮ);if(ə&gt;0&amp;&amp;Ō()&amp;&amp;Έ!=Ѓ&amp;&amp;Έ!=ϻ&amp;&amp;!((έ&amp;ˑ)&gt;0)&amp;&amp;!((έ&amp;ˎ)&gt;0))Ϝ(Ͽ);}List&lt;IMyTerminalBlock&gt;ȵ=new List&lt;IMyTerminalBlock&gt;();string ȴ(
                ){ȵ.Clear();ȵ=Ǐ&lt;IMyGasGenerator&gt;();return"GG"+ȵ.Count.ToString("00");}void Ⱥ(bool Â=true){ʎ(ȵ,Â);}bool Ȳ(){return true;}
                void ȱ(){if(ȼ()&gt;99){ʎ(ȵ,false);}else{ʎ(ȵ,true);}}List&lt;IMyTerminalBlock&gt;Ȱ=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                ȯ=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;Ȯ=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;ȭ=new List&lt;
                IMyTerminalBlock&gt;();const int ȳ=1;const int Ȭ=2;int Ȼ=0;int Ʉ=0;double ɂ=-1;double Ɂ=-1;void ɀ(){ɂ=ȼ(Ȭ);Ɂ=ȼ(ȳ);}bool ȿ(){return Ȯ.Count&gt;
                0;}string Ⱦ(){{Ȱ=new List&lt;IMyTerminalBlock&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyGasTank&gt;(Ȱ,(ß=&gt;ß.CubeGrid==Me.
                CubeGrid));}Ȼ=0;Ʉ=0;for(int G=0;G&lt;Ȱ.Count;++G){if(ț(Ȱ[G])==ȳ){if(Ȱ[G].CustomName.ToLower().Contains("isolated"))ȭ.Add(Ȱ[G]);else
                ȯ.Add(Ȱ[G]);Ʉ++;}else if(ț(Ȱ[G])==Ȭ){Ȯ.Add(Ȱ[G]);Ȼ++;}}return"T"+Ȱ.Count.ToString("00");}double ȼ(List&lt;IMyTerminalBlock&gt;Ȱ
                ){double Ƚ=0;int ȫ=0;for(int G=0;G&lt;Ȱ.Count;++G){{IMyGasTank ȗ=Ȱ[G]as IMyGasTank;if(ȗ==null)continue;float Ȝ=(float)ȗ.
                FilledRatio;Ƚ+=Ȝ;ȫ++;}}if(ȫ&gt;0){return Ƚ*100/ȫ;}else return 0;}double ȼ(int Ħ=0xff){if(Ȱ.Count&lt;1)Ⱦ();if(Ȱ.Count&lt;1)return-1;double Ƀ=
                0;int ȫ=0;for(int G=0;G&lt;Ȱ.Count;++G){int Ș=ț(Ȱ[G]);if((Ș&amp;Ħ)&gt;0){IMyGasTank ȗ=Ȱ[G]as IMyGasTank;if(ȗ==null)continue;float Ȝ
                =(float)ȗ.FilledRatio;Ƀ+=Ȝ;ȫ++;}}if(ȫ&gt;0){return Ƀ/ȫ;}else return-1;}int ț(IMyTerminalBlock Ț){if(Ț is IMyGasTank){if(Ț.
                BlockDefinition.SubtypeId.Contains("Hydro"))return Ȭ;else return ȳ;}return 0;}void ș(bool ȝ=true,int Ħ=0xff){if(Ȱ.Count&lt;1)Ⱦ();if(Ȱ.
                Count&lt;1)return;for(int G=0;G&lt;Ȱ.Count;++G){int Ș=ț(Ȱ[G]);if((Ș&amp;Ħ)&gt;0){IMyGasTank ȗ=Ȱ[G]as IMyGasTank;if(ȗ==null)continue;ȗ.
                Stockpile=ȝ;}}}string Ȗ="[DOCK]";List&lt;IMyTerminalBlock&gt;ȕ=new List&lt;IMyTerminalBlock&gt;();void Ȕ(ȉ Í){Í.Ż(Œ,"GearUse",ref Ȗ,true);}
                void ȓ(){if(ȕ.Count&lt;1)ȕ=Ǘ&lt;IMyLandingGear&gt;(Ȗ);if(ȕ.Count&lt;1)ȕ=Ǐ&lt;IMyLandingGear&gt;();return;}string ȟ(){{ȕ.Clear();ȓ();}return
                "LG"+ȕ.Count.ToString("00");}bool Ȫ(){for(int G=0;G&lt;ȕ.Count;G++){IMyLandingGear ȩ;ȩ=ȕ[G]as IMyLandingGear;if(ȩ!=null&amp;&amp;ȩ.
                IsLocked)return true;}return false;}bool Ȩ(IMyTerminalBlock æ){var ȣ=æ as IMyLandingGear;if(ȣ==null)return false;return((int)ȣ.
                LockMode==1);}bool ȧ(){var Ȧ=new StringBuilder();for(int G=0;G&lt;ȕ.Count;G++){if(Ȩ(ȕ[G]))return true;}return false;}void ȥ(bool Ȥ=
                true){for(int G=0;G&lt;ȕ.Count;G++){IMyLandingGear ȣ=ȕ[G]as IMyLandingGear;if(ȣ==null)continue;if(Ȥ)ȣ.Lock();else ȣ.Unlock();}}
                string Ȣ="LOGGING";void ȡ(ȉ Í){Í.Ż(Ȣ,"TextPanelReport",ref ɭ,true);Í.Ż(Ȣ,"StatusName",ref ɲ,true);Í.Ż(Ȣ,"LongStatus",ref ɯ,
                true);Í.Ż(Ȣ,"RangeReport",ref Ʌ,true);Í.Ż(Ȣ,"SledReport",ref ɪ,true);Í.Ż(Ȣ,"GPSTag",ref ɫ,true);}ɦ Ȟ=null;string Ʌ="[RANGE]"
                ;ɦ ɒ=null;string ɲ="Wico Craft Status";ɦ ɰ=null;string ɯ="Wico Craft Log";ɦ ɮ=null;string ɭ="Craft Report";ɦ ɬ=null;
                string ɫ="[GPS]";ɦ ɱ=null;string ɪ="[SMREPORT]";bool ɨ=false;bool ɧ=false;class ɦ{Program ǲ;string ɥ="";List&lt;IMyTextPanel&gt;ɤ=
                new List&lt;IMyTextPanel&gt;();string ɩ="";string ɣ="";bool ɳ=false;bool ɾ=true;public ɦ(Program Ǟ,string ǩ,bool ɵ=false){ǲ=Ǟ;ɥ=ǩ
                ;ɳ=ɵ;ɾ=true;ɩ="";ɣ="";ɤ.Clear();ɤ=ǲ.Ǖ(ɥ);if(ɤ.Count&lt;1)ɤ=ǲ.ǖ(ɥ);}public void ɡ(string ɍ,bool ɏ=false){if(ɍ=="clear"){ɩ="";
                ɣ="X";ɾ=false;return;}if(ɳ&amp;&amp;ɾ){ɾ=false;if(ɤ.Count&gt;0){ɩ=ɤ[0].GetPublicText();ɣ="X";}}if(ɏ){ɩ=ɍ+"\n"+ɩ;}else ɩ+=ɍ+"\n";}
                public void ɼ(){if(ɣ!=ɩ){ɾ=true;foreach(var ɻ in ɤ){ɻ.WritePublicText(ɩ);}ɣ=ɩ;}}}void ɺ(){ɒ=ɽ(true);ɰ=ɷ(ɯ,true);;ɮ=ɷ(ɭ);Ȟ=ɷ(Ʌ)
                ;ɬ=ɷ(ɫ,Ä);ɱ=ɷ(ɪ);ɨ=true;}void ɹ(){if(ɒ!=null)ɡ("clear",ɒ);if(ɰ!=null)ɡ("clear",ɰ);if(ɮ!=null)ɡ("clear",ɮ);if(Ȟ!=null)ɡ(
                "clear",Ȟ);if(ɬ!=null)ɡ("clear",ɬ);if(ɱ!=null)ɡ("clear",ɱ);}void ɸ(){if(ɒ!=null)ɒ.ɼ();if(ɰ!=null)ɰ.ɼ();if(ɮ!=null)ɮ.ɼ();if(Ȟ!=
                null)Ȟ.ɼ();if(ɬ!=null)ɬ.ɼ();if(ɱ!=null)ɱ.ɼ();}ɦ ɷ(string ɶ,bool ɵ=false){ɦ ɴ=new ɦ(this,ɶ,ɵ);return ɴ;}ɦ ɽ(bool ɢ=false){if(
                (ɒ!=null||ɨ)&amp;&amp;!ɢ)return ɒ;ɒ=ɷ(ɲ);return ɒ;}void ɡ(string ɍ,ɦ ɐ,bool ɏ=false){if(ɐ==null)return;ɐ.ɡ(ɍ,ɏ);}void Ɏ(string ɍ)
                {ɡ(ɍ,ɽ());if(ɧ&amp;&amp;ɍ!="clear")Echo(ɍ);}string Ɍ(double ɑ){int ɋ=75;if(ɑ&lt;0)ɑ=0;int ɉ=(int)(ɑ*ɋ)/100;if(ɉ&gt;ɋ)ɉ=ɋ;string Ɉ="["+
                new String('|',ɉ)+new String('\'',ɋ-ɉ)+"]";return Ɉ;}void ɇ(string ǩ,Vector3D Ȏ){string ƴ;ƴ="GPS:"+ǩ+":"+Ƨ(Ȏ)+":";ɡ(ƴ,ɬ);}
                string Ɋ(string Ɇ,string ɓ){string ý;int ɠ=Ɇ.Length;int ɟ=ɓ.Length;if(ɠ+ɟ&gt;32){if(ɟ&gt;31)return"INVALID";ɠ=32-ɟ;}ý=Ɇ.Substring(0,
                ɠ)+ɓ;ý.Replace(":","_");ý.Replace(";","_");return ý;}string ɞ(double ɝ){string ɜ="";if(ɝ&gt;1000){ɜ=ɝ.ToString("N0")+"km";}
                else if(ɝ&gt;10){ɜ=ɝ.ToString("0.0")+"m";}else{ɜ=ɝ.ToString("0.000")+"m";}return ɜ;}void ɛ(){}void ɚ(ȉ Ë){ő(Ë);Ξ(Ë);ƶ(Ë);Ȕ(Ë);ƒ
                (Ë);Ͳ(Ë);ţ(Ë);}double ə=-1;string ɘ(){if(N){Echo("(RE)INIT:"+l);}do{j("Init:"+n+" ");if(N){Echo("ERROR: Need (RE)INIT:"+l
                );Echo(l);}switch(n){case 0:l="";if(N)ā();N=false;ɡ(DateTime.Now.ToString()+" "+ʣ+":"+ʢ+":INIT",ɰ,true);break;case 1:if(!
                u.ContainsKey("doscans"))u.Add("doscans",ϡ);break;case 2:Ô+=ā();break;case 3:ɺ();break;case 4:ě();break;case 5:Ô+=Ω();ˀ()
                ;break;case 6:Ô+=ƹ();break;case 7:ͼ();break;case 8:Ƒ();break;case 9:Ô+=Ν(ƺ);break;case 10:Ô+=ǹ();break;case 11:if(ƺ is
                IMyRemoteControl){Vector3D ɗ;bool ɖ=((IMyRemoteControl)ƺ).GetNearestPlayer(out ɗ);IMyRemoteControl ɕ=(IMyRemoteControl)ƺ;ɕ.
                SetCollisionAvoidance(false);ɕ.SetDockingMode(false);ɕ.Direction=Base6Directions.Direction.Forward;ɕ.FlightMode=FlightMode.OneWay;ɕ.
                ClearWaypoints();}break;case 12:Ô+=ƈ(ƺ);break;case 13:Ô+=з();break;case 14:Ô+=Ő();break;case 15:Ô+=Ⱦ();break;case 16:Ô+=Z();break;case
                17:break;case 18:Ô+=S();break;case 19:Ô+=ş();break;case 20:Ô+=ȴ();break;case 21:ʥ();break;case 22:if(Ţ)h="*"+ʣ+":"+ʢ+" V"+
                ʡ+" ";if(h.Length&gt;34){h=ʣ+":"+ʢ+"\nV"+ʡ+" ";}if(ƺ is IMyShipController){MyShipMass Q;Q=((IMyShipController)ƺ).
                CalculateShipMass();ə=Q.BaseMass;}Ô+=ɔ();break;case 23:{Æ=true;if(ƺ==null){ƺ=Me;l+="\nUsing "+Me.CustomName+" as orientation";l+=
                "\nNo Ship Controller";E=-1.0;}else{if(ƺ is IMyShipController){F=((IMyShipController)ƺ).GetShipSpeed();Vector3D m=((IMyShipController)ƺ).
                GetNaturalGravity();double k=m.Length();E=k/9.81;}else{E=-1.0;}}Echo("Grid Mass="+ə.ToString());if(ə&gt;0){if(E==0){if(Ύ&lt;1&amp;&amp;Ό&lt;1)l+=
                "\nIn Space, but no valid thrusters";}if(Ύ&lt;1&amp;&amp;Ό&lt;1&amp;&amp;Ί&lt;1){if(Ə.Count&lt;1){if(и.Count&lt;1){if(Ɖ.Count&lt;1){N=true;l+="\nNo Propulsion Method Found";l+=
                "\nNo Thrusters.\nNo NAV Rotors\nNo Sled Wheels\nNo Wheels";}}}else{N=true;l+="\nNo Valid Propulsion Method Found";l+="\nSled wheels, but No Thrusters.\nNo NAV Rotors";if(ǌ.Count&lt;
                1){N=true;l="\nSled wheels, but no Gyros";}}}else{if(ǌ.Count&lt;1){N=true;l+="\nNo Gyros Found";}if(ƺ is IMyShipController){
                }}if(Ě(Ġ)){if(ΰ==null){N=true;l+="\nSubmodule timer, but no text\n panel named:"+γ;}}else{if(p){N=true;l+=
                "\nSubmodules Enabled, but no\n timer containing:"+Ġ;if(ΰ==null){N=true;l+="\n No text\n panel containing:"+γ;}}}}if(!N){Æ=true;}else{n=-1;}break;}}n++;}while(!Æ&amp;&amp;(((
                float)Runtime.CurrentInstructionCount/(float)Runtime.MaxInstructionCount)&lt;0.2f));if(Æ)n=0;if(N){Echo("ERROR: Need (RE)INIT:"+
                l);}Echo(l);Ɏ(Ô);return Ô;}string ɔ(){return"&gt;";}int Έ=-1;const int Љ=0;const int Ї=1;const int І=2;const int Ѕ=3;const
                int Є=4;const int Ѓ=5;const int Ђ=7;const int Ј=8;const int Ё=9;const int Ͽ=13;const int Ͼ=10;const int Ͻ=11;const int ϼ=12
                ;const int ϻ=14;const int Ϻ=15;const int Ѐ=16;const int Ϲ=17;const int Њ=18;const int М=19;const int К=20;const int Й=21;
                const int И=22;const int З=23;const int Ж=24;const int Е=25;const int Д=26;const int Г=27;const int В=28;const int Б=29;const
                int А=30;const int Џ=31;const int Ў=33;const int Ѝ=50;const int Ќ=60;const int Ћ=111;const int Л=112;const int ϸ=200;const
                int ϵ=210;const int Ϥ=220;const int ϣ=225;const int Ϣ=290;const int ϡ=400;const int Ϡ=410;const int ϟ=500;const int ϥ=510;
                const int Ϟ=999;void Ϝ(int ϛ){if(Έ==ϛ)return;Έ=ϛ;δ=0;Ļ();}Vector3D Ϛ;bool ϙ=false;DateTime Ϙ;double ϗ=9999;double ϝ=50;int ϖ=
                А;int ϧ=0;bool Ϸ=false;bool ϴ=true;bool ϳ=true;bool ϲ=false;bool ϱ=false;float ϰ=-1;bool ϯ=false;string Ϯ="";string ϭ=
                "NAV";void Ϭ(ȉ Í){Í.Ż(ϭ,"DTMDebug",ref Ϸ,true);Í.Ż(ϭ,"CameraCollision",ref ϴ,true);Í.Ż(ϭ,"SensorCollision",ref ϳ,true);Í.Ż(ϭ,
                "NAVEmulateOld",ref ϲ,true);Í.Ż(ϭ,"NAVGravityMinElevation",ref ϰ,true);Í.Ż(ϭ,"NavBeaconDebug",ref ϯ,true);Í.Ż(ϭ,"AllowBlindNav",ref ϱ,
                true);if(ϗ&gt;Ð)ϗ=Ð;}void ϫ(ȉ Í){Í.Ų(ϭ,"vTarget",Ϛ);Í.Ų(ϭ,"ValidNavTarget",ϙ);Í.Ų(ϭ,"TargetName",Ϯ);Í.Ų(ϭ,"dStartShip",Ϙ);Í.Ų(ϭ
                ,"shipSpeedMax",ϗ);Í.Ų(ϭ,"arrivalDistanceMin",ϝ);Í.Ų(ϭ,"NAVArrivalMode",ϖ);Í.Ų(ϭ,"NAVArrivalState",ϧ);}void Ϫ(ȉ Í){Í.Ż(ϭ,
                "vTarget",ref Ϛ,true);Í.Ż(ϭ,"ValidNavTarget",ref ϙ,true);Í.Ż(ϭ,"TargetName",ref Ϯ,true);Í.Ż(ϭ,"dStartShip",ref Ϙ,true);Í.Ż(ϭ,
                "shipSpeedMax",ref ϗ,true);Í.Ż(ϭ,"arrivalDistanceMin",ref ϝ,true);Í.Ż(ϭ,"NAVArrivalMode",ref ϖ,true);Í.Ż(ϭ,"NAVArrivalState",ref ϧ,
                true);}List&lt;IMyBeacon&gt;ϩ=new List&lt;IMyBeacon&gt;();void Ϧ(string Ϩ){if(ϯ){if(ϩ.Count&lt;1)GridTerminalSystem.GetBlocksOfType(ϩ);
                foreach(var Н in ϩ){Н.CustomName=Ϩ;}}}void с(Vector3D Щ,int п=А,int о=0,double н=50,string м="",double л=9999){Ϛ=Щ;ϙ=true;ϖ=п;ϧ
                =о;ϝ=н;Ϯ=м;δ=0;if(л&gt;Ð)л=Ð;ϗ=л;Ϝ(Ђ);}List&lt;IMyTerminalBlock&gt;к=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;й=new List
                &lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;и=new List&lt;IMyTerminalBlock&gt;();string з(){к.Clear();й.Clear();и.Clear();
                GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(к,ç);for(int G=0;G&lt;к.Count;G++){if(к[G].CustomName.Contains("[LEFT]")||к[G].CustomData.
                Contains("[LEFT]")){й.Add(к[G]);}else if(к[G].CustomName.Contains("[RIGHT]")||к[G].CustomData.Contains("[RIGHT]")){и.Add(к[G]);}
                }return"NR:L"+й.Count.ToString("0")+"R"+и.Count.ToString("0");}bool ж(float ƛ){if(й.Count&lt;1)return false;float е=й[0].
                GetMaximum&lt;float&gt;("Velocity");var Ø=й[0]as IMyMotorStator;float р=Ø.TargetVelocityRPM;float Ƙ=(р/е*100);Ƙ=Math.Abs(Ƙ);if(ƛ&gt;(Ƙ+5f))
                ƛ=Ƙ+5;if(ƛ&lt;(Ƙ-5))ƛ=Ƙ-5;if(ƛ&lt;0f)ƛ=0f;if(ƛ&gt;100f)ƛ=100f;if(Math.Abs(ƛ)&gt;0){ж(й,-ƛ);ж(и,ƛ);return true;}else return false;}
                bool ж(List&lt;IMyTerminalBlock&gt;ц,float ƛ){for(int G=0;G&lt;ц.Count;G++){var Ø=ц[G]as IMyMotorStator;float е=Ø.GetMaximum&lt;float&gt;(
                "Velocity");if(!Ø.Enabled)Ø.Enabled=true;float ш=е*(ƛ/100.0f);Ø.TargetVelocityRPM=ш;}return true;}bool ч(){ч(й);ч(и);return true;}
                bool ч(List&lt;IMyTerminalBlock&gt;ц){for(int G=0;G&lt;ц.Count;G++){IMyMotorStator Ø=ц[G]as IMyMotorStator;Ø.TargetVelocityRPM=0;}
                return true;}bool х(double ф){float ƛ;if(Math.Abs(ф)&gt;1.0){ƛ=50;}else if(Math.Abs(ф)&gt;.7){ƛ=50;}else if(Math.Abs(ф)&gt;0.5){ƛ=30;}
                else if(Math.Abs(ф)&gt;0.1){ƛ=20;}else if(Math.Abs(ф)&gt;0.01){ƛ=5;}else if(Math.Abs(ф)&gt;0.001){ƛ=0;}else ƛ=0;ƛ/=3;ƛ=ƛ*-Math.Sign(ф
                );if(Math.Abs(ƛ)&gt;0){ж(й,ƛ);}if(Math.Abs(ƛ)&gt;0){ж(и,ƛ);}if(Math.Abs(ƛ)&gt;0)return false;else return true;}bool у(string D){
                string[]т=D.Trim().Split(';');for(int д=0;д&lt;т.Length;д++){string[]Ш=т[д].Trim().Split(' ');if(Ш[0]=="timer"){ʮ();}else if(Ш[0]
                =="idle")ȷ();else if(Ш[0]=="setmode"){if(Ш.Length&lt;2){Echo("Invalid command format:\nsetmode &lt;mode#&gt;");}else{int ƀ;bool Ч=
                int.TryParse(Ш[1],out ƀ);if(!Ч){Echo("Invalid INT value:"+Ш[1]);}else{Echo("Set Mode to"+ƀ);Ϝ(ƀ);}}}else if(Ш[0]==
                "setstate"){if(Ш.Length&lt;2){Echo("Invalid command format:\nsetstate &lt;state#&gt;");}else{int ƀ;bool Ч=int.TryParse(Ш[1],out ƀ);if(!Ч){
                Echo("Invalid INT value:"+Ш[1]);}else{Echo("Set State to"+ƀ);δ=ƀ;}}}else if(Ш[0]=="masterreset")ʖ();else if(Ш[0].ToLower()==
                "coast"){if(Ι.Count&gt;1){ʽ(Ι);}}else if(Ш[0]=="setvaluef"){Echo("SetValueFloat");string Ц="";for(int G=1;G&lt;Ш.Length;G++){Ц+=Ш[G];
                if(G&lt;Ш.Length-1){Ц+=" ";}}string[]Х=Ц.Trim().Split(':');if(Х.Length&lt;3){Echo("Invalid Args");continue;}IMyTerminalBlock æ;æ
                =(IMyTerminalBlock)GridTerminalSystem.GetBlockWithName(Х[0]);if(æ==null){Echo("Block not found:"+Х[0]);continue;}float Ф=
                0;bool П=float.TryParse(Х[2].Trim(),out Ф);if(!П){Echo("invalid float value:"+Х[2]);continue;}Echo("SetValueFloat:"+Х[0]+
                " "+Х[1]+" to:"+Ф.ToString());æ.SetValueFloat(Х[1],Ф);}else if(Ш[0]=="brake"){Echo("brake");if(ƺ is IMyShipController){
                IMyShipController У=ƺ as IMyShipController;bool Т=У.HandBrake;У.ApplyAction("HandBrake");}else Echo("No Ship Controller found");}else if(
                Ш[0]=="genpatrol"){Echo("genpatrol");double С=500;double Р=500;if(Ш.Length&gt;1){bool П=double.TryParse(Ш[1].Trim(),out С);}
                if(Ш.Length&gt;2){bool П=double.TryParse(Ш[2].Trim(),out Р);}string О="WICO:PATROL:";Vector3D Щ;Vector3D г=ƺ.WorldMatrix.Up;
                if(ƺ is IMyShipController){Vector3D m=((IMyShipController)ƺ).GetNaturalGravity();if(m.Length()&gt;0.05){г=m;г.Normalize();}}О
                +="4:";ɡ("clear",ɬ);Щ=ƺ.GetPosition()+ƺ.WorldMatrix.Up*Р+ƺ.WorldMatrix.Right*С;ɇ("Patrol0",Щ);О+=Ƨ(Щ)+":";Щ=ƺ.GetPosition(
                )+ƺ.WorldMatrix.Up*Р+ƺ.WorldMatrix.Forward*С;ɇ("Patrol1",Щ);О+=Ƨ(Щ)+":";Щ=ƺ.GetPosition()+ƺ.WorldMatrix.Up*Р+ƺ.
                WorldMatrix.Left*С;ɇ("Patrol2",Щ);О+=Ƨ(Щ)+":";Щ=ƺ.GetPosition()+ƺ.WorldMatrix.Up*Р+ƺ.WorldMatrix.Backward*С;ɇ("Patrol3",Щ);О+=Ƨ(Щ)+
                ":";ņ(О);l+="PATROL:\n"+О;}else if(Ш[0]=="wcct"||Ш[0]==""){}else{int в;if(u.TryGetValue(Ш[0].ToLower(),out в)){Ϝ(в);}else
                Echo("Unrecognized Command:"+т[д]);}}return false;}bool б(string D){return false;}double а=-1;List&lt;IMyTerminalBlock&gt;Я=new
                List&lt;IMyTerminalBlock&gt;();void Ю(){Я.Clear();Ǐ&lt;IMyReactor&gt;(ref Я);float Ы;Ь(out Ы);}double Э(){double Ç=0;foreach(var ʊ in Я)
                {IMyReactor ʉ=ʊ as IMyReactor;Ç+=ʉ.CurrentOutput;}return Ç;}bool Ь(out float Ы){Ы=0;а=-1;bool Ъ=false;if(Я.Count&gt;0)а=0;
                foreach(IMyReactor ʉ in Я){Ы+=ʉ.CurrentOutput;а+=ʉ.MaxOutput;}return Ъ;}void ϕ(){if(ί==null)return;ʬ(ί);ί.Ų(β,"Mode",Έ.ToString
                ());ί.Ų(β,"current_state",δ.ToString());ί.Ų(β,"PassedArgument",ά);ί.Ų(β,"AlertStates",Ϋ.ToString());ί.Ų(β,
                "craft_operation",έ.ToString());ί.Ų(β,"PassedArgument",ά);ί.Ų(β,"ReceivedMessage",Ϊ);long ε=0;if(ΰ!=null)ε=ΰ.EntityId;ί.Ų(β,"SaveID",(
                long)ε);if(ί.Ǡ){if(ί.Ǡ){string ǜ=ί.ƣ();if(ΰ==null){Echo("WARNING: saving to Storage");Storage=ǜ;}else{ΰ.WritePublicText(ǜ,
                false);}}}else{Echo("Not saving: Same");}}string γ="Wico Craft Save";string β="WCCM2";void α(ȉ Í){Í.Ż(β,"SAVE_FILE_NAME",ref
                γ,true);}IMyTextPanel ΰ=null;ȉ ί=null;int δ=0;long ή=0;int έ=ʳ;string ά="";int Ϋ=0;string Ϊ="";string Ω(){string Ô="S";ΰ=
                null;List&lt;IMyTerminalBlock&gt;Ė=new List&lt;IMyTerminalBlock&gt;();Ė=ƽ&lt;IMyTextPanel&gt;(γ);if(Ė.Count&gt;1){N=true;l+=
                "\nMultiple blocks found:\""+γ+"\"";}else if(Ė.Count==0){Ė=Ǘ&lt;IMyTextPanel&gt;(γ);if(Ė.Count==1)ΰ=Ė[0]as IMyTextPanel;else{Ė=ǘ&lt;IMyTextPanel&gt;(γ);if(Ė.
                Count==1)ΰ=Ė[0]as IMyTextPanel;}}else ΰ=Ė[0]as IMyTextPanel;ί=new ȉ(this,"");if(ΰ==null){Ô="-";}return Ô;}bool Ψ(){return ΰ!=
                null;}string Ƨ(Vector3D Ʀ){string ý;ý=Ʀ.X.ToString("0.00")+":"+Ʀ.Y.ToString("0.00")+":"+Ʀ.Z.ToString("0.00");return ý;}bool
                Ư(string Ʈ,out double ß,out double ƭ,out double Ƭ){string[]ƫ=Ʈ.Trim().Split(',');if(ƫ.Length&lt;3){ƫ=Ʈ.Trim().Split(':');}ß=
                0;ƭ=0;Ƭ=0;if(ƫ.Length&lt;3)return false;bool ƪ=double.TryParse(ƫ[0].Trim(),out ß);bool Ʃ=double.TryParse(ƫ[1].Trim(),out ƭ);
                bool ƨ=double.TryParse(ƫ[2].Trim(),out Ƭ);if(!ƪ||!Ʃ||!ƨ){return false;}return true;}List&lt;IMyTerminalBlock&gt;κ=new List&lt;
                IMyTerminalBlock&gt;();float ι=0;double θ=-1;void η(){κ.Clear();θ=-1;GridTerminalSystem.GetBlocksOfType&lt;IMySolarPanel&gt;(κ,ç);ζ();}void ζ(){
                if(κ.Count&gt;0)θ=0;ι=0;foreach(var ʊ in κ){IMySolarPanel ʉ=ʊ as IMySolarPanel;θ+=ʉ.MaxOutput;ι+=ʉ.CurrentOutput;}}List&lt;
                IMyTerminalBlock&gt;Χ=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;Μ=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;Ι=new List&lt;
                IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;Θ=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;Η=new List&lt;IMyTerminalBlock&gt;();List&lt;
                IMyTerminalBlock&gt;Ζ=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;Ε=new List&lt;IMyTerminalBlock&gt;();double Δ=0;double Κ=0;double Γ=0;
                double Α=0;double ΐ=0;double Ώ=0;int Ύ=0;int Ό=0;int Ί=0;int Β=0;const int Ή=1;const int Λ=2;const int Φ=4;const int Υ=8;const
                int Τ=0xff;Matrix Σ=new Matrix(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);string Ρ="IGNORE";string Π="cutter";string Ο="THRUSTERS";
                void Ξ(ȉ Í){Í.Ż(Ο,"IgnoreThruster",ref Ρ);Í.Ż(Ο,"CutterThruster",ref Π);}void Ν(IMyTerminalBlock Ƈ,ref List&lt;IMyTerminalBlock
                &gt;Μ,ref List&lt;IMyTerminalBlock&gt;Ι,ref List&lt;IMyTerminalBlock&gt;Θ,ref List&lt;IMyTerminalBlock&gt;Η,ref List&lt;IMyTerminalBlock&gt;Ζ,ref
                List&lt;IMyTerminalBlock&gt;Ε,int λ=Τ){Μ.Clear();Ι.Clear();Θ.Clear();Η.Clear();Ζ.Clear();Ε.Clear();Χ.Clear();if(Ƈ==null)return;var
                π=new List&lt;IMyTerminalBlock&gt;();Ǐ&lt;IMyThrust&gt;(ref π);for(int G=0;G&lt;π.Count;G++){if(π[G].CustomName.ToLower().Contains(Π)||π
                [G].CustomData.ToLower().Contains(Π))continue;if(π[G].CustomName.ToLower().Contains(Ρ)||π[G].CustomData.ToLower().
                Contains(Ρ))continue;Χ.Add(π[G]);}Matrix ϊ;Ƈ.Orientation.GetMatrix(out ϊ);Matrix.Transpose(ref ϊ,out ϊ);Δ=0;Κ=0;Γ=0;Α=0;ΐ=0;Ώ=0;
                for(int G=0;G&lt;Χ.Count;++G){var Ĥ=Χ[G]as IMyThrust;Matrix ω;Ĥ.Orientation.GetMatrix(out ω);Vector3 ψ=Vector3.Transform(ω.
                Backward,ϊ);int χ=φ(Χ[G]);if(χ==Ή)Ί++;else if(χ==Λ)Ό++;else if(χ==Φ)Ύ++;else if(χ==Υ)Β++;if(ψ==Σ.Left){ΐ+=Ċ((IMyThrust)Χ[G]);Ζ.
                Add(Χ[G]);}else if(ψ==Σ.Right){Ώ+=Ċ((IMyThrust)Χ[G]);Ε.Add(Χ[G]);}else if(ψ==Σ.Backward){Κ+=Ċ((IMyThrust)Χ[G]);Ι.Add(Χ[G]);
                }else if(ψ==Σ.Forward){Δ+=Ċ((IMyThrust)Χ[G]);Μ.Add(Χ[G]);}else if(ψ==Σ.Up){Α+=Ċ((IMyThrust)Χ[G]);Η.Add(Χ[G]);}else if(ψ==
                Σ.Down){Γ+=Ċ((IMyThrust)Χ[G]);Θ.Add(Χ[G]);}}}string Ν(IMyTerminalBlock Ƈ){Μ.Clear();Ι.Clear();Θ.Clear();Η.Clear();Ζ.Clear
                ();Ε.Clear();Χ.Clear();if(Ƈ==null)return"No Orientation Block";Ν(Ƈ,ref Μ,ref Ι,ref Θ,ref Η,ref Ζ,ref Ε);string ý;ý="&gt;";ý
                +="F"+Μ.Count.ToString("00");ý+="B"+Ι.Count.ToString("00");ý+="D"+Θ.Count.ToString("00");ý+="U"+Η.Count.ToString("00");ý+=
                "L"+Ζ.Count.ToString("00");ý+="R"+Ε.Count.ToString("00");ý+="&lt;";return ý;}int φ(IMyTerminalBlock Ț){if(Ț is IMyThrust){if(Ț
                .BlockDefinition.SubtypeId.Contains("AtmosphericHover"))return Υ;else if(Ț.BlockDefinition.SubtypeId.Contains("Atmo"))
                return Ή;else if(Ț.BlockDefinition.SubtypeId.Contains("Hydro"))return Λ;else if(Ț.BlockDefinition.SubtypeId.Contains(
                "SmallBlock_HoverEngine"))return Υ;else return Φ;}return 0;}double Ċ(IMyThrust Ĥ){return Ĥ.MaxEffectiveThrust;}double υ(List&lt;IMyTerminalBlock&gt;ĩ,
                int Ħ=Τ){double ĵ=0;for(int μ=0;μ&lt;ĩ.Count;μ++){int ĥ=φ(ĩ[μ]);if((ĥ&amp;Ħ)&gt;0){IMyThrust Ĥ=ĩ[μ]as IMyThrust;double ϓ=Ĥ.
                MaxEffectiveThrust;ĵ+=ϓ;}}return ĵ;}double ϒ(List&lt;IMyTerminalBlock&gt;ĩ,float ϑ=5f,float ϐ=2f,float Ϗ=1f){double ώ=0;foreach(var æ in ĩ){var
                Ĥ=æ as IMyThrust;if(Ĥ==null)continue;if(φ(Ĥ)==Ή)ώ+=Ĥ.MaxEffectiveThrust*ϑ;else if(φ(Ĥ)==Φ)ώ+=Ĥ.MaxEffectiveThrust*ϐ;else
                if(φ(Ĥ)==Λ)ώ+=Ĥ.MaxEffectiveThrust*Ϗ;else ώ+=Ĥ.MaxEffectiveThrust;}return ώ;}bool ύ(List&lt;IMyTerminalBlock&gt;ĩ,out float ό,
                out float ɂ,out float ϋ){ό=0;ɂ=0;ϋ=0;double ϔ=υ(ĩ,Φ);double τ=υ(ĩ,Ή);double σ=υ(ĩ,Λ);MyShipMass Q;Q=((IMyShipController)ƺ).
                CalculateShipMass();double Ĺ=0;Ĺ=Q.PhysicalMass*E*9.810;if(τ&gt;0){if(τ&lt;Ĺ){ό=100;Ĺ-=τ;}else{ό=(float)(Ĺ/τ*100);if(ό&gt;0)Ĺ-=(τ*ό/100);}}if(ϔ&gt;0
                &amp;&amp;Ĺ&gt;0){if(ϔ&lt;Ĺ){ϋ=100;Ĺ-=ϔ;}else{ϋ=(float)(Ĺ/ϔ*100);if(ϋ&gt;0)Ĺ-=((ϔ*ϋ)/100);}}if(σ&gt;0&amp;&amp;Ĺ&gt;0){if(σ&lt;Ĺ){ɂ=100;Ĺ-=σ;}else{ɂ=(float)
                (Ĺ/σ*100);if(ɂ&gt;0)Ĺ-=((σ*ɂ)/100);;}}if(Ĺ&gt;0)return false;return true;}List&lt;IMyTerminalBlock&gt;ο(string ξ){var ν=new List&lt;
                IMyTerminalBlock&gt;();var ī=new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(ī);for(int Ī=0;Ī&lt;ī.Count;Ī++){if(ī[Ī].Name==ξ){
                List&lt;IMyTerminalBlock&gt;ĩ=null;ī[Ī].GetBlocks(ĩ,ç);for(int μ=0;μ&lt;ĩ.Count;μ++){ν.Add(ĩ[μ]);}break;}}return ν;}int Ĩ(List&lt;
                IMyTerminalBlock&gt;ĩ,float ʒ,int Ħ=Τ){int ĸ=0;if(ʒ&gt;100)ʒ=100;if(ʒ&lt;0)ʒ=0;for(int μ=0;μ&lt;ĩ.Count;μ++){int ĥ=φ(ĩ[μ]);if((ĥ&amp;Ħ)&gt;0){IMyThrust Ĥ=ĩ
                [μ]as IMyThrust;if(!Ĥ.IsWorking){if(!Ĥ.Enabled)Ĥ.Enabled=true;}ĸ+=1;Ĥ.ThrustOverridePercentage=ʒ/100f;}}return ĸ;}int Ĩ(
                List&lt;IMyTerminalBlock&gt;ĩ,int ς=100,int Ħ=Τ){return Ĩ(ĩ,(float)ς,Ħ);}bool Ĩ(string Ĭ,int ς=100,int Ħ=Τ){if(ς&gt;100)ς=100;var ī=
                new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(ī);for(int Ī=0;Ī&lt;ī.Count;Ī++){if(ī[Ī].Name==Ĭ){List&lt;
                IMyTerminalBlock&gt;ĩ=null;ī[Ī].GetBlocks(ĩ,ç);return(Ĩ(ĩ,ς,Ħ)&gt;0);}}return false;}int ħ(List&lt;IMyTerminalBlock&gt;ĩ,int Ħ=Τ,bool ρ=false){int ĸ
                =0;for(int μ=0;μ&lt;ĩ.Count;μ++){int ĥ=φ(ĩ[μ]);if((ĥ&amp;Ħ)&gt;0){ĸ++;IMyThrust Ĥ=ĩ[μ]as IMyThrust;Ĥ.ThrustOverride=0;if(Ĥ.
                IsWorking&amp;&amp;ρ&amp;&amp;Ĥ.Enabled==true)Ĥ.Enabled=false;else if(!Ĥ.IsWorking&amp;&amp;!ρ&amp;&amp;Ĥ.Enabled==false)Ĥ.Enabled=true;}}return ĸ;}bool ħ(string
                Ĭ){var ī=new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(ī);for(int Ī=0;Ī&lt;ī.Count;Ī++){if(ī[Ī].Name==Ĭ){List&lt;
                IMyTerminalBlock&gt;ĩ=null;ī[Ī].GetBlocks(ĩ,ç);return(ħ(ĩ)&gt;0);}}return false;}bool Ĩ(){return(Ĩ(Μ)&gt;0);}bool ħ(){return(ħ(Μ)&gt;0);}double ĭ(
                List&lt;IMyTerminalBlock&gt;Ģ,int Ħ=Τ){for(int G=0;G&lt;Ģ.Count;G++){int ĥ=φ(Ģ[G]);if((ĥ&amp;Ħ)&gt;0&amp;&amp;Ģ[G].IsWorking){var Ĥ=Ģ[G]as IMyThrust
                ;return Ĥ.ThrustOverride;}}return 0;}bool ģ(List&lt;IMyTerminalBlock&gt;Ģ,int Ħ=Τ){for(int G=0;G&lt;Ģ.Count;G++){int ĥ=φ(Ģ[G]);if(
                (ĥ&amp;Ħ)&gt;0&amp;&amp;Ģ[G].IsWorking){return true;}}return false;}int ĺ(List&lt;IMyTerminalBlock&gt;Ģ,int Ħ=Τ){int ĸ=0;for(int G=0;G&lt;Ģ.Count
                ;G++){int ĥ=φ(Ģ[G]);if((ĥ&amp;Ħ)&gt;0&amp;&amp;Ģ[G].IsWorking){ĸ++;}}return ĸ;}IMyThrust ķ(List&lt;IMyTerminalBlock&gt;B,int Ķ=Τ){foreach(var
                ĵ in Χ){if(ĵ is IMyThrust&amp;&amp;(φ(ĵ)&amp;Ķ)&gt;0)return ĵ as IMyThrust;}return null;}double Ĵ(){if(Ί&lt;1)return 0;var ĳ=ķ(Χ,Ή);if(ĳ==
                null)return 0;return ĳ.MaxEffectiveThrust/ĳ.MaxThrust;}double Ĳ(List&lt;IMyTerminalBlock&gt;ı,double İ,double į){var Q=((
                IMyShipController)ƺ).CalculateShipMass();double Ĺ=Q.PhysicalMass*į*9.810;double Ċ=υ(ı);double ć=(Ċ-Ĺ)/Q.PhysicalMass;double Ē=İ/ć;double
                đ=İ/2*Ē;return đ;}int Đ=0;void ď(float Ď,float č,List&lt;IMyTerminalBlock&gt;ē,List&lt;IMyTerminalBlock&gt;Č){if(Đ&lt;0)Đ=0;double Ċ=υ(ē
                );MyShipMass Q;Q=((IMyShipController)ƺ).CalculateShipMass();double ĉ=Q.PhysicalMass;float Ĉ=100f;if(ĉ&gt;0){double ć=(Ċ)/ĉ;
                if(ć&gt;0)Ĉ=(float)(Ď/ć);}if(F&gt;č){ħ(Χ);}else if(F&lt;(Ď*0.90)){if(F&lt;0.09)Đ++;if(F&lt;Ď*0.25)Đ++;Ĩ(ē,Ĉ+Đ/5);}else if(F&lt;(Ď*1.1)){Đ--;
                ħ(Č,Τ,true);ħ(ē);}else{Đ--;Đ--;Ĩ(ē,1f);}}void Ć(){Đ=0;}string[]ċ={"-","\\","|","/","-","\\","|","/"};int ą=99;string Ĕ(){
                ą++;if(ą&gt;=ċ.Length)ą=0;return ċ[ą];}string ġ="[WCCT]";string Ġ="[WCCS]";string ğ="[WCCM]";string Ğ="WICOTIMERS";void ĝ(ȉ
                Í){Í.Ż(Ğ,"FastTimer",ref ġ,true);Í.Ż(Ğ,"SubModuleTimer",ref Ġ,true);Í.Ż(Ğ,"MainTimer",ref ğ,true);}Dictionary&lt;string,List
                &lt;IMyTerminalBlock&gt;&gt;Ĝ=new Dictionary&lt;string,List&lt;IMyTerminalBlock&gt;&gt;();void ě(){Ĝ.Clear();Ě(ġ);Ě(Ġ);Ě(ğ);}bool Ě(string Ę){
                var Ė=new List&lt;IMyTerminalBlock&gt;();if(Ĝ.ContainsKey(Ę)){Ė=Ĝ[Ę];if(Ė.Count&gt;0)return true;}else{Ė=Ǘ&lt;IMyTimerBlock&gt;(Ę);Ĝ.Add(Ę
                ,Ė);if(Ė.Count&gt;0)return true;}return false;}bool ę(string Ę="[WCCS]"){bool ė=false;List&lt;IMyTerminalBlock&gt;Ė=new List&lt;
                IMyTerminalBlock&gt;();IMyTimerBlock ĕ=null;if(Ĝ.ContainsKey(Ę)){Ė=Ĝ[Ę];}else{Ė=Ǘ&lt;IMyTimerBlock&gt;(Ę);Ĝ.Add(Ę,Ė);}for(int G=0;G&lt;Ė.Count;G++){
                ĕ=Ė[G]as IMyTimerBlock;if(ĕ!=null){if(ĕ.Enabled){ĕ.Trigger();ė=true;}else{Echo("Timer:"+ĕ.CustomName+" is OFF");}}}return
                ė;}void Ļ(){Runtime.UpdateFrequency|=UpdateFrequency.Once;}bool ŉ=false;string Ť="COMMUNICATIONS";void ţ(ȉ Í){Í.Ż(Ť,
                "CommunicationsStealth",ref ŉ,true);}bool Ţ=false;List&lt;IMyRadioAntenna&gt;š=new List&lt;IMyRadioAntenna&gt;();List&lt;IMyLaserAntenna&gt;Š=new List&lt;
                IMyLaserAntenna&gt;();string ş(){š.Clear();Š.Clear();Ǐ&lt;IMyRadioAntenna&gt;(ref š);Ǐ&lt;IMyLaserAntenna&gt;(ref Š);for(int å=0;å&lt;š.Count;++å){if(š[å
                ].CustomName.Contains("unused")||š[å].CustomData.Contains("unused"))continue;if(!Ţ){ʣ="Wico "+š[å].CustomName.Split('!')[
                0].Trim();Ţ=true;}}return"A"+š.Count.ToString("0");}void Ş(){for(int G=0;G&lt;š.Count;G++){š[G].Enabled=true;}}string Ŝ="";
                void ś(){if(Ϊ!=""){if(Ŝ==Ϊ){Ϊ="";}Ŝ=Ϊ;}else Ŝ="";}void Ś(){}bool ř(){bool Ř=false;float ŝ=0;int ŗ=-1;for(int G=0;G&lt;š.Count;G
                ++){if(š[G].AttachedProgrammableBlock==Me.EntityId){Ř=true;ŗ=G;break;}if(š[G].Radius&gt;ŝ&amp;&amp;š[G].AttachedProgrammableBlock==0)
                {ŗ=G;ŝ=š[G].Radius;}}if(ŗ&gt;=0){if(š[ŗ].AttachedProgrammableBlock!=Me.EntityId)Ô+="\nSetting Antenna PB";š[ŗ].
                AttachedProgrammableBlock=Me.EntityId;Ř=true;}else{}return Ř;}void Ű(bool ť=false){if(š.Count&lt;1)ş();foreach(var ů in š){ů.Radius=200;if(ů.
                AttachedProgrammableBlock&gt;0||ť){ů.Enabled=true;}}}void Ů(float ŭ=200,bool ť=false){if(š.Count&lt;1)ş();foreach(var ū in š){if(ū.
                AttachedProgrammableBlock&gt;0||ť){ū.Radius=ŭ;ū.Enabled=true;}}}Vector3D Ŭ(){if(š.Count&lt;1)ş();foreach(var ū in š){if(ū.AttachedProgrammableBlock==Me
                .EntityId){return ū.GetPosition();}}foreach(var ū in š){return ū.GetPosition();}Vector3D Ū=new Vector3D();return Ū;}float
                ũ=float.MaxValue;void Ũ(bool ť=false,float ŧ=float.MaxValue){if(ŧ&lt;200)ŧ=200;ũ=ŧ;Ŧ(ť);}void Ŧ(bool ť=false){if(š==null||š.
                Count&lt;1)ş();foreach(var ů in š){if(ů.AttachedProgrammableBlock&gt;0||ť){float Ŗ=ů.GetMaximum&lt;float&gt;("Radius");if(ũ&lt;Ŗ)Ŗ=ũ;ů.
                Radius=Ŗ;ů.Enabled=true;}}}int Ŕ(){if(š.Count&lt;1)ş();return(š.Count);}List&lt;string&gt;ň=new List&lt;string&gt;();void Ň(){if(ň.Count&gt;0){Ŧ
                ();Echo("pPS("+ň.Count+"):"+ň[0]);Ŧ();ņ(ň[0],false);ň.RemoveAt(0);}if(ň.Count&gt;0){Echo("Pending Send.  Request FAST!");Ŧ()
                ;M=true;}else{if(ŉ){Ű(true);}}}void ņ(string Ŀ,bool Ņ=true){bool ń=false;if(š.Count&lt;1)ş();for(int G=0;G&lt;š.Count;G++){if(!
                Ņ){ń=š[G].TransmitMessage(Ŀ);if(ń){break;}}}if(!ń){if(Ŕ()&gt;0){ň.Add(Ŀ);Echo(
                "Adding outgoing message to queue. Request FAST!");Echo(Ŀ);M=true;}else{Echo("Unable to send Antenna Message!");}}}List&lt;string&gt;Ń=new List&lt;string&gt;();void Ł(){if(Ń.Count&gt;0
                ){if(Ϊ==""){Ϊ=Ń[0];Ń.RemoveAt(0);}else Echo("Waiting for message to be processed");Ļ();}if(Ń.Count&gt;0){}}void ŀ(string Ŀ){
                Echo("RECEIVE:\n"+Ŀ);Ń.Add(Ŀ);Ł();}void ľ(){if(š.Count&gt;0){Echo(Ń.Count+" Pending Incoming Messages");for(int G=0;G&lt;Ń.Count;G
                ++)Echo(G+":"+Ń[G]);}else Echo("No antennas found");}List&lt;IMyTerminalBlock&gt;Ľ=new List&lt;IMyTerminalBlock&gt;();List&lt;
                IMyTerminalBlock&gt;ł=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;ļ=new List&lt;IMyTerminalBlock&gt;();bool Ŋ=false;string ŕ="[BASE]";
                string œ="[DOCK]";string Œ="CONNECTORS";void ő(ȉ Í){Í.Ż(Œ,"BaseConnector",ref ŕ,true);Í.Ż(Œ,"DockConnector",ref œ,true);}
                string Ő(){Ŋ=false;Ľ.Clear();ł.Clear();ļ.Clear();ŏ();return"CL"+Ľ.Count.ToString()+"CD"+ł.Count.ToString()+"CB"+ļ.Count.
                ToString();}void ŏ(){if(Ľ.Count&lt;1&amp;&amp;!Ŋ)Ľ=Ǐ&lt;IMyShipConnector&gt;();if(ł.Count&lt;1&amp;&amp;!Ŋ)ł=Ǘ&lt;IMyShipConnector&gt;(œ);if(ł.Count&lt;1&amp;&amp;!Ŋ)ł=Ľ;if(
                ļ.Count&lt;1&amp;&amp;!Ŋ)ļ=Ǘ&lt;IMyShipConnector&gt;(ŕ);Ŋ=true;return;}bool Ŏ(){return ł.Count&gt;1;}bool ō(){ŏ();for(int G=0;G&lt;ł.Count;G++){
                var ª=ł[G]as IMyShipConnector;if(ª==null)continue;if(ª.Status==MyShipConnectorStatus.Connectable)return true;}return false;
                }bool Ō(){ŏ();for(int G=0;G&lt;ł.Count;G++){var ª=ł[G]as IMyShipConnector;if(ª==null)continue;if(ª.Status==
                MyShipConnectorStatus.Connected){var w=ª.OtherConnector;if(w.CubeGrid==ª.CubeGrid){continue;}else return true;}}return false;}void ŋ(){for(
                int G=0;G&lt;ł.Count;G++){var ª=ł[G]as IMyShipConnector;if(ª==null)continue;}}IMyTerminalBlock Ą(){ŏ();if(ł.Count&gt;0){return ł[
                0];}return null;}IMyTerminalBlock R(bool Á=false){ŏ();for(int G=0;G&lt;ł.Count;G++){var ª=ł[G]as IMyShipConnector;if(ª==null
                )continue;if(ª.Status==MyShipConnectorStatus.Connected){var w=ª.OtherConnector;if(w.CubeGrid==ª.CubeGrid){continue;}else{
                if(!Á){return ª.OtherConnector;}else{return ł[G];}}}}return null;}void À(bool º=true,bool Â=true){ŏ();for(int G=0;G&lt;ł.
                Count;G++){var ª=ł[G]as IMyShipConnector;if(ª==null)continue;if(ª.Status==MyShipConnectorStatus.Connected){var w=ª.
                OtherConnector;if(w.CubeGrid==ª.CubeGrid){continue;}}if(º){if(ª.Status==MyShipConnectorStatus.Connectable)ª.Connect();}else{if(ª.
                Status==MyShipConnectorStatus.Connected)ª.Disconnect();}ª.Enabled=Â;}return;}Dictionary&lt;string,int&gt;u=new Dictionary&lt;string,int
                &gt;();string h="";UpdateFrequency q=UpdateFrequency.Once;bool p=true;bool µ=true;bool o=false;bool Ä=false;double Õ=5;
                double Ó=-1;double Ò=5;double Ñ=-1;float Ð=100;string Ï="WORLD";void Î(ȉ Í){Í.Ż(Ï,"MaxWorldMps",ref Ð,true);}string Ì=
                "WICOCRAFT";Program(){ɛ();ȉ Ë=new ȉ(this,Me.CustomData);Ë.Ż(Ì,"EchoOn",ref Ê,true);Ë.Ż(Ì,"DebugUpdate",ref o,true);Ë.Ż(Ì,
                "SubModules",ref p,true);Ë.Ż(Ì,"SubmoduleTriggerWait",ref Õ,true);É=Echo;Echo=È;Î(Ë);ò(Ë);ȡ(Ë);ĝ(Ë);ɚ(Ë);if(Ë.Ǡ){Me.CustomData=Ë.ƣ(
                true);}h=ʣ+":"+ʢ+" V"+ʡ+" ";É(h+"Creator");ɺ();ɡ("clear",ɰ,true);if(!ę(ğ)){Runtime.UpdateFrequency|=UpdateFrequency.
                Update100;}if(!Me.Enabled){Echo("I am turned OFF!");}}bool Ê=true;Action&lt;string&gt;É;void È(string Ç){if(Ê)É(Ç);}bool Æ=false;bool Å
                =false;string Ô="";int n=0;string l="";bool N=false;bool M=false;bool L=false;bool K=false;double J=5;double I=-1;double
                O=3;double H=-1;double F=-1;double E=-2;void Main(string D,UpdateType C){Echo(h+Ĕ());if(o){Echo(C.ToString()+" : "+(int)C
                );}M=false;L=false;if(I&gt;J){I=0;K=false;var B=new List&lt;IMyTerminalBlock&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyProjector
                &gt;(B,ç);for(int G=0;G&lt;B.Count;G++){if(B[G].IsWorking){if(B[G].CustomName.Contains("!WCC")||B[G].CustomData.Contains("!WCC"
                ))continue;Echo("Working local Projector found!");K=true;}}}else{if(I&lt;0){I=J+5;}I+=Runtime.TimeSinceLastRun.TotalSeconds;
                }ά="";double A=0;if(ƺ is IMyShipController){if(H&gt;O||!Æ){H=0;MyShipMass Q;Q=((IMyShipController)ƺ).CalculateShipMass();A=Q
                .BaseMass;if(A!=ə&amp;&amp;ə&gt;0){Echo("MASS CHANGE");ɡ(ʣ+":"+ʢ+":MASS CHANGE",ɰ,true);{Æ=false;Ô="";Ñ=0;}}}else{if(H&lt;0){H=O+5;}H+=
                Runtime.TimeSinceLastRun.TotalSeconds;A=ə;}}else{ə=A=-1;if(N&amp;&amp;!Å){Æ=false;Ô="";Ñ=0;}}if(Ñ&gt;Ò){Ñ=0;if(N){D="init";Echo("RESCAN!")
                ;Ñ=0;}}else{if(N){Echo("Waiting for Rescan:"+Ñ.ToString("0.0")+"("+Ò.ToString("0.0")+")");Ñ+=Runtime.TimeSinceLastRun.
                TotalSeconds;}}if((D=="init"&amp;&amp;n==0)||(Math.Abs(A-ə)&gt;1&amp;&amp;ə&gt;0&amp;&amp;n==0)){Ɏ("INIT or GRID/MASS CHANGE!");Echo(
                "Arg init or grid/mass change!");Ô="";Ñ=Ò+5;Æ=false;n=0;l="";ά="init";}Ɏ("clear");if(!Æ){if(K){Ɏ(
                "Construction in Progress\nTurn off projector to continue");ɡ("Construction in Progress\nTurn off projector to continue",ɮ);}else{}M=true;if(n==0){N=false;l="";}ɘ();if(N)M=false;
                Å=true;if(Æ){D="";Ñ=0;}}else{if(p)ˀ();ά=D;if(Å){ɡ(DateTime.Now.ToString()+" "+Ô,ɰ,true);}if(ƺ!=null){}if(ƺ is
                IMyShipController){F=((IMyShipController)ƺ).GetShipSpeed();Vector3D m=((IMyShipController)ƺ).GetNaturalGravity();double k=m.Length();E=k/
                9.81;}else{E=-1.0;}if((C&amp;(UpdateType.Trigger|UpdateType.Terminal))&gt;0||(C&amp;(UpdateType.Trigger))&gt;0||(C&amp;(UpdateType.Terminal))&gt;
                0||(C&amp;(UpdateType.Mod))&gt;0||(C&amp;(UpdateType.Script))&gt;0){if(у(D)){ϕ();ɸ();return;}}else if((C&amp;(UpdateType.Antenna))&gt;0){if(!б
                (D)){ŀ(D);}ϕ();Ļ();ɸ();return;}else{D="";}Ł();Ň();ʛ();ȸ();}if(p)ϕ();if(p){if((ΰ==null)){}else{if((C&amp;(UpdateType.Trigger|
                UpdateType.Terminal))&gt;0||(C&amp;(UpdateType.Mod))&gt;0||(C&amp;(UpdateType.Script))&gt;0||Ó&gt;Õ||Å){Ó=0;ę(Ġ);}else{Ó+=Runtime.TimeSinceLastRun.
                TotalSeconds;}}}else Echo("Submodules turned off");if(M){Echo("FAST!");Runtime.UpdateFrequency|=q;}else{Runtime.UpdateFrequency&amp;=~(q
                );}if(L){Echo("MEDIUM");Runtime.UpdateFrequency|=UpdateFrequency.Update10;}else{Runtime.UpdateFrequency&amp;=~(
                UpdateFrequency.Update10);}if(µ)Echo(ˉ());ʘ();ɸ();Å=false;}void j(string h=null){float e=0;e=Runtime.CurrentInstructionCount/(float)
                Runtime.MaxInstructionCount;if(h==null)h="Instructions=";Echo(h+(e*100).ToString("0.00")+"%");}List&lt;IMyTerminalBlock&gt;d=new List
                &lt;IMyTerminalBlock&gt;();string Z(){List&lt;IMyTerminalBlock&gt;P=new List&lt;IMyTerminalBlock&gt;();d.Clear();P=Ǐ&lt;IMyShipDrill&gt;();
                foreach(var W in P)d.Add(W as IMyTerminalBlock);return"D"+d.Count.ToString("00");}void Y(){foreach(IMyFunctionalBlock W in d){W
                .Enabled=true;}}void X(){if(d.Count&lt;1)Z();foreach(IMyFunctionalBlock W in d){W.Enabled=false;}}bool V(){if(d.Count&lt;1)Z();
                if(d.Count&lt;1)return false;return true;}List&lt;IMyTerminalBlock&gt;U=new List&lt;IMyTerminalBlock&gt;();string S(){List&lt;
                IMyTerminalBlock&gt;P=new List&lt;IMyTerminalBlock&gt;();U.Clear();P=Ǘ&lt;IMyShipConnector&gt;("Ejector");foreach(var W in P)U.Add(W as
                IMyTerminalBlock);return"E"+U.Count.ToString("00");}void â(){foreach(IMyFunctionalBlock W in U){if(!W.Enabled)W.Enabled=true;}}void ø(){
                if(U.Count&lt;1)S();foreach(IMyFunctionalBlock W in U){if(W.Enabled)W.Enabled=false;}}string ö="NOFOLLOW";string õ="!WCC";
                string ô="[NAV]";string ó="Craft Remote Control";string ù="GRIDS";void ò(ȉ Í){Í.Ż(ù,"NoFollow",ref ö,true);Í.Ż(ù,"BlockIgnore"
                ,ref õ,true);Í.Ż(ù,"OrientationBlockContains",ref ô,true);Í.Ż(ù,"OrientationBlockNamed",ref ó,true);}List&lt;
                IMyTerminalBlock&gt;ð=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTextPanel&gt;ï=new List&lt;IMyTextPanel&gt;();List&lt;IMyTextPanel&gt;î=new List&lt;IMyTextPanel&gt;(
                );List&lt;IMyTerminalBlock&gt;í=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyCubeGrid&gt;ì=new List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;ñ=new
                List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;ë=new List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;ú=new List&lt;IMyCubeGrid&gt;();bool ă(){List&lt;
                IMyTerminalBlock&gt;Ă=new List&lt;IMyTerminalBlock&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyTerminalBlock&gt;(Ă);if(ή!=Ă.Count){return true;}
                return false;}string ā(){ð.Clear();ú.Clear();ì.Clear();ñ.Clear();ë.Clear();ï.Clear();î.Clear();í.Clear();GridTerminalSystem.
                GetBlocksOfType&lt;IMyTerminalBlock&gt;(ð);ή=ð.Count;foreach(var æ in ð){var Û=æ.CubeGrid;if(!ú.Contains(Û)){ú.Add(Û);}}ü(Me.CubeGrid);
                foreach(var Û in ú){if(ì.Contains(Û))continue;bool Ā=false;List&lt;IMyShipConnector&gt;ÿ=new List&lt;IMyShipConnector&gt;();
                GridTerminalSystem.GetBlocksOfType&lt;IMyShipConnector&gt;(ÿ,(Ù=&gt;Ù.CubeGrid==Û));foreach(var þ in ÿ){if(þ.Status==MyShipConnectorStatus.
                Connected){if(ì.Contains(þ.OtherConnector.CubeGrid)||ñ.Contains(þ.OtherConnector.CubeGrid)){continue;}if(ì.Contains(þ.
                OtherConnector.CubeGrid))Ā=true;else Ā=false;}}if(Ā){if(!ë.Contains(Û)){ë.Add(Û);}}if(!ñ.Contains(Û)){ñ.Add(Û);}}string ý="";ý+="B"+ð.
                Count.ToString();ý+="G"+ú.Count.ToString();ý+="L"+ì.Count.ToString();ý+="D"+ë.Count.ToString();ý+="R"+ñ.Count.ToString();Echo
                ("Found "+ú.Count.ToString()+" Grids");Echo("Found "+ì.Count.ToString()+" Local Grids");for(int G=0;G&lt;ì.Count;G++)Echo(
                "|"+ì[G].CustomName);Echo("Found "+ë.Count.ToString()+" Docked Grids");for(int G=0;G&lt;ë.Count;G++)Echo("|"+ë[G].CustomName);
                Echo("Found "+ñ.Count.ToString()+" Remote Grids");for(int G=0;G&lt;ñ.Count;G++)Echo("|"+ñ[G].CustomName);return ý;}void ü(
                IMyCubeGrid Û){if(Û==null)return;if(!ì.Contains(Û)){ì.Add(Û);û(Û);à(Û);Ü(Û);ê(Û);}}void û(IMyCubeGrid Û){List&lt;IMyMotorStator&gt;Ú=new
                List&lt;IMyMotorStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(Ú,(ß=&gt;ß.TopGrid==Û));foreach(var Ø in Ú){if(Ø.
                CustomName.Contains(ö)||Ø.CustomData.Contains(ö))continue;ü(Ø.CubeGrid);}List&lt;IMyMotorAdvancedStator&gt;Ö=new List&lt;
                IMyMotorAdvancedStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorAdvancedStator&gt;(Ö,(ß=&gt;ß.TopGrid==Û));foreach(var Ø in Ö){if(Ø.CustomName.
                Contains(ö)||Ø.CustomData.Contains(ö))continue;ü(Ø.CubeGrid);}}void à(IMyCubeGrid Û){List&lt;IMyPistonBase&gt;á=new List&lt;IMyPistonBase
                &gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyPistonBase&gt;(á,(ß=&gt;ß.TopGrid==Û));foreach(var Ý in á){ü(Ý.CubeGrid);}}void Ü(
                IMyCubeGrid Û){List&lt;IMyMotorStator&gt;Ú=new List&lt;IMyMotorStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(Ú,(Ù=&gt;Ù.CubeGrid
                ==Û));foreach(var Ø in Ú){if(Ø.CustomName.Contains(ö)||Ø.CustomData.Contains(ö))continue;IMyCubeGrid Þ=Ø.TopGrid;if(Þ!=
                null&amp;&amp;Þ!=Û){ü(Þ);}}Ú.Clear();List&lt;IMyMotorAdvancedStator&gt;Ö=new List&lt;IMyMotorAdvancedStator&gt;();GridTerminalSystem.
                GetBlocksOfType&lt;IMyMotorAdvancedStator&gt;(Ö,(Ù=&gt;Ù.CubeGrid==Û));foreach(var Ø in Ö){if(Ø.CustomName.Contains(ö)||Ø.CustomData.Contains(ö)
                )continue;IMyCubeGrid Þ=Ø.TopGrid;if(Þ!=null&amp;&amp;Þ!=Û){ü(Þ);}}}void ê(IMyCubeGrid Û){List&lt;IMyPistonBase&gt;á=new List&lt;
                IMyPistonBase&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyPistonBase&gt;(á,(Ù=&gt;Ù.CubeGrid==Û));foreach(var Ý in á){IMyCubeGrid Þ=Ý.TopGrid;
                if(Þ!=null&amp;&amp;Þ!=Û){if(!ì.Contains(Þ)){ü(Þ);}}}}List&lt;IMyCubeGrid&gt;é(){if(ì.Count&lt;1){ā();}return ì;}List&lt;IMyCubeGrid&gt;è(){if(ì.
                Count&lt;1){ā();}return ë;}bool ç(IMyTerminalBlock æ){return é().Contains(æ.CubeGrid);}bool ä(long Ã){for(int å=0;å&lt;ì.Count;å++)
                {if((long)ì[å].EntityId==Ã)return true;}return false;}bool ä(IMyCubeGrid Ã){return é().Contains(Ã);}bool ã(
                IMyTerminalBlock æ){var ǂ=è();if(ǂ==null)return false;return ǂ.Contains(æ.CubeGrid);}void Ǔ(){if(ð.Count&lt;1)ā();í.Clear();foreach(var ǒ
                in ð){if(ç(ǒ)&amp;&amp;!(ǒ.CustomName.Contains(õ)))í.Add(ǒ);}}IMyTerminalBlock Ǒ(string ǐ){IMyTerminalBlock æ;æ=(IMyTerminalBlock)
                GridTerminalSystem.GetBlockWithName(ǐ);if(æ==null)throw new Exception(ǐ+" Not Found");return æ;}List&lt;Ƽ&gt;Ǐ&lt;Ƽ&gt;(ref List&lt;Ƽ&gt;P,string ƻ=null)
                where Ƽ:class{if(P==null)P=new List&lt;Ƽ&gt;();else P.Clear();if(í.Count&lt;1)Ǔ();for(int ƾ=0;ƾ&lt;í.Count;ƾ++){if(í[ƾ]is Ƽ&amp;&amp;((ƻ==null)||
                (ƻ!=null&amp;&amp;í[ƾ].CustomName.StartsWith(ƻ)))){P.Add((Ƽ)í[ƾ]);}}return P;}List&lt;IMyTerminalBlock&gt;Ǐ&lt;Ƽ&gt;(ref List&lt;
                IMyTerminalBlock&gt;P,string ƻ=null)where Ƽ:class{if(ð.Count&lt;1)ā();if(P==null)P=new List&lt;IMyTerminalBlock&gt;();else P.Clear();if(í.Count&lt;1)Ǔ(
                );for(int ƾ=0;ƾ&lt;í.Count;ƾ++){if(í[ƾ]is Ƽ&amp;&amp;((ƻ==null)||(ƻ!=null&amp;&amp;í[ƾ].CustomName.StartsWith(ƻ)))){P.Add(í[ƾ]);}}return P;}
                List&lt;IMyTerminalBlock&gt;Ǐ&lt;Ƽ&gt;(string ƻ=null)where Ƽ:class{var P=new List&lt;IMyTerminalBlock&gt;();Ǐ&lt;Ƽ&gt;(ref P,ƻ);return P;}List&lt;
                IMyTerminalBlock&gt;Ǘ&lt;Ƽ&gt;(string ƻ=null)where Ƽ:class{var P=new List&lt;IMyTerminalBlock&gt;();if(í.Count&lt;1)Ǔ();for(int ƾ=0;ƾ&lt;í.Count;ƾ++){if(í[ƾ]
                is Ƽ&amp;&amp;ƻ!=null&amp;&amp;(í[ƾ].CustomName.Contains(ƻ)||í[ƾ].CustomData.Contains(ƻ))){P.Add(í[ƾ]);}}return P;}List&lt;IMyTextPanel&gt;ǖ(
                string ƻ=null){if(ð.Count&lt;1)ā();var P=new List&lt;IMyTextPanel&gt;();if(ï.Count&gt;1){foreach(var ǔ in ï){if(ƻ!=null&amp;&amp;(ǔ.CustomName.
                Contains(ƻ)||ǔ.CustomData.Contains(ƻ)))P.Add(ǔ);}}else{foreach(var ǔ in ð){if(ǔ is IMyTextPanel&amp;&amp;ç(ǔ)&amp;&amp;!(ǔ.CustomName.Contains(õ
                )||ǔ.CustomData.Contains(õ))){if(ƻ!=null&amp;&amp;(ǔ.CustomName.Contains(ƻ)||ǔ.CustomData.Contains(ƻ)))P.Add(ǔ as IMyTextPanel);ï
                .Add(ǔ as IMyTextPanel);}}}return P;}List&lt;IMyTextPanel&gt;Ǖ(string ƻ=null){if(í.Count&lt;1)Ǔ();var P=new List&lt;IMyTextPanel&gt;();
                if(î.Count&gt;1){foreach(var ǔ in î){if(ƻ!=null&amp;&amp;(ǔ.CustomName.Contains(ƻ)||ǔ.CustomData.Contains(ƻ)))P.Add(ǔ);}}else{foreach
                (var ǔ in í){if(ǔ is IMyTextPanel&amp;&amp;Me.CubeGrid==ǔ.CubeGrid){if(ƻ!=null&amp;&amp;(ǔ.CustomName.Contains(ƻ)||ǔ.CustomData.Contains(
                ƻ)))P.Add(ǔ as IMyTextPanel);î.Add(ǔ as IMyTextPanel);}}}return P;}List&lt;IMyTerminalBlock&gt;ǘ&lt;Ƽ&gt;(string ƻ=null)where Ƽ:class
                {if(í.Count&lt;1)Ǔ();var P=new List&lt;IMyTerminalBlock&gt;();for(int ƾ=0;ƾ&lt;í.Count;ƾ++){if(í[ƾ]is Ƽ&amp;&amp;Me.CubeGrid==í[ƾ].CubeGrid&amp;&amp;
                ƻ!=null&amp;&amp;(í[ƾ].CustomName.Contains(ƻ)||í[ƾ].CustomData.Contains(ƻ))){P.Add(í[ƾ]);}}return P;}List&lt;IMyTerminalBlock&gt;ƽ&lt;Ƽ&gt;(
                string ƻ=null)where Ƽ:class{if(í.Count&lt;1)Ǔ();var P=new List&lt;IMyTerminalBlock&gt;();for(int ƾ=0;ƾ&lt;í.Count;ƾ++){if(í[ƾ]is Ƽ&amp;&amp;ƻ!=
                null&amp;&amp;í[ƾ].CustomName==ƻ){P.Add(í[ƾ]);}}return P;}IMyTerminalBlock ƺ=null;string ƹ(){string Ô="";var Ƹ=new List&lt;
                IMyTerminalBlock&gt;();Ǐ&lt;IMyTerminalBlock&gt;(ref Ƹ,ó);if(Ƹ.Count==0){Ƹ=Ǘ&lt;IMyRemoteControl&gt;(ô);if(Ƹ.Count==0){Ǐ&lt;IMyRemoteControl&gt;(ref Ƹ);if(Ƹ.
                Count==0){Ǐ&lt;IMyCockpit&gt;(ref Ƹ);int G=0;for(;G&lt;Ƹ.Count;G++){Echo("Checking Controller:"+Ƹ[G].CustomName);if(Ƹ[G]is
                IMyCryoChamber)continue;break;}if(G&gt;=Ƹ.Count){Ô+="!!NO valid Controller:"+G+"\n";Echo("No Controller found");}else{Ô+="S";Echo(
                "Using good ship Controller: "+Ƹ[G].CustomName);}}else{Ô+="R";Echo("Using First Remote control found: "+Ƹ[0].CustomName);}}}else{Ô+="N";Echo(
                "Using Named: "+Ƹ[0].CustomName);}if(Ƹ.Count&gt;0)ƺ=Ƹ[0];return Ô;}string Ʒ="!NAV";void ƶ(ȉ Í){Í.Ż(ù,"GyroIgnore",ref Ʒ,true);Í.Ż(ù,
                "LIMIT_GYROS",ref ǀ,true);Í.Ż(ù,"LEAVE_GYROS",ref ǎ,true);Í.Ż(ù,"CTRL_COEFF",ref Ƶ,true);}double Ƶ=0.9;int ǀ=99;int ǎ=-1;
                IMyShipController Ǎ;List&lt;IMyGyro&gt;ǌ=new List&lt;IMyGyro&gt;();float ǋ=0.01f;bool ǉ(string ǈ){if(Ǎ==null)ǹ();if(Ǎ is IMyShipController){Vector3D
                Ǌ=(Ǎ as IMyShipController).GetNaturalGravity();return ǉ(ǈ,Ǌ,ƺ);}else{Echo("No Controller for gravity");}return true;}bool
                ǉ(string ǈ,Vector3D Ǉ,IMyTerminalBlock ǆ){bool ǅ=true;if(Ǎ==null)ǹ();Matrix Ǆ;ǆ.Orientation.GetMatrix(out Ǆ);Vector3D ǃ;ǈ
                =ǈ.ToLower();if(ǈ.Contains("rocket"))ǃ=Ǆ.Backward;else if(ǈ.Contains("up"))ǃ=Ǆ.Up;else if(ǈ.Contains("backward"))ǃ=Ǆ.
                Backward;else if(ǈ.Contains("forward"))ǃ=Ǆ.Forward;else if(ǈ.Contains("right"))ǃ=Ǆ.Right;else if(ǈ.Contains("left"))ǃ=Ǆ.Left;
                else ǃ=Ǆ.Down;Ǉ.Normalize();for(int å=0;å&lt;ǌ.Count;++å){var ǂ=ǌ[å];ǂ.Orientation.GetMatrix(out Ǆ);var ƿ=Vector3D.Transform(ǃ,
                MatrixD.Transpose(Ǆ));var ǁ=Vector3D.Transform(Ǉ,MatrixD.Transpose(ǂ.WorldMatrix.GetOrientation()));var Ǚ=Vector3D.Cross(ƿ,ǁ);
                double ȁ=Vector3D.Dot(ƿ,ǁ);double ǿ=Ǚ.Length();ǿ=Math.Atan2(ǿ,Math.Sqrt(Math.Max(0.0,1.0-ǿ*ǿ)));if(ȁ&lt;0)ǿ=Math.PI-ǿ;if(ǿ&lt;ǋ){ǂ.
                GyroOverride=false;continue;}float Ǿ=(float)(2*Math.PI);double ǽ=Ǿ*(ǿ/Math.PI)*Ƶ;ǽ=Math.Min(Ǿ,ǽ);ǽ=Math.Max(0.01,ǽ);Ǚ.Normalize();Ǚ
                *=ǽ;float Ǽ=-(float)Ǚ.X;ǂ.Pitch=Ǽ;float ǻ=-(float)Ǚ.Y;ǂ.Yaw=ǻ;float Ǻ=-(float)Ǚ.Z;ǂ.Roll=Ǻ;ǂ.GyroOverride=true;ǅ=false;}
                return ǅ;}string ǹ(){string ý="";var Ǹ=new List&lt;IMyTerminalBlock&gt;();Ǎ=ƺ as IMyShipController;ǌ.Clear();if(Ǎ==null){if(Ǹ.Count&lt;
                1)return"No RC!";}ǵ();GridTerminalSystem.GetBlocksOfType&lt;IMyGyro&gt;(Ǹ,ß=&gt;ß.CubeGrid==ƺ.CubeGrid);int Ƿ=0;for(int å=0;å&lt;Ǹ.
                Count;å++){if(Ǹ[å].CustomName.Contains(Ʒ)||Ǹ[å].CustomData.Contains(Ʒ)){Ƿ++;continue;}ǌ.Add(Ǹ[å]as IMyGyro);}if(ǀ&gt;0){if(ǌ.
                Count&gt;ǀ){ǌ.RemoveRange(ǀ,ǌ.Count-ǀ);}else{if((ǎ-Ƿ)&gt;0){int Ƕ=ǌ.Count-(ǎ-Ƿ);ǌ.RemoveRange(Ƕ,(ǎ-Ƿ));}}}ǵ();ý+="GYRO#"+ǌ.Count.
                ToString("00")+"#";return ý;}void ǵ(){if(ǌ!=null){for(int å=0;å&lt;ǌ.Count;++å){ǌ[å].GyroOverride=false;ǌ[å].Enabled=true;}}}bool Ȁ
                (Vector3D Ȃ,Vector3D ȑ,IMyTerminalBlock Ȓ){bool Ȑ=false;Vector3D ȏ=(ȑ-Ȃ);Vector3D Ȏ;if(Ȓ is IMyShipController){Ȏ=((
                IMyShipController)Ȓ).CenterOfMass;}else{Ȏ=Ȓ.GetPosition();}Vector3D ȍ=(ȑ-Ȏ);Vector3D Ȍ=Ȋ(ȏ,ȍ);Vector3D ȋ=(ȑ-Ȍ*2)-Ȏ;Ȑ=ǉ("forward",ȋ,Ȓ);
                return Ȑ;}Vector3D Ȋ(Vector3D ů,Vector3D W){if(Vector3D.IsZero(W))return Vector3D.Zero;return ů-ů.Dot(W)/W.LengthSquared()*W;}
                class ȉ{char Ȉ='[';char ȇ=']';string Ȇ=";";string ȅ="";public bool Ȅ=false;public string ȃ="";string Ǵ="---";char Ǩ='|';
                private MyGridProgram ǲ;private Dictionary&lt;string,string&gt;Ǧ;private Dictionary&lt;string,string[]&gt;ǥ;private Dictionary&lt;string,
                Dictionary&lt;string,string&gt;&gt;Ǥ;private string ǣ="";static string[]Ǣ={"true","yes","on","1"};const StringComparison ǡ=StringComparison
                .OrdinalIgnoreCase;const char ǧ='=';public bool Ǡ{get;private set;}=false;public ȉ(MyGridProgram Ǟ,string ǜ){ǲ=Ǟ;Ǧ=new
                Dictionary&lt;string,string&gt;();ǥ=new Dictionary&lt;string,string[]&gt;();Ǥ=new Dictionary&lt;string,Dictionary&lt;string,string&gt;&gt;();ǝ(ǜ);}public
                int ǝ(string ǜ){ǜ.TrimEnd();if(ǣ==ǜ){return Ǧ.Count;}Ǧ.Clear();ǥ.Clear();Ǥ.Clear();ȅ="";ȃ="";Ǡ=false;ǣ=ǜ;string[]Ǜ=ǜ.Split(
                '\n');for(int ǟ=0;ǟ&lt;Ǜ.Count();ǟ++){string ǚ="";Ǜ[ǟ].Trim();if(Ǜ[ǟ].StartsWith(Ȉ.ToString())){string ǩ="";for(int ǳ=1;ǳ&lt;Ǜ[ǟ].
                Length;ǳ++)if(Ǜ[ǟ][ǳ]==ȇ)break;else ǩ+=Ǜ[ǟ][ǳ];if(ǩ!=""){ǚ=ǩ.ToUpper();}else continue;ǟ++;string ơ="";var Ǳ=new string[Ǜ.Count
                ()-ǟ];int ǰ=0;var ž=new Dictionary&lt;string,string&gt;();for(;ǟ&lt;Ǜ.Count();ǟ++){Ǜ[ǟ].Trim();if(Ǜ[ǟ].StartsWith(Ȉ.ToString())||Ǜ
                [ǟ].StartsWith(Ǵ)){ǟ--;break;}ơ+=Ǜ[ǟ]+"\n";Ǳ[ǰ++]=Ǜ[ǟ];if(Ǜ[ǟ].Contains(ǧ)){string[]ǯ=Ǜ[ǟ].Split('=');if(ǯ.Count()&gt;1){
                string ű=ǯ[0];string Ǯ="";for(int å=1;å&lt;ǯ.Count();å++){Ǯ+=ǯ[å];if(å+1&lt;ǯ.Count())Ǯ+=ǧ;}if(Ǯ==""){int ǭ=ǟ+1;for(;ǭ&lt;ǯ.Count();ǭ++
                ){Ǜ[ǭ].Trim();if(Ǜ[ǭ].Length&gt;1&amp;&amp;Ǜ[ǭ][0]==Ǩ){Ǯ+=Ǜ[ǭ].Substring(1).Trim()+"\n";break;}}ǟ=ǭ;}ž.Add(ű,Ǯ);}}else if(Ǜ[ǟ].
                StartsWith(Ȇ)){}}if(!Ǥ.ContainsKey(ǚ)){Ǥ.Add(ǚ,ž);if(!ǥ.ContainsKey(ǚ))ǥ.Add(ǚ,Ǳ);}else{}if(!Ǧ.ContainsKey(ǚ)){Ǧ.Add(ǚ,ơ);}else{Ǡ=
                true;}}else if(Ǜ[ǟ].StartsWith(Ǵ)){ǟ++;for(;ǟ&lt;Ǜ.Count();ǟ++){ȃ+=Ǜ[ǟ];}}else{ȅ+=Ǜ[ǟ]+"\n";}}return Ǧ.Count;}public string Ǭ(
                string ŷ){string ơ="";if(Ǧ.ContainsKey(ŷ))ơ=Ǧ[ŷ];return ơ;}public string[]ǫ(string ŷ){string[]Ǫ={""};if(ǥ.ContainsKey(ŷ))Ǫ=ǥ[ŷ
                ];return Ǫ;}public bool Ż(string ŷ,string ű,ref string ż,bool ŵ=false){ŷ=ŷ.ToUpper();if(Ǥ.ContainsKey(ŷ)){var ſ=Ǥ[ŷ];if(ſ
                .ContainsKey(ű)){ż=ſ[ű];return true;}}if(ŵ)Ų(ŷ,ű,ż);return false;}public bool Ż(string ŷ,string ű,ref long Ɓ,bool ŵ=false
                ){string Ŵ="";if(!Ż(ŷ,ű,ref Ŵ)){if(ŵ){Ų(ŷ,ű,Ɓ);}return false;}Ɓ=Convert.ToInt64(Ŵ);return true;}public bool Ż(string ŷ,
                string ű,ref int ƀ,bool ŵ=false){string Ŵ="";if(!Ż(ŷ,ű,ref Ŵ)){if(ŵ){Ų(ŷ,ű,ƀ);}return false;}ƀ=Convert.ToInt32(Ŵ);return true;
                }public bool Ż(string ŷ,string ű,ref double ƅ,bool ŵ=false){string Ŵ="";if(!Ż(ŷ,ű,ref Ŵ)){if(ŵ){Ų(ŷ,ű,ƅ);}return false;}
                bool ƃ=double.TryParse(Ŵ,out ƅ);return true;}public bool Ż(string ŷ,string ű,ref float Ƅ,bool ŵ=false){string Ŵ="";if(!Ż(ŷ,ű
                ,ref Ŵ)){if(ŵ){Ų(ŷ,ű,Ƅ.ToString());}return false;}bool ƃ=float.TryParse(Ŵ,out Ƅ);return true;}public bool Ż(string ŷ,
                string ű,ref DateTime Ƃ,bool ŵ=false){string Ŵ="";if(!Ż(ŷ,ű,ref Ŵ)){if(ŵ){Ų(ŷ,ű,Ƃ);}return false;}Ƃ=DateTime.Parse(Ŵ);return
                true;}public bool Ż(string ŷ,string ű,ref Vector3D ź,bool ŵ=false){string Ŵ="";if(!Ż(ŷ,ű,ref Ŵ)){if(ŵ){Ų(ŷ,ű,ź);}return
                false;}double Ù,Ź,Ÿ;Ư(Ŵ,out Ù,out Ź,out Ÿ);ź.X=Ù;ź.Y=Ź;ź.Z=Ÿ;return true;}public bool Ż(string ŷ,string ű,ref bool Ŷ,bool ŵ=
                false){string Ŵ="";if(!Ż(ŷ,ű,ref Ŵ)){if(ŵ){Ų(ŷ,ű,Ŷ);}return false;}Ŷ=Ǣ.Any(ų=&gt;string.Equals(Ŵ,ų,ǡ));return true;}public bool
                Ų(string ŷ,string ű,string Ŵ){if(Ǧ.ContainsKey(ŷ)){Ǧ[ŷ]="";}else{Ǧ.Add(ŷ,"");Ǡ=true;}if(Ǥ.ContainsKey(ŷ)){var ž=new
                Dictionary&lt;string,string&gt;();var ſ=Ǥ[ŷ];if(ſ.ContainsKey(ű)){if(ſ[ű]==Ŵ)return false;ſ[ű]=Ŵ;}else{ſ.Add(ű,Ŵ);}Ǡ=true;}else{var ž=
                new Dictionary&lt;string,string&gt;();ž.Add(ű,Ŵ);Ǥ.Add(ŷ,ž);Ǡ=true;}return true;}public bool Ų(string ŷ,string ű,Vector3D ź){Ų(ŷ,
                ű,Ƨ(ź));return true;}public bool Ų(string ŷ,string ű,bool Ŷ){Ų(ŷ,ű,Ŷ.ToString());return true;}public bool Ų(string ŷ,
                string ű,int Ž){Ų(ŷ,ű,Ž.ToString());return true;}public bool Ų(string ŷ,string ű,long Ɣ){Ų(ŷ,ű,Ɣ.ToString());return true;}
                public bool Ų(string ŷ,string ű,DateTime Ƃ){Ų(ŷ,ű,Ƃ.ToString());return true;}public bool Ų(string ŷ,string ű,float Ƅ){Ų(ŷ,ű,Ƅ.
                ToString());return true;}public bool Ų(string ŷ,string ű,double ƅ){Ų(ŷ,ű,ƅ.ToString());return true;}public void Ƣ(string ŷ,
                string ơ){ơ.TrimEnd();ŷ=ŷ.ToUpper();if(Ǧ.ContainsKey(ŷ)){if(Ǧ[ŷ]!=ơ){Ǧ[ŷ]=ơ;Ǡ=true;}}else{Ǡ=true;Ǧ.Add(ŷ,ơ);}}public string ƣ(
                bool Ơ=true){string Ƥ="";string ƴ=ȅ.Trim();if(Ȅ&amp;&amp;ƴ!="")Ƥ=ƴ+"\n";foreach(var Ʋ in Ǧ){Ƥ+=Ȉ+Ʋ.Key.Trim()+ȇ+"\n";if(Ʋ.Value.
                TrimEnd()==""){string Ʊ="";if(Ǥ.ContainsKey(Ʋ.Key)){foreach(var ư in Ǥ[Ʋ.Key]){Ʊ+=ư.Key+ǧ+ư.Value+"\n";}}Ʊ+="\n";Ƥ+=Ʊ;}else{Ƥ+=
                Ʋ.Value.Trim()+"\n\n";}}if(ȃ!=""){Ƥ+="\n"+Ǵ+"\n";Ƥ+=ȃ+"\n";}if(Ơ){Ǡ=false;ǣ=Ƥ;}return Ƥ;}bool Ư(string Ʈ,out double ß,out
                double ƭ,out double Ƭ){string[]ƫ=Ʈ.Trim().Split(',');if(ƫ.Length&lt;3){ƫ=Ʈ.Trim().Split(':');}ß=0;ƭ=0;Ƭ=0;if(ƫ.Length&lt;3)return
                false;bool ƪ=double.TryParse(ƫ[0].Trim(),out ß);bool Ʃ=double.TryParse(ƫ[1].Trim(),out ƭ);bool ƨ=double.TryParse(ƫ[2].Trim(),
                out Ƭ);if(!ƪ||!Ʃ||!ƨ){return false;}return true;}string Ƨ(Vector3D Ʀ){string ý;ý=Ʀ.X.ToString("0.00")+":"+Ʀ.Y.ToString(
                "0.00")+":"+Ʀ.Z.ToString("0.00");return ý;}}int ƥ=80;int Ƴ=20;double Ɵ=0;string ƞ="POWER";void ƒ(ȉ Í){Í.Ż(ƞ,"batterypcthigh",
                ref ƥ,true);Í.Ż(ƞ,"batterypctlow",ref Ƴ,true);}void Ƒ(){Ɵ=0;Echo("Init Reactors");Ю();Echo("Init Solar");η();Echo(
                "Init Batteries");ʓ();if(а&gt;0)Ɵ+=а;if(ʫ&gt;0)Ɵ+=ʫ;}List&lt;IMyTerminalBlock&gt;Ɛ=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;Ə=new List&lt;
                IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;Ǝ=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;Ɠ=new List&lt;IMyTerminalBlock&gt;();List&lt;
                IMyTerminalBlock&gt;ƍ=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;Ƌ=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;Ɗ=new List&lt;
                IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;Ɖ=new List&lt;IMyTerminalBlock&gt;();string ƈ(IMyTerminalBlock Ƈ){Ɛ.Clear();Ə.Clear();Ǝ.Clear();Ɠ.
                Clear();ƍ.Clear();Ƌ.Clear();Ɗ.Clear();Ɖ.Clear();Ǐ&lt;IMyMotorSuspension&gt;(ref Ɛ);for(int G=0;G&lt;Ɛ.Count;G++){if(Ɛ[G].CustomName.
                Contains("[SLED]")||Ɛ[G].CustomData.Contains("[SLED]")){Ə.Add(Ɛ[G]);if(Ɛ[G].CustomName.Contains("[REAR]")||Ɛ[G].CustomData.
                Contains("[FRONT]")){Ǝ.Add(Ɛ[G]);}if(Ɛ[G].CustomName.Contains("[FRONT]")||Ɛ[G].CustomData.Contains("[FRONT]")){Ɠ.Add(Ɛ[G]);}}
                else{if(Ɛ[G].CustomName.Contains("[LEFT]")||Ɛ[G].CustomData.Contains("[LEFT]")){Ɗ.Add(Ɛ[G]);}else if(Ɛ[G].CustomName.
                Contains("[RIGHT]")||Ɛ[G].CustomData.Contains("[RIGHT]")){Ɖ.Add(Ɛ[G]);}if(Ɛ[G].CustomName.Contains("[REAR]")||Ɛ[G].CustomData.
                Contains("[FRONT]")){ƍ.Add(Ɛ[G]);}if(Ɛ[G].CustomName.Contains("[FRONT]")||Ɛ[G].CustomData.Contains("[FRONT]")){Ƌ.Add(Ɛ[G]);}}}
                return"W"+Ɛ.Count.ToString("0")+"WS"+Ə.Count.ToString("0")+"SR"+Ǝ.Count.ToString("0")+"SF"+Ɠ.Count.ToString("0");}bool ƌ(){if(
                Ə.Count&gt;0)return true;return false;}void Ɔ(){foreach(var Į in Ə){var ƕ=Į as IMyMotorSuspension;ƕ.SetValueFloat("Friction"
                ,0);}}bool Ɲ(){if(Ɛ.Count&gt;0){return true;}return false;}bool Ɯ(float ƛ,float Ɩ=-1){Echo("WPP:"+ƛ.ToString()+":"+Ɩ.
                ToString());bool ƚ=true;if(ƛ&lt;0f)ƛ=0f;if(ƛ&gt;100f)ƛ=100f;foreach(var Į in Ɖ){var ƕ=Į as IMyMotorSuspension;float ƙ=ƕ.GetValueFloat(
                "Propulsion override");Echo("CPower:"+ƙ.ToString("0.00")+"\n"+ƕ.CustomName);float Ƙ=(ƙ);Ƙ=Math.Abs(Ƙ);if(Ƙ&lt;1)Ƙ*=100f;if(ƛ&gt;(Ƙ+5f)){ƚ=false;Ƙ+=
                5;}else if(ƛ&lt;(Ƙ-5)){ƚ=false;Ƙ-=5;}else Ƙ=ƛ;if(Ɩ&gt;=0)ƕ.SetValueFloat("Friction",Ɩ);Echo("Setting override to"+Ƙ.ToString(
                "0.000"));ƕ.SetValueFloat("Propulsion override",-Ƙ);}foreach(var Į in Ɗ){var ƕ=Į as IMyMotorSuspension;float ƙ=ƕ.GetValueFloat(
                "Propulsion override");Echo("CPower:"+ƙ.ToString("0.00")+"\n"+ƕ.CustomName);float Ƙ=(ƙ);Ƙ=Math.Abs(Ƙ);if(Ƙ&lt;1)Ƙ*=100f;if(ƛ&gt;(Ƙ+5f)){ƚ=false;Ƙ+=
                5;}else if(ƛ&lt;(Ƙ-5)){ƚ=false;Ƙ-=5;}else Ƙ=ƛ;if(Ɩ&gt;=0)ƕ.SetValueFloat("Friction",Ɩ);Echo("Setting override to"+(Ƙ).ToString(
                "0.000"));ƕ.SetValueFloat("Propulsion override",Ƙ);}return ƚ;}void Ɨ(float Ɩ){foreach(var Į in Ɛ){var ƕ=Į as IMyMotorSuspension
                ;ƕ.SetValueFloat("Friction",Ɩ);}}
              </Program>
              <Storage />
              <DefaultRunArgument>idle</DefaultRunArgument>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="3" y="6" z="-2" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="5" z="5" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="5" z="5" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="5" z="5" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockLargeAtmosphericThrust</SubtypeName>
              <EntityId>141400536895712093</EntityId>
              <Min x="-1" y="3" z="6" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Large Atmospheric Thruster</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-2" y="5" z="7" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="5" z="9" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="2" y="5" z="7" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="-2" y="4" z="-2" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="2" y="6" z="-2" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_BatteryBlock">
              <SubtypeName>SmallBlockBatteryBlock</SubtypeName>
              <EntityId>101212258228453630</EntityId>
              <Min x="-3" y="4" z="0" />
              <BlockOrientation Forward="Forward" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Battery 2</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <CurrentStoredPower>1</CurrentStoredPower>
              <ProducerEnabled>true</ProducerEnabled>
              <MaxStoredPower>0</MaxStoredPower>
              <SemiautoEnabled>false</SemiautoEnabled>
              <OnlyDischargeEnabled>false</OnlyDischargeEnabled>
              <ChargeMode>0</ChargeMode>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_TimerBlock">
              <SubtypeName>TimerBlockSmall</SubtypeName>
              <EntityId>114090973177137165</EntityId>
              <Min x="0" y="5" z="-2" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
              <BuiltBy>144115188075855897</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyModStorageComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_ModStorageComponent">
                      <Storage>
                        <dictionary>
                          <item>
                            <Key>74de02b3-27f9-4960-b1c4-27351f2b06d1</Key>
                            <Value />
                          </item>
                        </dictionary>
                      </Storage>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Timer Block [WCCS]</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Toolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots>
                  <Slot>
                    <Index>0</Index>
                    <Item />
                    <Data xsi:type="MyObjectBuilder_ToolbarItemTerminalBlock">
                      <Action>Run</Action>
                      <Parameters>
                        <MyObjectBuilder_ToolbarItemActionParameter>
                          <TypeCode>String</TypeCode>
                          <Value>wccs</Value>
                        </MyObjectBuilder_ToolbarItemActionParameter>
                      </Parameters>
                      <BlockEntityId>88785049293218644</BlockEntityId>
                    </Data>
                  </Slot>
                </Slots>
              </Toolbar>
              <Delay>10000</Delay>
              <CurrentTime>0</CurrentTime>
              <IsCountingDown>false</IsCountingDown>
              <Silent>false</Silent>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_BatteryBlock">
              <SubtypeName>SmallBlockBatteryBlock</SubtypeName>
              <EntityId>122022343638020635</EntityId>
              <Min x="2" y="4" z="0" />
              <BlockOrientation Forward="Forward" Up="Right" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Battery 3</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <CurrentStoredPower>1</CurrentStoredPower>
              <ProducerEnabled>true</ProducerEnabled>
              <MaxStoredPower>0</MaxStoredPower>
              <SemiautoEnabled>false</SemiautoEnabled>
              <OnlyDischargeEnabled>false</OnlyDischargeEnabled>
              <ChargeMode>0</ChargeMode>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="4" z="-3" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="4" z="-2" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-3" y="5" z="-2" />
              <BlockOrientation Forward="Right" Up="Backward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="3" y="5" z="-2" />
              <BlockOrientation Forward="Left" Up="Backward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="5" z="6" />
              <BlockOrientation Forward="Backward" Up="Right" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="5" z="8" />
              <BlockOrientation Forward="Forward" Up="Right" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="2" y="5" z="5" />
              <BlockOrientation Forward="Backward" Up="Right" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="5" z="-2" />
              <BlockOrientation Forward="Right" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="2" y="5" z="9" />
              <BlockOrientation Forward="Forward" Up="Right" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="5" z="9" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="5" z="6" />
              <BlockOrientation Forward="Backward" Up="Left" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-2" y="5" z="5" />
              <BlockOrientation Forward="Backward" Up="Left" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="5" z="8" />
              <BlockOrientation Forward="Forward" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-2" y="5" z="9" />
              <BlockOrientation Forward="Forward" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="5" z="9" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="6" z="-3" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>124861736867901250</EntityId>
              <Min x="-3" y="5" z="6" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Atmospheric Thrusters B</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>74546073693924671</EntityId>
              <Min x="3" y="5" z="6" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Atmospheric Thrusters A</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="5" z="-2" />
              <BlockOrientation Forward="Left" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="6" z="-3" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="-3" y="6" z="-2" />
              <BlockOrientation Forward="Right" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_MyProgrammableBlock">
              <SubtypeName>SmallProgrammableBlock</SubtypeName>
              <EntityId>88785049293218644</EntityId>
              <Min x="1" y="5" z="-2" />
              <BlockOrientation Forward="Left" Up="Backward" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
              <BuiltBy>144115188075855897</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyModStorageComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_ModStorageComponent">
                      <Storage>
                        <dictionary>
                          <item>
                            <Key>74de02b3-27f9-4960-b1c4-27351f2b06d1</Key>
                            <Value>
                              [WORLD]
                              MaxWorldMps=100

                              [GRIDS]
                              NoFollow=NOFOLLOW
                              BlockIgnore=!WCC
                              OrientationBlockContains=[NAV]
                              OrientationBlockNamed=Craft Remote Control
                              GyroIgnore=!NAV
                              LIMIT_GYROS=3
                              LEAVE_GYROS=-1
                              CTRL_COEFF=0.3

                              [LOGGING]
                              TextPanelReport=Craft Report
                              StatusName=Wico Craft Status
                              LongStatus=Wico Craft Log
                              RangeReport=[RANGE]
                              SledReport=[SMREPORT]
                              GPSTag=[GPS]

                              [CONNECTORS]
                              BaseConnector=[BASE]
                              DockConnector=[DOCK]

                              [CAMERAS]
                              CameraViewOnly=[VIEW]

                              [NAV]
                              DTMDebug=False
                              CameraCollision=False
                              SensorCollision=False
                              NAVEmulateOld=True
                              NAVGravityMinElevation=25
                              NavBeaconDebug=False

                              [WICO CRAFT]
                              EchoOn=True

                            </Value>
                          </item>
                        </dictionary>
                      </Storage>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>PB Wico Craft NAV</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Program>
                /* Wico Craft NAV Control sub-module
                *
                * Commands:
                * XXX
                *
                *
                *
                * Handles MODES:
                * MODE_DOCKED
                * MODE_LAUNCH
                * MODE_RELAUNCH
                * MODE_SLEDMOVE
                * MODE_ARRIVEDTARGET
                *
                *
                *
                * 2.0.4 Upate to new save format
                *  .04A Camera Scans for Obstacles...!!!one
                *
                *  2.1 Use new blockInint and localgrids
                *
                *  .1g Add Docked
                *  copy from SLED PATROL
                *  .1h fixed yaw only gyromain
                *  .1i tested in space. Added !NAV to gyro check
                *  .1j add doroll
                *  .1k use (and fix/test) IMyGyroControl
                2.2: Update for 1.72

                2.9 Copy from Sled Dock 2.2

                Needs LOTS of updates.

                3.0 Move code into 3.0

                3.0A Start NAV processing: W and O
                3.0B Add D, S, C
                3.0C Add arrivedtarget

                3.0D 110517  search order for text panels

                3.1 Version for PB Updates SE 1.185
                o Added support for GPS-formatted nav locations
                Ex:  W GPS:Wicorel #1:53970.01:128270.31:-123354.92:

                3.1a
                remove blockApplyActions() and make routines for each block type that needs it

                3.2 Collision Avoidance from Docking module for thruster travel

                Added Rotors

                3.2A travelmovement calculating target speeds and distances with more precision

                3.2B Sled Testing

                3.2C INI Save
                fix bug in serialize wrting z,y z, instead of x,y,z (oops)

                3.2D INI WCCM 01062018

                3.2E Major INI settings

                3.3 Lists of text panels
                Only output to textpanels and end of run

                3.3A Redo Serialize

                3.4 Sled testing
                (EFM Update 8 Drones)

                3.4a Save NAV settings so nav can properly resume
                (EFM Update 9 Drones)

                3.4B

                3.4C AvionicsGyro fixes (terminal properties changed units)
                Fix for bug in SE wheel setter for friction
                Add Gyro limits to CustomData
                (EFM Update 11 wheeled Drones)

                3.4D Air unit NAV changes
                terrain auto-follow
                alignment in gravity
                (EFM Update 11 Air unit drones)

                * TODO:
                */

                string a="Wico Craft";string b="NAV";string c="3.4D";const string d="0.00";void e(oo f){gt(f);}void g(oo
                f){gs(f);}void h(){}void i(){iR();}void j(bool k=false){ka(iT);on();gJ(gy);gJ(gz);if(nO is IMyRemoteControl)
                ((IMyRemoteControl)nO).SetAutoPilotEnabled(false);if(nO is IMyShipController)((IMyShipController)nO).DampenersOverride
                =true;}m l=new m();class m{public const Base6Directions.Direction n=Base6Directions.Direction.Forward;
                public const Base6Directions.Direction o=Base6Directions.Direction.Backward;public const Base6Directions.Direction
                p=Base6Directions.Direction.Left;public const Base6Directions.Direction q=Base6Directions.Direction.Right;
                public const Base6Directions.Direction Up=Base6Directions.Direction.Up;public const Base6Directions.Direction
                r=Base6Directions.Direction.Down;public float s=30.0f;public List&lt;IMyGyro&gt;t=new List&lt;IMyGyro&gt;();Base6Directions.Direction
                u=Up;Base6Directions.Direction v=p;Base6Directions.Direction w=n;Base6Directions.Direction x=Up;Base6Directions.Direction
                y=p;Base6Directions.Direction z=n;public void A(List&lt;IMyTerminalBlock&gt;B){t=B.ConvertAll(x=&gt;(IMyGyro)x);
                if(t.Count&gt;0)s=t[0].GetMaximum&lt;float&gt;("Yaw");}public void A(List&lt;IMyGyro&gt;B){t.Clear();if(B==null)return;
                t=B;if(t.Count&gt;0)s=t[0].GetMaximum&lt;float&gt;("Yaw");}public void A(IMyProgrammableBlock PB,IMyGridTerminalSystem
                C){t.Clear();if((C!=null)&amp;&amp;(PB!=null))C.GetBlocksOfType&lt;IMyGyro&gt;(t,x=&gt;((x.CubeGrid==PB.CubeGrid)&amp;&amp;x.IsFunctional));
                if(t.Count&gt;0)s=t[0].GetMaximum&lt;float&gt;("Yaw");}public void D(IMyTerminalBlock E,Base6Directions.Direction
                F=n,Base6Directions.Direction G=Up){if(Base6Directions.GetAxis(F)==Base6Directions.GetAxis(G))G=Base6Directions.GetPerpendicular(F);
                if(E==null){}else{Vector3 H=Base6Directions.GetVector(F);Vector3.TransformNormal(ref H,E.Orientation,
                out H);F=Base6Directions.GetDirection(ref H);H=Base6Directions.GetVector(G);Vector3.TransformNormal(ref
                H,E.Orientation,out H);G=Base6Directions.GetDirection(ref H);}x=G;z=F;y=Base6Directions.GetLeft(x,z);
                }public void I(bool J){for(int i=0;i&lt;t.Count;i++){t[i].GyroOverride=J;}}public void I(int K,bool J){
                if(K&lt;t.Count){t[K].GyroOverride=J;}}public void L(float M){for(int i=0;i&lt;t.Count;i++){t[i].GyroPower
                =M;}}public void L(int K,float M){if(K&lt;t.Count){t[K].GyroPower=M;}}public void N(bool O){for(int i=0;
                i&lt;t.Count;i++){t[i].Enabled=O;}}public void N(int K,bool O){if(K&lt;t.Count){t[K].Enabled=O;}}public void
                P(bool Q){for(int i=0;i&lt;t.Count;i++){t[i].ShowOnHUD=Q;}}public void P(int K,bool Q){if(K&lt;t.Count){t[K].ShowOnHUD
                =Q;}}void R(Base6Directions.Direction S,out string T,out float U){T="Yaw";U=-1.0f;if(Base6Directions.GetAxis(u)
                ==Base6Directions.GetAxis(S)){if(u==S)U=1.0f;}if(Base6Directions.GetAxis(v)==Base6Directions.GetAxis(S))
                {T="Pitch";if(v==S)U=1.0f;}if(Base6Directions.GetAxis(w)==Base6Directions.GetAxis(S)){T="Roll";if(w==
                S){}else U=1.0f;}}public void V(IMyGyro K,string T,float J){if(T=="Yaw"){K.Yaw=J;}else if(T=="Pitch")
                {K.Pitch=J;}else{K.Roll=J;}}public void W(float X){for(int i=0;i&lt;t.Count;i++){string T;float U;Vector3
                H=Base6Directions.GetVector(Up);Vector3.TransformNormal(ref H,t[i].Orientation,out H);u=Base6Directions.GetDirection(ref
                H);R(x,out T,out U);V(t[i],T,U*X);}}public void Y(float Z){for(int i=0;i&lt;t.Count;i++){string T;float
                U;Vector3 H=Base6Directions.GetVector(p);Vector3.TransformNormal(ref H,t[i].Orientation,out H);v=Base6Directions.GetDirection(ref
                H);R(y,out T,out U);V(t[i],T,U*Z);}}public void ba(float bb){for(int i=0;i&lt;t.Count;i++){string T;float
                U;Vector3 H=Base6Directions.GetVector(n);Vector3.TransformNormal(ref H,t[i].Orientation,out H);w=Base6Directions.GetDirection(ref
                H);R(z,out T,out U);V(t[i],T,U*bb);}}public void bc(float X,float Z,float bb){for(int i=0;i&lt;t.Count;
                i++){string T;float U;Vector3 H=Base6Directions.GetVector(n);Vector3.TransformNormal(ref H,t[i].Orientation,
                out H);w=Base6Directions.GetDirection(ref H);H=Base6Directions.GetVector(p);Vector3.TransformNormal(ref
                H,t[i].Orientation,out H);v=Base6Directions.GetDirection(ref H);H=Base6Directions.GetVector(Up);Vector3.TransformNormal(ref
                H,t[i].Orientation,out H);u=Base6Directions.GetDirection(ref H);R(x,out T,out U);V(t[i],T,U*X);R(y,out
                T,out U);V(t[i],T,U*Z);R(z,out T,out U);V(t[i],T,U*bb);}}}double bd(Vector3D be,IMyTerminalBlock bf)
                {double bg=0;bool bh=false;MatrixD bi=by(bf);Vector3D bj=bf.GetPosition();Vector3D bk=bj+1.0*Vector3D.Normalize(bi.Backward);
                Vector3D bl=bj+1.0*Vector3D.Normalize(bi.Right);Vector3D bm=bj-1.0*Vector3D.Normalize(bi.Right);double
                bn=bs(bl,be);double bo=bs(bm,be);double bp=bs(bl,bm);double bq=Vector3D.DistanceSquared(bj,be);double
                br=Vector3D.DistanceSquared(bk,be);bh=bq&lt;br;bg=(bo-bn)/bp;Echo("calc Angle="+Math.Round(bg,5));if(!bh)
                {bg+=(bg&lt;0)?-1:1;}return bg;}double bs(Vector3D a,Vector3D b){return Vector3D.Distance(a,b);}MatrixD
                bt(IMyCubeGrid bu){Vector3D bv=bu.GridIntegerToWorld(new Vector3I(0,0,0));Vector3D bw=bu.GridIntegerToWorld(new
                Vector3I(0,1,0))-bv;Vector3D bx=bu.GridIntegerToWorld(new Vector3I(0,0,1))-bv;return MatrixD.CreateScale(bu.GridSize)
                *MatrixD.CreateWorld(bv,-bx,bw);}MatrixD by(IMyCubeBlock blk){Matrix bA;blk.Orientation.GetMatrix(out
                bA);return bA*MatrixD.CreateTranslation(((Vector3D)new Vector3D(blk.Min+blk.Max))/2.0)*bt(blk.CubeGrid);
                }bool bB(double bC,string bD="Roll",float bE=-1,float bF=1f){float bG=0;IMyGyro K=nX[0]as IMyGyro;float
                bH=K.GetMaximum&lt;float&gt;(bD);if(bE&gt;0)bH=bE;if(Math.Abs(bC)&gt;1.0){bG=bH*(float)(bC)*bF;}else if(Math.Abs(bC)
                &gt;.7){bG=bH*(float)(bC)/4;}else if(Math.Abs(bC)&gt;0.5){bG=0.11f*Math.Sign(bC);}else if(Math.Abs(bC)&gt;0.1)
                {bG=0.11f*Math.Sign(bC);}else if(Math.Abs(bC)&gt;0.01){bG=0.11f*Math.Sign(bC);}else if(Math.Abs(bC)&gt;0.001)
                {bG=0.09f*Math.Sign(bC);}else bG=0;l.W(bG);if(Math.Abs(bC)&lt;nY){l.I(false);}else{l.I(true);l.N(true);
                return false;}return true;}void bI(List&lt;IMyTerminalBlock&gt;bJ,bool bK=true){foreach(var b in bJ){IMyFunctionalBlock
                f=b as IMyFunctionalBlock;if(f==null)continue;f.Enabled=bK;}}void bL(List&lt;IMyTerminalBlock&gt;bJ){foreach
                (var b in bJ){IMyFunctionalBlock f=b as IMyFunctionalBlock;if(f==null)continue;f.Enabled=!f.Enabled;
                }}string bM="[VIEW]";Matrix bN=new Matrix(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);List&lt;IMyTerminalBlock&gt;bO=
                new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;bP=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                bQ=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;bR=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                bS=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;bT=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                bU=new List&lt;IMyTerminalBlock&gt;();IMyTerminalBlock bV=null;private MyDetectedEntityInfo bW;string bX="CAMERAS";
                void bY(oo f){f.oP(bX,"CameraViewOnly",ref bM,true);}bool bZ(List&lt;IMyTerminalBlock&gt;ca,double cb=100,
                float Z=0,float X=0){double cc=0;bV=null;for(int i=0;i&lt;ca.Count;i++){double cd=((IMyCameraBlock)ca[i]).AvailableScanRange;
                if(cd&gt;cc){cc=cd;bV=ca[i];}}var ce=bV as IMyCameraBlock;if(bV==null){return false;}if(ce.CanScan(cb))
                {bW=ce.Raycast(cb,Z,X);bV=ce;if(!bW.IsEmpty())dt(bW);return true;}else{}return false;}bool bZ(List&lt;IMyTerminalBlock&gt;
                ca,Vector3D cf){double cc=0;bV=null;for(int i=0;i&lt;ca.Count;i++){double cd=((IMyCameraBlock)ca[i]).AvailableScanRange;
                if(cd&gt;cc){cc=cd;bV=ca[i];}}var ce=bV as IMyCameraBlock;if(bV==null)return false;{bW=ce.Raycast(cf);bV
                =ce;if(!bW.IsEmpty())dt(bW);return true;}}double cg(List&lt;IMyTerminalBlock&gt;ca){double ch=0;for(int i=
                0;i&lt;ca.Count;i++){IMyCameraBlock ce=ca[i]as IMyCameraBlock;if(ch&lt;ce.AvailableScanRange)ch=ce.AvailableScanRange;
                }return ch;}string ci(IMyTerminalBlock cj){bO.Clear();bP.Clear();bQ.Clear();bR.Clear();bS.Clear();bT.Clear();
                bU.Clear();if(cj==null)return"\nCameras:No OrientationBlock";GridTerminalSystem.GetBlocksOfType&lt;IMyCameraBlock&gt;(bU,
                (x1=&gt;x1.CubeGrid==Me.CubeGrid));Matrix ck;cj.Orientation.GetMatrix(out ck);Matrix.Transpose(ref ck,out
                ck);for(int i=0;i&lt;bU.Count;++i){if(bU[i].CustomName.Contains(bM))continue;IMyCameraBlock ce=bU[i]as IMyCameraBlock;
                ce.EnableRaycast=true;Matrix cl;ce.Orientation.GetMatrix(out cl);Vector3 cm=Vector3.Transform(cl.Forward,
                ck);if(cm==bN.Left){bS.Add(bU[i]);}else if(cm==bN.Right){bT.Add(bU[i]);}else if(cm==bN.Backward){bP.Add(bU[i]);
                }else if(cm==bN.Forward){bO.Add(bU[i]);}else if(cm==bN.Up){bR.Add(bU[i]);}else if(cm==bN.Down){bQ.Add(bU[i]);
                }}string s;s="CS:&lt;";s+="F"+bO.Count.ToString("00");s+="B"+bP.Count.ToString("00");s+="D"+bQ.Count.ToString("00");
                s+="U"+bR.Count.ToString("00");s+="L"+bS.Count.ToString("00");s+="R"+bT.Count.ToString("00");s+="&gt;";
                return s;}void cn(List&lt;IMyTerminalBlock&gt;ca,string co){string cp;for(int i=0;i&lt;ca.Count;i++){if(!ca[i].CustomName.Contains(co))
                {cp="Camera ";if(ca.Count&gt;1)cp+=(i+1).ToString()+" ";cp+=co;ca[i].CustomName=cp;}}}List&lt;IMyTerminalBlock&gt;
                cq=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;cr=new List&lt;IMyTerminalBlock&gt;();string cs(IMyTerminalBlock
                cj){string s="";if(bU.Count&lt;1)s+=ci(cj);cq.Clear();cr.Clear();foreach(var camera in bQ){if(camera.CustomName.ToLower().Contains("fore")
                ||camera.CustomData.ToLower().Contains("fore"))cq.Add(camera);else if(camera.CustomName.ToLower().Contains("aft")
                ||camera.CustomData.ToLower().Contains("aft"))cr.Add(camera);}s+="HCS:&lt;";s+="F"+cq.Count.ToString("00");
                s+="A"+cr.Count.ToString("00");s+="&gt;";return s;}public class ct{bool cu=false;Program cv;public double
                cw=1250;double cx=5000;float cy=25f;float cz=25f;double cA=5;float cB=3;float cC=0.5f;float cD=0;float
                cE=0;float cF=0;float cG=0;List&lt;IMyTerminalBlock&gt;cH=new List&lt;IMyTerminalBlock&gt;();private int cI=0;private
                int cJ=1;public MyDetectedEntityInfo bW;public List&lt;MyDetectedEntityInfo&gt;cK=new List&lt;MyDetectedEntityInfo&gt;();
                public IMyTerminalBlock bV=null;public ct(Program pg,List&lt;IMyTerminalBlock&gt;bJ,double cL=1250,float cM
                =45f,float cN=45f,float cO=2,float cP=1,float cQ=0.5f,double cR=5000){cv=pg;cu=false;cH.Clear();cK.Clear();
                bW=new MyDetectedEntityInfo();foreach(var b in bJ){if(b is IMyCameraBlock){cH.Add(b);IMyCameraBlock c
                =b as IMyCameraBlock;c.EnableRaycast=true;if(cy&gt;c.RaycastConeLimit)cy=c.RaycastConeLimit;if(cz&gt;c.RaycastConeLimit)
                cz=c.RaycastConeLimit;}}if(cL&gt;cR)cR=cL;cw=cL;cy=cM;cz=cN;cA=cO;cB=cP;cC=cQ;cx=cR;cD=0;cE=0;cF=0;cG=0;
                cI=0;cJ=cH.Count;}public bool cS(){return cu;}void cT(MyDetectedEntityInfo bW){bool cU=true;for(int i
                =0;i&lt;cK.Count;i++){if(cK[i].EntityId==bW.EntityId)cU=false;}if(cU){cK.Add(bW);}}public bool cV(){if(cH.Count
                &lt;1)cu=true;if(cu)return false;bool cW=false;for(int cX=0;cX&lt;cJ;cX++){if(cv.bZ(cH,cw,cG,cF)){bW=cv.bW;
                if(!bW.IsEmpty()){bool cY=true;if((bW.Type==MyDetectedEntityType.LargeGrid)||(bW.Type==MyDetectedEntityType.SmallGrid))
                {if(cv.nA(bW.EntityId)){cY=false;}}if(cY){cv.fh+="\nDoScan HIT!";cT(bW);cW=true;}}cI++;if(cG==0&amp;&amp;cF==
                0){cD=cC;cE=cC;cI=0;}if(cI&gt;3){cI=0;cE+=Math.Abs(cE/cB)+cC;if(Math.Abs(cE)&gt;cy){cI=0;cE=0;cD+=Math.Abs(cD
                /cB)+cC;}if(Math.Abs(cD)&gt;cz){cD=0;cE=0;cI=0;{cw*=cA;if(cw&gt;cx){cu=true;return false;}}}}switch(cI){case
                0:cG=cD;cF=cE;break;case 1:cG=-cD;cF=cE;break;case 2:cG=cD;cF=-cE;break;case 3:cG=-cD;cF=-cE;break;}
                }}return cW;}}const int cZ=0;const int da=2;const int db=4;const int dc=32;const int dd=64;const int
                de=128;const int df=256;const int dg=512;const int dh=1024;const int di=2048;const int dj=0xfff;string
                dk(){string dl="FLAGS:";if((hR&amp;da)&gt;0)dl+="SLED ";if((hR&amp;dc)&gt;0)dl+="ORBITAL ";if((hR&amp;dd)&gt;0)dl+="ROCKET ";
                if((hR&amp;db)&gt;0)dl+="ROTOR ";if((hR&amp;de)&gt;0)dl+="PET ";if((hR&amp;df)&gt;0)dl+="NAD ";if((hR&amp;dg)&gt;0)dl+="NO Gyro ";
                if((hR&amp;di)&gt;0)dl+="No Tank ";if((hR&amp;dh)&gt;0)dl+="No Power ";return dl;}long dm=0;void dn(){string@do;if
                (SaveFile==null){@do=Storage;}else{@do=SaveFile.GetPublicText();}if(hO==null)return;hO.oA(@do);hO.oP(hL,
                "SaveID",ref dm);if(dp())hO.oA("");e(hO);hO.oP(hL,"Mode",ref fm,true);hO.oP(hL,"current_state",ref current_state,
                true);hO.oP(hL,"PassedArgument",ref sPassedArgument,true);hO.oP(hL,"AlertStates",ref hT,true);hO.oP(hL,
                "craft_operation",ref hR,true);hO.oP(hL,"PassedArgument",ref sPassedArgument);hO.oP(hL,"ReceivedMessage",
                ref hU);}bool dp(){if(SaveFile==null)return false;if(dm==(long)SaveFile.EntityId)return false;else return
                true;}bool dq(string dr){dr=dr.Trim().ToLower();return(dr=="True"||dr=="true");}Dictionary&lt;long,MyDetectedEntityInfo&gt;
                ds=new Dictionary&lt;long,MyDetectedEntityInfo&gt;();void dt(MyDetectedEntityInfo thisDetectedInfo){if(thisDetectedInfo.EntityId
                !=0){if(!ds.ContainsKey(thisDetectedInfo.EntityId)){ds.Add(thisDetectedInfo.EntityId,thisDetectedInfo);
                }else{ds[thisDetectedInfo.EntityId]=thisDetectedInfo;}}else Echo("Not adding: Zero Entity");}string dv(MyDetectedEntityInfo
                dw){string s="";s+="ETBV";s+=":"+dw.EntityId.ToString();s+=":"+dw.TimeStamp;Vector3D dx=dw.BoundingBox.Min;
                s+=":"+hX(dx);Vector3D dy=dw.BoundingBox.Max;s+=":"+hX(dy);Vector3D dz=(Vector3)dw.Velocity;s+=":"+hX(dz);
                return s;}void dA(){Echo("mode="+fm.ToString());if(fm==ft){dG();return;}}void dB(){eD(DateTime.Now.ToString()
                +" ACTION: Reset To Idle",el,true);j();gd(fn);}void dC(){eD(b+" Manual Control",en);}bool dD=true;bool
                dE=false;bool dF=false;void dG(){eD("clear",en);eD(b+":Going Target!",en);eD(b+":GT: current_state="
                +current_state.ToString(),en);Echo("Going Target: state="+current_state.ToString());string dH="";dH+=
                "GT:S="+current_state;if(current_state==0){lc();if((hR&amp;da)&gt;0){dE=true;if(gi&gt;45)gi=45;}else dE=false;
                if((hR&amp;db)&gt;0){dF=true;if(gi&gt;15)gi=15;}else dF=false;l.D(nO);double dI=0;((IMyShipController)nO).TryGetPlanetElevation(MyPlanetElevation.Surface,
                out dI);if(!dE&amp;&amp;!dF){if(go&lt;0)go=75;}if(gg){if(dI&gt;ia.it()){current_state=150;}else current_state=160;
                }else gd(fq);iJ=true;}else if(current_state==150){iJ=true;if(dGravity&gt;0){double dI=0;((IMyShipController)nO).TryGetPlanetElevation(MyPlanetElevation.Surface,
                out dI);dH+=" E="+dI.ToString("0.0");float dJ=nY;nY=0.1f;Vector3D dK=(nO as IMyShipController).GetNaturalGravity();
                bool dL=nZ("",dK,nO);dH+=" Aligned="+dL.ToString();Echo("bAligned="+dL.ToString());nY=dJ;if(dL||dI&lt;ia.it()
                *2){on();if(go&gt;0)current_state=155;else current_state=160;}}else current_state=160;}else if(current_state
                ==151){iJ=true;if(dGravity&gt;0){double dI=0;((IMyShipController)nO).TryGetPlanetElevation(MyPlanetElevation.Surface,
                out dI);dH+=" E="+dI.ToString("0.0");float dJ=nY;nY=0.1f;Vector3D dK=(nO as IMyShipController).GetNaturalGravity();
                bool dL=nZ("",dK,nO);dH+=" Aligned="+dL.ToString();Echo("bAligned="+dL.ToString());nY=dJ;if(dL||dI&lt;ia.it()
                *2){on();if(go&gt;0)current_state=155;else current_state=160;}else current_state=150;}else current_state
                =160;}else if(current_state==155){iJ=true;if(dGravity&gt;0){Vector3D dK=(nO as IMyShipController).GetNaturalGravity();
                bool dL=nZ("",dK,nO);dH+=" Aligned="+dL.ToString();double dM=-999;dM=bd(gf,nO);bool dN=Math.Abs(dM)&lt;
                0.1;Echo("yawangle="+dM.ToString());dH+=" Yaw="+dM.ToString("0.00");if(!dN){if(la){Echo("Rotor");gK(dM);
                }else{bB(dM,"Yaw");}}if(dL&amp;&amp;dN){on();current_state=160;}else if(dL&amp;&amp;Math.Abs(dM)&lt;0.5){float dO;float
                dP;float dQ;jI(iU,out dO,out dP,out dQ);dO+=1;dP+=1;dQ+=1;jW(iU,dO,jj);jW(iU,dP,jk);jW(iU,dQ,thrustion);
                }else ka(iU);}else current_state=160;}else if(current_state==156){iJ=true;Vector3D dK=(nO as IMyShipController).GetNaturalGravity();
                bool dN=nZ("",dK,nO);if(dN){on();current_state=160;}}else if(current_state==160){Echo("Moving to Target");
                Vector3D dR=gf;Vector3D dS=dR-nO.GetPosition();double dT=dS.Length();Echo("distance="+fb(dT));Echo("velocity="
                +iM.ToString("0.00"));eD("clear",er);eD("Moving to Target\nD:"+fb(dT)+" V:"+iM.ToString(d),er);if(dD
                &amp;&amp;(dT&lt;gj)){current_state=200;Echo("we have arrived");iJ=true;return;}bool dU=true;if(go&gt;0&amp;&amp;dGravity&gt;
                0){double dI=0;MyShipVelocities dV=((IMyShipController)nO).GetShipVelocities();Vector3D lv=dV.LinearVelocity;
                double dW=lv.X;Echo("LV="+hX(lv));((IMyShipController)nO).TryGetPlanetElevation(MyPlanetElevation.Surface,
                out dI);dH+=" E="+dI.ToString("0.0");dH+=" V="+iM.ToString("0.00");Echo("Elevation="+dI.ToString("0.0"));
                Echo("MinEle="+go.ToString("0.0"));double dX=0;if(dW&lt;0){dX=kk(iX,Math.Abs(dW),dGravity);}double dY=kk(iX,
                iz,dGravity);float dO;float dP;float dQ;jI(iX,out dO,out dP,out dQ);if(go&gt;0){if(dW&lt;-0.5&amp;&amp;(dI-dX*2)&lt;go)
                {dH+=" EM UP!";Vector3D dK=(nO as IMyShipController).GetNaturalGravity();bool dL=nZ("",dK,nO);jW(iX,
                100);dU=false;iJ=true;}else if(dI&lt;go){dO+=Math.Min(5f,(float)gi);dP+=Math.Min(5f,(float)gi);dQ+=Math.Min(5f,
                (float)gi);dH+=" UP! A"+dO.ToString("0.00");jW(iX,dO,jj);jW(iX,dP,jk);jW(iX,dQ,thrustion);}else if(dI
                &gt;(dY+go*1.25)){dH+=" SUPERHIGH";ka(iX,jm,true);Vector3D dK=(nO as IMyShipController).GetNaturalGravity();
                bool dL=nZ("",dK,nO);if(!dL){iJ=true;dU=false;}}else if(dI&gt;go*2){dH+=" HIGH";if(dW&gt;2){dH+=" ^";ka(iX,
                jm,true);}else if(dW&lt;-0.5){dH+=" v";if(dW&gt;(-Math.Min(15,gi))){dO-=Math.Max(25f,Math.Min(5f,(float)iM
                /2));dP-=Math.Max(25f,Math.Min(5f,(float)iM/2));dQ-=Math.Max(25f,Math.Min(5f,(float)iM/2));dH+=" DOWN! A"
                +dO.ToString("0.00");}else{dO+=Math.Max(100f,Math.Min(5f,(float)iM/2));dP+=Math.Max(100f,Math.Min(5f,
                (float)iM/2));dQ+=Math.Max(100f,Math.Min(5f,(float)iM/2));dH+=" 2FAST! A"+dO.ToString("0.00");Vector3D
                dK=(nO as IMyShipController).GetNaturalGravity();bool dL=nZ("",dK,nO);if(!dL){iJ=true;dU=false;}}}else
                {dH+=" -";dO-=5;dP-=5;dQ-=5;}jW(iX,dO,jj);jW(iX,dP,jk);jW(iX,dQ,thrustion);}else{ka(iX);}}}if(dU){Echo("Do Travel");
                lh(dR,(float)gj,200,170);}else{ka(iU);}}else if(current_state==170){iJ=true;Vector3D dR=gf;lc();lx(dR);
                current_state=172;}else if(current_state==171){iJ=false;}else if(current_state==172){Echo("Collision Avoid");
                eD("clear",er);eD("Collision Avoid",er);lh(lw,5.0f,160,173);}else if(current_state==173){if(bW.Type==
                MyDetectedEntityType.Asteroid||bW.Type==MyDetectedEntityType.LargeGrid||bW.Type==MyDetectedEntityType.SmallGrid)
                {current_state=174;}else current_state=170;iJ=true;}else if(current_state==174){lQ();lc();gh=DateTime.Now;
                current_state=175;iJ=true;}else if(current_state==175){DateTime dZ=gh.AddSeconds(5.0f);DateTime ea=DateTime.Now;
                if(DateTime.Compare(ea,dZ)&gt;0){gd(fq);ky();return;}if(lR()){Echo("ESCAPE!");current_state=180;}bWantMedium
                =true;}else if(current_state==180){lh(lw,1f,160,173);}else if(current_state==200){eD("clear",er);eD("Arrived at Target",
                er);dH+=" ARRIVED!";j();gg=false;mo(false);py();gd(fQ);if(gn){var eb=nJ&lt;IMyTerminalBlock&gt;("NAV:");for
                (int i1=0;i1&lt;eb.Count();i1++){if(eb[i1].CustomName.StartsWith("NAV:")){Echo("Found NAV: command:");eb[i1].CustomName
                ="NAV: C Arrived Target";}}}iJ=true;ky();}gv(dH);}void ec(float ed){if(dF){gB(ed);}else jW(iU,ed);}void
                ee(){ka(iT);gJ();}string ef="LOGGING";void eg(oo f){f.oP(ef,"TextPanelReport",ref sTextPanelReport,true);
                f.oP(ef,"StatusName",ref ek,true);f.oP(ef,"LongStatus",ref em,true);f.oP(ef,"RangeReport",ref ei,true);
                f.oP(ef,"SledReport",ref ssledReport,true);f.oP(ef,"GPSTag",ref eq,true);}ev eh=null;string ei="[RANGE]";
                ev ej=null;string ek="Wico Craft Status";ev el=null;string em="Wico Craft Log";ev en=null;string sTextPanelReport
                ="Craft Report";ev ep=null;string eq="[GPS]";ev er=null;string ssledReport="[SMREPORT]";bool et=false;
                bool eu=false;public class ev{Program cv;string ew="";List&lt;IMyTextPanel&gt;ex=new List&lt;IMyTextPanel&gt;();
                string ey="";string ez="";bool eA=false;bool eB=true;public ev(Program pg,string cp,bool eC=false){cv
                =pg;ew=cp;eA=eC;eB=true;ey="";ez="";ex.Clear();ex=cv.nL(ew);if(ex.Count&lt;1)ex=cv.nK(ew);}public void eD(string
                eE,bool eF=false){if(eE=="clear"){ey="";ez="X";eB=false;return;}if(eA&amp;&amp;eB){eB=false;if(ex.Count&gt;0){ey
                =ex[0].GetPublicText();ez="X";}}if(eF){ey=eE+"\n"+ey;}else ey+=eE+"\n";}public void eG(){if(ez!=ey){
                eB=true;foreach(var t in ex){t.WritePublicText(ey);}ez=ey;}}}void eH(){ej=eM(true);el=eJ(em,true);;en
                =eJ(sTextPanelReport);eh=eJ(ei);ep=eJ(eq,iy);er=eJ(ssledReport);et=true;}void eI(){if(ej!=null)ej.eG();
                if(el!=null)el.eG();if(en!=null)en.eG();if(eh!=null)eh.eG();if(ep!=null)ep.eG();if(er!=null)er.eG();
                }ev eJ(string stheName,bool bRefresh=false){ev eL=new ev(this,stheName,bRefresh);return eL;}ev eM(bool
                force_update=false){if((ej!=null||et)&amp;&amp;!force_update)return ej;ej=eJ(ek);return ej;}void eD(string text,
                ev wLog,bool bReverse=false){if(wLog==null)return;wLog.eD(text,bReverse);}void eP(string eE){eD(eE,eM());
                if(eu&amp;&amp;eE!="clear")Echo(eE);}string eQ(double eR){int eS=75;if(eR&lt;0)eR=0;int eT=(int)(eR*eS)/100;if(eT
                &gt;eS)eT=eS;string dl="["+new String('|',eT)+new String('\'',eS-eT)+"]";return dl;}void eU(string cp,Vector3D
                eV){string s1;s1="GPS:"+cp+":"+hX(eV)+":";eD(s1,ep);}string eW(string eX,string eY){string s;int eZ=
                eX.Length;int fa=eY.Length;if(eZ+fa&gt;32){if(fa&gt;31)return"INVALID";eZ=32-fa;}s=eX.Substring(0,eZ)+eY;s.Replace(":",
                "_");s.Replace(";","_");return s;}string fb(double thed){string fd="";if(thed&gt;1000){fd=thed.ToString("N0")
                +"km";}else if(thed&gt;10){fd=thed.ToString("0.0")+"m";}else{fd=thed.ToString("0.000")+"m";}return fd;}
                void fe(){}void ff(oo fg){mJ(fg);jr(fg);nS(fg);bY(fg);NavInitCustomData(fg);}string fh="";string fi=
                "";int fj=0;string fk(){nU=1;nY=0.09f;nT=0.75;Echo("Init:"+fj);if(fj==0){eD(DateTime.Now.ToString()+
                a+":"+b+":INIT",el,true);fh+=SerializeInit();dn();fh+=nl();fh+=DefaultOrientationBlockInit();eH();}else
                if(fj==1){fh+=js(nO);fh+=gA();fh+=pU(nO);fh+=pt();fh+=ci(nO);fh+=mK();}else if(fj==2){fh+=ol();l.A(nX);
                l.D(nO);fh+=pl();fh+=ci(nO);gM(nO);initShipDim(nO);fh+=fl();iH=true;}fj++;if(iH){fj=0;}eP(fh);return
                fh;}string fl(){return"&gt;";}int fm=0;const int fn=0;const int fo=1;const int fp=2;const int fq=3;const
                int fr=4;const int fs=5;const int ft=7;const int fu=8;const int fv=9;const int fw=13;const int fx=10;
                const int fy=11;const int fz=12;const int fA=14;const int fB=15;const int fC=16;const int fD=17;const
                int fE=18;const int fF=19;const int fG=20;const int fH=21;const int fI=22;const int fJ=23;const int fK
                =24;const int fL=25;const int fM=26;const int fN=27;const int fO=28;const int fP=29;const int fQ=30;
                const int fR=31;const int fS=50;const int fT=60;const int fU=111;const int fV=200;const int fW=210;const
                int fX=220;const int fY=290;const int fZ=400;const int ga=410;const int gb=500;const int gc=510;void
                gd(int newMode){if(fm==newMode)return;fm=newMode;current_state=0;ky();}Vector3D gf;bool gg=false;DateTime
                gh;double gi=100;double gj=50;bool gk=false;bool gl=true;bool gm=true;bool gn=true;float go=-1;bool bNavBeaconDebug
                =false;string sNavSection="NAV";void NavInitCustomData(oo iNIHolder){iNIHolder.oP(sNavSection,"DTMDebug",
                ref gk,true);iNIHolder.oP(sNavSection,"CameraCollision",ref gl,true);iNIHolder.oP(sNavSection,"SensorCollision",
                ref gm,true);iNIHolder.oP(sNavSection,"NAVEmulateOld",ref gn,true);iNIHolder.oP(sNavSection,"NAVGravityMinElevation",
                ref go,true);iNIHolder.oP(sNavSection,"NavBeaconDebug",ref bNavBeaconDebug,true);}void gs(oo f){f.pc(sNavSection,
                "vTarget",gf);f.pc(sNavSection,"ValidNavTarget",gg);f.pc(sNavSection,"dStartShip",gh);f.pc(sNavSection,
                "shipSpeedMax",gi);f.pc(sNavSection,"arrivalDistanceMin",gj);}void gt(oo f){f.oP(sNavSection,"vTarget",
                ref gf,true);f.oP(sNavSection,"ValidNavTarget",ref gg,true);f.oP(sNavSection,"dStartShip",ref gh,true);
                f.oP(sNavSection,"shipSpeedMax",ref gi,true);f.oP(sNavSection,"arrivalDistanceMin",ref gj,true);}List&lt;IMyBeacon&gt;
                gu=new List&lt;IMyBeacon&gt;();void gv(string gw){if(bNavBeaconDebug){if(gu.Count&lt;1)GridTerminalSystem.GetBlocksOfType(gu);
                foreach(var beacon in gu){beacon.CustomName=gw;}}}List&lt;IMyTerminalBlock&gt;gx=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;gy=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;gz=new List&lt;IMyTerminalBlock&gt;();
                string gA(){gx.Clear();gy.Clear();gz.Clear();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(gx,nz);
                for(int i=0;i&lt;gx.Count;i++){if(gx[i].CustomName.Contains("[LEFT]")||gx[i].CustomData.Contains("[LEFT]"))
                {gy.Add(gx[i]);}else if(gx[i].CustomName.Contains("[RIGHT]")||gx[i].CustomData.Contains("[RIGHT]")){
                gz.Add(gx[i]);}}return"NR:L"+gy.Count.ToString("0")+"R"+gz.Count.ToString("0");}bool gB(float gC){if
                (gy.Count&lt;1)return false;float gD=gy[0].GetMaximum&lt;float&gt;("Velocity");var gE=gy[0]as IMyMotorStator;
                float gF=gE.TargetVelocityRPM;float gG=(gF/gD*100);gG=Math.Abs(gG);if(gC&gt;(gG+5f))gC=gG+5;if(gC&lt;(gG-5))
                gC=gG-5;if(gC&lt;0f)gC=0f;if(gC&gt;100f)gC=100f;if(Math.Abs(gC)&gt;0){gB(gy,-gC);gB(gz,gC);return true;}else return
                false;}bool gB(List&lt;IMyTerminalBlock&gt;rotorList,float gC){for(int i=0;i&lt;rotorList.Count;i++){var gE=rotorList[i]
                as IMyMotorStator;float gD=gE.GetMaximum&lt;float&gt;("Velocity");if(!gE.Enabled)gE.Enabled=true;float gI=
                gD*(gC/100.0f);gE.TargetVelocityRPM=gI;}return true;}bool gJ(){gJ(gy);gJ(gz);return true;}bool gJ(List&lt;IMyTerminalBlock&gt;
                rotorList){for(int i=0;i&lt;rotorList.Count;i++){IMyMotorStator gE=rotorList[i]as IMyMotorStator;gE.TargetVelocityRPM
                =0;}return true;}bool gK(double bg){float gC;if(Math.Abs(bg)&gt;1.0){gC=50;}else if(Math.Abs(bg)&gt;.7){gC
                =50;}else if(Math.Abs(bg)&gt;0.5){gC=30;}else if(Math.Abs(bg)&gt;0.1){gC=20;}else if(Math.Abs(bg)&gt;0.01){gC
                =5;}else if(Math.Abs(bg)&gt;0.001){gC=0;}else gC=0;gC/=3;gC=gC*-Math.Sign(bg);if(Math.Abs(gC)&gt;0){gB(gy,
                gC);}if(Math.Abs(gC)&gt;0){gB(gz,gC);}if(Math.Abs(gC)&gt;0)return false;else return true;}public gO gL;void
                gM(IMyTerminalBlock sourceBlock=null){if(sourceBlock==null)sourceBlock=nO;gL=new gO(sourceBlock);}public
                struct gO{public Vector3D[]gP;Vector3D gQ;Vector3D gR;public Vector3D gS;static int[]gT={1,3,5,7};static
                int[]gU={0,2,4,6};static int[]gV={2,3,6,7};static int[]gW={0,1,4,5};static int[]gX={4,5,6,7};static int[]
                gY={0,1,2,3};static int[][]gZ={gT,gU,gV,gW,gX,gY};public const int ha=0;public const int hb=1;public
                const int hc=2;public const int hd=3;public const int he=4;public const int hf=5;public gO(IMyTerminalBlock
                hg){gP=new Vector3D[8];gR=new Vector3D(hg.CubeGrid.Min)-new Vector3D(0.5,0.5,0.5);gR*=hg.CubeGrid.GridSize;
                gQ=new Vector3D(hg.CubeGrid.Max)+new Vector3D(0.5,0.5,0.5);gQ*=hg.CubeGrid.GridSize;var hh=hg.WorldMatrix.GetOrientation();
                var hi=hg.CubeGrid.WorldMatrix.GetOrientation()*MatrixD.Transpose(hh);Vector3D.TransformNormal(ref gR,
                ref hi,out gR);Vector3D.TransformNormal(ref gQ,ref hi,out gQ);var hj=Vector3D.Min(gR,gQ);gQ=Vector3D.Max(gR,
                gQ);gR=hj;var hk=hg.CubeGrid.GetPosition();Vector3D hl;Vector3D hm;hl=gR;Vector3D.TransformNormal(ref
                hl,ref hh,out hl);hl+=hk;hm=gQ;Vector3D.TransformNormal(ref hm,ref hh,out hm);hm+=hk;BoundingBox bb=
                new BoundingBox(hl,hm);gS=bb.Center;Vector3D hn;for(int i=0;i&lt;8;i++){hn.X=((i&amp;1)==0?gR:gQ).X;hn.Y=((i
                &amp;2)==0?gR:gQ).Y;hn.Z=((i&amp;4)==0?gR:gQ).Z;Vector3D.TransformNormal(ref hn,ref hh,out hn);hn+=hk;gP[i]=
                hn;}}public void ho(int hp,Vector3D[]hq,int hr=0){hp%=gZ.Length;for(int i=0;i&lt;gZ[hp].Length;i++){hq[hr++]
                =gP[gZ[hp][i]];}}}bool hs(string ht){fi="";if(ht==""||ht=="timer"||ht=="wccs"||ht=="wcct"){if(sPassedArgument
                !=""&amp;&amp;sPassedArgument!="timer"){ht=sPassedArgument;}if(gn){var eb=nJ&lt;IMyTerminalBlock&gt;("NAV:");for(int
                i1=0;i1&lt;eb.Count();i1++){if(eb[i1].CustomName.StartsWith("NAV:")){Echo("Found NAV: command:");ht=eb[i1].CustomName.Substring("NAV:".Length);
                break;}}}}if(ht=="init"){fh="";iH=false;fj=0;fk();return false;}string[]hu=ht.Trim().Split(';');for(int
                hv=0;hv&lt;hu.Length;hv++){string[]hw=hu[hv].Trim().Split(' ');if(hw[0]=="timer"){}else if(hw[0]=="wccs")
                {}else if(hw[0]=="wcct"){}else if(hw[0]=="W"||hw[0]=="O"){Echo("Args:");for(int hx=0;hx&lt;hw.Length;hx++)
                Echo(hw[hx]);if(hw.Length&lt;1){Echo("Invalid Command:("+hu[hv]+")");continue;}string hy=hw[1].Trim();if
                (hw.Length&gt;2){hy=hw[1];for(int kk=2;kk&lt;hw.Length;kk++)hy+=" "+hw[kk];hy=hy.Trim();}string[]hz=hy.Split(',');
                if(hz.Length&lt;3){hz=hy.Split(':');}for(int hx=0;hx&lt;hz.Length;hx++)Echo(hz[hx]);if(hz.Length&lt;3){Echo("Invalid Command:("
                +hu[hv]+")");on();return false;}int hA=0;string hB="Waypoint";if(hz[0]=="GPS"){if(hz.Length&gt;4){hB=hz[1];
                hA=2;}else{Echo("Invalid Command");on();return false;}}double x,y,z;bool hC=double.TryParse(hz[hA++].Trim(),
                out x);bool hD=double.TryParse(hz[hA++].Trim(),out y);bool hE=double.TryParse(hz[hA++].Trim(),out z);
                if(!hC||!hD||!hE){Echo("Invalid Command:("+hu[hv]+")");continue;}gf=new Vector3D(x,y,z);gg=true;if(hw[0]
                =="W")dD=true;else dD=false;gd(ft);}else if(hw[0]=="S"){if(hw.Length&lt;1){Echo("Invalid Command:("+hu[hv]
                +")");continue;}double x;bool hC=double.TryParse(hw[1].Trim(),out x);if(hC){gi=x;Echo("Set speed to:"
                +gi.ToString("0.00"));}else{Echo("Invalid Command:("+hu[hv]+")");continue;}}else if(hw[0]=="D"){if(hw.Length
                &lt;1){Echo("Invalid Command:("+hu[hv]+")");continue;}double x;bool hC=double.TryParse(hw[1].Trim(),out
                x);if(hC){gj=x;Echo("Set arrival distance to:"+gj.ToString("0.00"));}else{Echo("Invalid Command:("+hu[hv]
                +")");continue;}}else if(hw[0]=="C"){if(hw.Length&lt;1){Echo("Invalid Command:("+hu[hv]+")");continue;}
                else{Echo(hu[hv]);}}else{int hF;if(iv.TryGetValue(hw[0].ToLower(),out hF)){fi="mode set to "+hF;gd(hF);
                }else{fi="Unknown argument:"+hw[0];}}}return false;}bool hG(string ht){return false;}void hH(){if(hO
                ==null)return;g(hO);hO.pc(hL,"Mode",fm.ToString());hO.pc(hL,"current_state",current_state.ToString());
                hO.pc(hL,"PassedArgument",sPassedArgument);hO.pc(hL,"AlertStates",hT.ToString());hO.pc(hL,"craft_operation",
                hR.ToString());hO.pc(hL,"PassedArgument",sPassedArgument);hO.pc(hL,"ReceivedMessage",hU);long hI=0;if
                (SaveFile!=null)hI=SaveFile.EntityId;hO.pc(hL,"SaveID",(long)hI);if(hO.oz){if(hO.oz){string hJ=hO.pg();
                if(SaveFile==null){Storage=hJ;}else{SaveFile.WritePublicText(hJ,false);}}}else{Echo("Not saving: Same");
                }}string hK="Wico Craft Save";string hL="WCCM2";void SerializeInitCustomData(oo iNIHolder){iNIHolder.oP(hL,
                "SAVE_FILE_NAME",ref hK,true);}IMyTextPanel SaveFile=null;oo hO;int current_state=0;long allBlocksCount
                =0;int hR=cZ;string sPassedArgument="";int hT=0;string hU="";string SerializeInit(){string fh="S";SaveFile
                =null;List&lt;IMyTerminalBlock&gt;bJ=new List&lt;IMyTerminalBlock&gt;();bJ=nN&lt;IMyTextPanel&gt;(hK);if(bJ.Count&gt;1)Echo("Multiple blocks found: \""
                +hK+"\"");else if(bJ.Count==0){bJ=nJ&lt;IMyTextPanel&gt;(hK);if(bJ.Count==1)SaveFile=bJ[0]as IMyTextPanel;
                else{bJ=nM&lt;IMyTextPanel&gt;(hK);if(bJ.Count==1)SaveFile=bJ[0]as IMyTextPanel;}}else SaveFile=bJ[0]as IMyTextPanel;
                hO=new oo(this,"");if(SaveFile==null){fh="-";Echo(hK+" (TextPanel) is missing or Named incorrectly. ");
                }return fh;}bool hW(){return SaveFile!=null;}string hX(Vector3D v){string s;s=v.X.ToString("0.00")+":"
                +v.Y.ToString("0.00")+":"+v.Z.ToString("0.00");return s;}bool hY(string hZ,out double x,out double y,
                out double z){string[]hz=hZ.Trim().Split(',');if(hz.Length&lt;3){hz=hZ.Trim().Split(':');}x=0;y=0;z=0;if
                (hz.Length&lt;3)return false;bool hC=double.TryParse(hz[0].Trim(),out x);bool hD=double.TryParse(hz[1].Trim(),
                out y);bool hE=double.TryParse(hz[2].Trim(),out z);if(!hC||!hD||!hE){return false;}return true;}ig ia;
                void initShipDim(IMyTerminalBlock cj){if(cj==null){cj=(IMyTerminalBlock)Me;}ia=new ig(this,cj);}const
                float ic=0.5f;const float id=2.5f;const double ie=0.5;const double@if=2.5;public class ig{private float
                ih,ii,ij;private double ik,il,im;private double@in;private Program cv;private gO gL;public ig(Program
                pg,IMyTerminalBlock cj){cv=pg;if(cv.Me.CubeGrid.GridSizeEnum.ToString().ToLower().Contains("small"))
                @in=ie;else@in=@if;gL=new gO(cj);Vector3D[]hq=new Vector3D[4];gL.ho(gO.hf,hq);il=(hq[0]-hq[1]).Length();
                im=(hq[0]-hq[2]).Length();gL.ho(0,hq);ik=(hq[0]-hq[2]).Length();ih=(float)(ik/@in);ii=(float)(il/@in);
                ij=(float)(im/@in);}public float io(){return ih;}public double ip(){return ik;}public float iq(){return
                ii;}public double ir(){return il;}public float@is(){return ij;}public double it(){return im;}public double
                iu(){return@in;}}Dictionary&lt;string,int&gt;iv=new Dictionary&lt;string,int&gt;();string iw="";UpdateFrequency ix
                =UpdateFrequency.Once;bool iy=true;float iz=100;string iA="WORLD";void iB(oo f){f.oP(iA,"MaxWorldMps",
                ref iz,true);}void iC(){oo fg=new oo(this,Me.CustomData);fg.oP(a,"EchoOn",ref iD,true);iB(fg);na(fg);
                eg(fg);ff(fg);if(fg.oz){Me.CustomData=fg.pg(true);}}bool iD=true;Action&lt;string&gt;iE;void iF(string iG)
                {if(iD)iE(iG);}public Program(){fe();iC();iE=Echo;Echo=iF;iw=a+":"+b+" V"+c+" ";iE(iw+"Creator");if(!Me.CustomName.Contains(b))
                Me.CustomName="PB "+a+" "+b;if(!Me.Enabled){Echo("I am turned OFF!");}}bool iH=false;bool iI=false;bool
                iJ=false;bool bWantMedium=false;bool bWorkingProjector=false;double iM=-1;double dGravity=-2;void Main(string
                ht,UpdateType ut){Echo(iw+ks());iJ=false;bWantMedium=false;bWorkingProjector=false;var iO=new List&lt;IMyTerminalBlock&gt;();
                GridTerminalSystem.GetBlocksOfType&lt;IMyProjector&gt;(iO,nz);for(int i=0;i&lt;iO.Count;i++){if(iO[i].IsWorking)
                {Echo("Projector:"+iO[i].CustomName);bWorkingProjector=true;}}if(bWorkingProjector)Echo("Working local Projector found!");
                if(ht!=""&amp;&amp;ht!="timer"&amp;&amp;ht!="wccs")Echo("Arg="+ht);if(ht=="init"){fh="";iH=false;}if(!iH){if(bWorkingProjector)
                {eD("clear",eJ(sTextPanelReport));eD(b+":Construction in Progress\nTurn off projector to continue",en);
                }iJ=true;fk();iI=true;}else{if(iI)eD(DateTime.Now.ToString()+" "+a+":"+fh,el,true);dn();if(nO is IMyShipController)
                {iM=((IMyShipController)nO).GetShipSpeed();Vector3D iP=((IMyShipController)nO).GetNaturalGravity();double
                iQ=iP.Length();dGravity=iQ/9.81;}if((ut&amp;(UpdateType.Trigger|UpdateType.Terminal))&gt;0){if(hs(ht)){hH();
                eI();return;}}else if((ut&amp;(UpdateType.Mod))&gt;0){if(hs(ht)){hH();eI();return;}}else if((ut&amp;(UpdateType.Script))
                &gt;0){if(hs(ht)){hH();eI();return;}}else if((ut&amp;(UpdateType.Antenna))&gt;0){if(!hG(ht)){mA(ht);}hH();ky();
                eI();return;}else{ht="";}my();mt();h();dA();}hH();if(iJ){Echo("FAST!");Runtime.UpdateFrequency|=ix;}
                else{Runtime.UpdateFrequency&amp;=~(ix);}if(bWantMedium){Echo("MEDIUM");Runtime.UpdateFrequency|=UpdateFrequency.Update10;
                }else{Runtime.UpdateFrequency&amp;=~(UpdateFrequency.Update10);}this.i();iI=false;eI();}void iR(string iw
                =null){float iS=0;iS=Runtime.CurrentInstructionCount/(float)Runtime.MaxInstructionCount;if(iw==null)
                iw="Instructions=";Echo(iw+" "+(iS*100).ToString("0.00")+"%");}List&lt;IMyTerminalBlock&gt;iT=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;iU=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;thrustBackwardList=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;iW=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;iX=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;thrustLeftList=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;iZ=new List&lt;IMyTerminalBlock&gt;();
                double ja=0;double jb=0;double jc=0;double jd=0;double je=0;double jf=0;int jg=0;int jh=0;int ji=0;const
                int jj=1;const int jk=2;const int thrustion=4;const int jm=0xff;Matrix jn=new Matrix(1,0,0,0,0,1,0,0,
                0,0,1,0,0,0,0,1);string jo="IGNORE";string jp="cutter";string jq="THRUSTERS";void jr(oo iNIHolder){iNIHolder.oP(jq,
                "IgnoreThruster",ref jo);iNIHolder.oP(jq,"CutterThruster",ref jp);}void js(IMyTerminalBlock cj,ref List&lt;IMyTerminalBlock&gt;
                iU,ref List&lt;IMyTerminalBlock&gt;iV,ref List&lt;IMyTerminalBlock&gt;iW,ref List&lt;IMyTerminalBlock&gt;iX,ref List&lt;IMyTerminalBlock&gt;
                iY,ref List&lt;IMyTerminalBlock&gt;iZ,int jt=jm){iU.Clear();iV.Clear();iW.Clear();iX.Clear();iY.Clear();iZ.Clear();
                iT.Clear();if(cj==null)return;var ju=new List&lt;IMyTerminalBlock&gt;();nG&lt;IMyThrust&gt;(ref ju);for(int i=0;
                i&lt;ju.Count;i++){if(ju[i].CustomName.ToLower().Contains(jp)||ju[i].CustomData.ToLower().Contains(jp))
                continue;if(ju[i].CustomName.ToLower().Contains(jo)||ju[i].CustomData.ToLower().Contains(jo))continue;
                iT.Add(ju[i]);}Matrix ck;cj.Orientation.GetMatrix(out ck);Matrix.Transpose(ref ck,out ck);ja=0;jb=0;
                jc=0;jd=0;je=0;jf=0;for(int i=0;i&lt;iT.Count;++i){var jv=iT[i]as IMyThrust;Matrix jw;jv.Orientation.GetMatrix(out
                jw);Vector3 cm=Vector3.Transform(jw.Backward,ck);int jx=jy(iT[i]);if(jx==jj)ji++;else if(jx==jk)jh++;
                else if(jx==thrustion)jg++;if(cm==jn.Left){je+=jA((IMyThrust)iT[i]);iY.Add(iT[i]);}else if(cm==jn.Right)
                {jf+=jA((IMyThrust)iT[i]);iZ.Add(iT[i]);}else if(cm==jn.Backward){jb+=jA((IMyThrust)iT[i]);iV.Add(iT[i]);
                }else if(cm==jn.Forward){ja+=jA((IMyThrust)iT[i]);iU.Add(iT[i]);}else if(cm==jn.Up){jd+=jA((IMyThrust)iT[i]);
                iX.Add(iT[i]);}else if(cm==jn.Down){jc+=jA((IMyThrust)iT[i]);iW.Add(iT[i]);}}}string js(IMyTerminalBlock
                cj){iU.Clear();thrustBackwardList.Clear();iW.Clear();iX.Clear();thrustLeftList.Clear();iZ.Clear();iT.Clear();
                if(cj==null)return"No Orientation Block";var ju=new List&lt;IMyTerminalBlock&gt;();nG&lt;IMyThrust&gt;(ref ju);for
                (int i=0;i&lt;ju.Count;i++){if(ju[i].CustomName.ToLower().Contains(jp)||ju[i].CustomData.ToLower().Contains(jp))
                continue;if(ju[i].CustomName.ToLower().Contains(jo)||ju[i].CustomData.ToLower().Contains(jo))continue;
                iT.Add(ju[i]);}Matrix ck;cj.Orientation.GetMatrix(out ck);Matrix.Transpose(ref ck,out ck);ja=0;jb=0;
                jc=0;jd=0;je=0;jf=0;for(int i=0;i&lt;iT.Count;++i){var jv=iT[i]as IMyThrust;Matrix jw;jv.Orientation.GetMatrix(out
                jw);Vector3 cm=Vector3.Transform(jw.Backward,ck);int jx=jy(iT[i]);if(jx==jj)ji++;else if(jx==jk)jh++;
                else if(jx==thrustion)jg++;if(cm==jn.Left){je+=jA((IMyThrust)iT[i]);thrustLeftList.Add(iT[i]);}else if
                (cm==jn.Right){jf+=jA((IMyThrust)iT[i]);iZ.Add(iT[i]);}else if(cm==jn.Backward){jb+=jA((IMyThrust)iT[i]);
                thrustBackwardList.Add(iT[i]);}else if(cm==jn.Forward){ja+=jA((IMyThrust)iT[i]);iU.Add(iT[i]);}else if
                (cm==jn.Up){jd+=jA((IMyThrust)iT[i]);iX.Add(iT[i]);}else if(cm==jn.Down){jc+=jA((IMyThrust)iT[i]);iW.Add(iT[i]);
                }}string s;s="&gt;";s+="F"+iU.Count.ToString("00");s+="B"+thrustBackwardList.Count.ToString("00");s+="D"
                +iW.Count.ToString("00");s+="U"+iX.Count.ToString("00");s+="L"+thrustLeftList.Count.ToString("00");s
                +="R"+iZ.Count.ToString("00");s+="&lt;";return s;}int jy(IMyTerminalBlock theBlock){if(theBlock is IMyThrust)
                {if(theBlock.BlockDefinition.SubtypeId.Contains("Atmo"))return jj;else if(theBlock.BlockDefinition.SubtypeId.Contains("Hydro"))
                return jk;else return thrustion;}return 0;}double jA(IMyThrust thruster){return thruster.MaxEffectiveThrust;
                }double jB(List&lt;IMyTerminalBlock&gt;jC,int jD=jm){double jE=0;for(int jF=0;jF&lt;jC.Count;jF++){int jG=jy(jC[jF]);
                if((jG&amp;jD)&gt;0){IMyThrust jv=jC[jF]as IMyThrust;double jH=jv.MaxEffectiveThrust;jE+=jH;}}return jE;}bool
                jI(List&lt;IMyTerminalBlock&gt;thrusters,out float jJ,out float jK,out float jL){jJ=0;jK=0;jL=0;double jM=
                jB(thrusters,thrustion);double jN=jB(thrusters,jj);double jO=jB(thrusters,jk);MyShipMass jP;jP=((IMyShipController)nO).CalculateShipMass();
                double jQ=0;jQ=jP.PhysicalMass*dGravity*9.810;if(jN&gt;0){if(jN&lt;jQ){jJ=100;jQ-=jN;}else{jJ=(float)(jQ/jN
                *100);if(jJ&gt;0)jQ-=(jN*jJ/100);}}if(jM&gt;0&amp;&amp;jQ&gt;0){if(jM&lt;jQ){jL=100;jQ-=jM;}else{jL=(float)(jQ/jM*100);if
                (jL&gt;0)jQ-=((jM*jL)/100);}}if(jO&gt;0&amp;&amp;jQ&gt;0){if(jO&lt;jQ){jK=100;jQ-=jO;}else{jK=(float)(jQ/jO*100);if(jK&gt;0)
                jQ-=((jO*jK)/100);;}}if(jQ&gt;0)return false;return true;}List&lt;IMyTerminalBlock&gt;jR(string jS){var jT=new
                List&lt;IMyTerminalBlock&gt;();var jU=new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(jU);for(int
                jV=0;jV&lt;jU.Count;jV++){if(jU[jV].Name==jS){List&lt;IMyTerminalBlock&gt;jC=null;jU[jV].GetBlocks(jC,nz);for
                (int jF=0;jF&lt;jC.Count;jF++){jT.Add(jC[jF]);}break;}}return jT;}int jW(List&lt;IMyTerminalBlock&gt;jC,float
                ed,int jD=jm){int jX=0;if(ed&gt;100)ed=100;if(ed&lt;0)ed=0;for(int jF=0;jF&lt;jC.Count;jF++){int jG=jy(jC[jF]);
                if((jG&amp;jD)&gt;0){IMyThrust jv=jC[jF]as IMyThrust;if(!jv.IsWorking){jv.Enabled=true;}jX+=1;jv.ThrustOverridePercentage
                =ed/100f;}}return jX;}int jW(List&lt;IMyTerminalBlock&gt;jC,int jY=100,int jD=jm){return jW(jC,(float)jY,jD);
                }bool jW(string jZ,int jY=100,int jD=jm){if(jY&gt;100)jY=100;var jU=new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(jU);
                for(int jV=0;jV&lt;jU.Count;jV++){if(jU[jV].Name==jZ){List&lt;IMyTerminalBlock&gt;jC=null;jU[jV].GetBlocks(jC,
                nz);return(jW(jC,jY,jD)&gt;0);}}return false;}int ka(List&lt;IMyTerminalBlock&gt;thrusters,int iTypes=jm,bool
                bForceOff=false){int jX=0;for(int jF=0;jF&lt;thrusters.Count;jF++){int jG=jy(thrusters[jF]);if((jG&amp;iTypes)
                &gt;0){jX++;IMyThrust jv=thrusters[jF]as IMyThrust;jv.ThrustOverride=0;if(jv.IsWorking&amp;&amp;bForceOff)jv.Enabled
                =false;else if(!jv.IsWorking&amp;&amp;!bForceOff)jv.Enabled=true;}}return jX;}bool ka(string jZ){var jU=new List&lt;IMyBlockGroup&gt;();
                GridTerminalSystem.GetBlockGroups(jU);for(int jV=0;jV&lt;jU.Count;jV++){if(jU[jV].Name==jZ){List&lt;IMyTerminalBlock&gt;
                jC=null;jU[jV].GetBlocks(jC,nz);return(ka(jC)&gt;0);}}return false;}bool jW(){return(jW(iU)&gt;0);}bool ka()
                {return(ka(iU)&gt;0);}double kc(List&lt;IMyTerminalBlock&gt;kd,int jD=jm){for(int i=0;i&lt;kd.Count;i++){int jG=
                jy(kd[i]);if((jG&amp;jD)&gt;0&amp;&amp;kd[i].IsWorking){var jv=kd[i]as IMyThrust;return jv.ThrustOverride;}}return 0;
                }bool ke(List&lt;IMyTerminalBlock&gt;kd,int jD=jm){for(int i=0;i&lt;kd.Count;i++){int jG=jy(kd[i]);if((jG&amp;jD)
                &gt;0&amp;&amp;kd[i].IsWorking){return true;}}return false;}int kf(List&lt;IMyTerminalBlock&gt;kd,int jD=jm){int jX=0;
                for(int i=0;i&lt;kd.Count;i++){int jG=jy(kd[i]);if((jG&amp;jD)&gt;0&amp;&amp;kd[i].IsWorking){jX++;}}return jX;}IMyThrust
                kg(List&lt;IMyTerminalBlock&gt;iO,int kh=jm){foreach(var thrust in iT){if(thrust is IMyThrust&amp;&amp;(jy(thrust)
                &amp;kh)&gt;0)return thrust as IMyThrust;}return null;}double ki(){if(ji&lt;1)return 0;var kj=kg(iT,jj);if(kj==
                null)return 0;return kj.MaxEffectiveThrust/kj.MaxThrust;}double kk(List&lt;IMyTerminalBlock&gt;iX,double kl,
                double km){var jP=((IMyShipController)nO).CalculateShipMass();double jQ=0;jQ=jP.PhysicalMass*km*9.810;
                double jA=jB(iX);double kn=(jA-jQ)/jP.TotalMass;double ko=kl/kn;double kp=kl/2*ko;return kp;}string[]
                kq={"-","\\","|","/","-","\\","|","/"};int kr=99;string ks(){kr++;if(kr&gt;=kq.Length)kr=0;return kq[kr];
                }const string kt="[WCCT]";const string ku="[WCCS]";const string kv="[WCCM]";Dictionary&lt;string,List&lt;IMyTerminalBlock&gt;&gt;
                kw=new Dictionary&lt;string,List&lt;IMyTerminalBlock&gt;&gt;();void kx(){kw.Clear();}void ky(){if(!kz(kt))kz(kv);
                }bool kz(string sKeyword="[WCCS]"){bool kB=false;List&lt;IMyTerminalBlock&gt;bJ=new List&lt;IMyTerminalBlock&gt;();
                IMyTimerBlock kC=null;if(kw.ContainsKey(sKeyword)){bJ=kw[sKeyword];}else{bJ=nJ&lt;IMyTerminalBlock&gt;(sKeyword);
                kw.Add(sKeyword,bJ);}for(int i=0;i&lt;bJ.Count;i++){kC=bJ[i]as IMyTimerBlock;if(kC!=null){kC.ApplyAction("TriggerNow");
                kB=true;}}return kB;}double kD=-1;double kE=0.50;double kF=-1;IMyShipController kG=null;double kH=85;
                List&lt;IMyTerminalBlock&gt;kI=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;kJ=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;kK=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;kL=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;kM=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;kN=new List&lt;IMyTerminalBlock&gt;();
                IMySensorBlock kO=null;bool kP=false;bool kQ=false;bool kR=false;double kS=100;double kT=50;double kU
                =15;double kV=100;double kW=100*0.5;double kX=100*0.25;double kY=5;float kZ=50f;bool la=false;bool lb
                =false;void lc(){kG=null;py();nY=0.01f;kF=0;kD=-1;}void ld(Vector3D dR,double maxSpeed,IMyTerminalBlock
                lf,int jx=jm){kH=maxSpeed;if(kH&gt;iz)kH=iz;if((hR&amp;da)&gt;0){lb=true;pW();}else lb=false;if((hR&amp;db)&gt;0){la=
                true;}else la=false;kG=lf as IMyShipController;Vector3D dS=dR-kG.CenterOfMass;double dT=dS.Length();
                js(kG,ref kJ,ref kI,ref kN,ref kM,ref kK,ref kL,jx);py();if(po.Count&gt;0){kO=po[0];if(la||lb)kO.DetectAsteroids
                =false;else kO.DetectAsteroids=true;kO.DetectEnemy=true;kO.DetectLargeShips=true;kO.DetectSmallShips
                =true;kO.DetectStations=true;kO.DetectPlayers=false;kZ=kO.GetMaximum&lt;float&gt;("Front");}else{kO=null;kZ
                =0;}kP=false;kQ=false;kR=false;double lg=kH;if(!lb&amp;&amp;!la)lg=lu(kI,dT);if(lg&lt;kH)kH=lg;fh+="\nDistance="
                +fb(dT)+" OptimalV="+lg;kV=kH;kW=kH*0.50;kX=kH*0.25;if(kX&lt;5)kX=5;if(kX&gt;kW)kW=kX;if(kX&gt;kV)kV=kX;kU=kk(kI,
                kX+(kW-kX)/2,0);kT=kk(kI,kW+(kV-kW)/2,0);kS=kk(kI,kV,0);kD=-1;kF=0;nY=0.01f;}void lh(Vector3D dR,float
                arrivalDistance,int lj,int colDetectState,bool ll=false){if(gk)Echo("dTM:"+current_state+"-&gt;"+lj+"-C&gt;"
                +colDetectState);if(kG==null){ld(dR,gi,nO);}if(kD&gt;=0)kD+=Runtime.TimeSinceLastRun.TotalMilliseconds;
                if(kF&gt;=0)kF+=Runtime.TimeSinceLastRun.TotalMilliseconds;Vector3D dS=dR-kG.CenterOfMass;double dT=dS.Length();
                if(gk){Echo("dTM:distance="+fb(dT));Echo("dTM:velocity="+iM.ToString("0.00"));Echo("dTM:tmMaxSpeed="
                +kH.ToString("0.00"));}if(dT&lt;arrivalDistance){j();current_state=lj;lc();iJ=true;return;}eU("TargetLocation",
                dR);List&lt;IMySensorBlock&gt;lm=null;double ln=kk(kI,iM,0);Echo("StoppingD="+fb(ln));if(po.Count&gt;0){float
                lo=Math.Min(50f,(float)ln*1.5f);pA(kO,0,0,0,0,lo,0);}else Echo("No Sensors for Travel movement");bool
                dN=false;Vector3D dK=(nO as IMyShipController).GetNaturalGravity();if(lb||la){double dM=-999;dM=bd(dR,
                nO);Echo("yawangle="+dM.ToString());if(lb){Echo("Sled");bB(dM,"Yaw");}else if(la){Echo("Rotor");gK(dM);
                }dN=Math.Abs(dM)&lt;.05;}else{if(dK.Length()&gt;0){bool lp=nZ("",dK,nO);{double dM=bd(dR,nO);bB(dM,"Yaw");
                dN=Math.Abs(dM)&lt;.05;}}else{dN=nZ("forward",dS,nO);}}kG.DampenersOverride=true;if((dT-ln)&lt;arrivalDistance)
                {nY=0.005f;Echo("Waiting for stop");if(!dN)iJ=true;j();return;}if(dN){bWantMedium=true;Echo("Aimed");
                on();if(gm&amp;&amp;(kF&gt;pq||kF&lt;0)){kF=0;lm=pw();if(lm.Count&gt;0){var lq=new List&lt;MyDetectedEntityInfo&gt;();string
                s="";for(int i1=0;i1&lt;lm.Count;i1++){lm[i1].DetectedEntities(lq);int j1=0;bool lr=false;if(lq.Count&gt;0)
                lr=true;for(;j1&lt;lq.Count;j1++){s="\nSensor TRIGGER!";s+="\nName: "+lq[j1].Name;s+="\nType: "+lq[j1].Type;
                s+="\nRelationship: "+lq[j1].Relationship;s+="\n";if(gk){Echo(s);eD(s,el);}if(lq[j1].Type==MyDetectedEntityType.Planet)
                {lr=false;}if(lq[j1].Type==MyDetectedEntityType.LargeGrid||lq[j1].Type==MyDetectedEntityType.SmallGrid)
                {if(lq[j1].BoundingBox.Contains(dR)!=ContainmentType.Disjoint){if(gk)Echo("Ignoring collision because we want to be INSIDE");
                lr=false;}}if(lr)break;}if(lr){bW=lq[j1];lc();current_state=colDetectState;iJ=true;j();return;}}}else
                bW=new MyDetectedEntityInfo();}double ls=ln*2;{if(ls&lt;100)if(dT&lt;1000)ls=dT;else ls=1000;ls=Math.Min(dT,
                ls);}if(gl){Echo("Scanning distance="+ls);}if(gl&amp;&amp;(kD&gt;kE||kD&lt;0)&amp;&amp;dT&gt;kZ){if(bZ(bO,ls)){kD=0;if(!bW.IsEmpty())
                {bool lr=true;if(ll){if(bW.Type==MyDetectedEntityType.Asteroid){if(bW.BoundingBox.Contains(dR)!=ContainmentType.Disjoint)
                {lr=false;double lt=((Vector3D)bW.HitPosition-nO.GetPosition()).Length();if((lt-ln)&lt;arrivalDistance)
                {j();current_state=lj;lc();return;}}}else if(bW.Type==MyDetectedEntityType.Planet){lr=false;}else{}}
                if(gk){Echo("raycast hit:"+bW.Type.ToString());eD("Camera Trigger collision",el);}if(lr){lc();current_state
                =colDetectState;iJ=true;j();return;}}else{if(gk){eD("Camera Scan Clear",el);}}}else{if(gk){eD("No Scan Available",
                el);}}}else Echo("Raycast delay");if(gk)Echo("dtmFar="+fb(kS));if(gk)Echo("dtmApproach="+fb(kT));if(gk)
                Echo("dtmPrecision="+fb(kU));if(dT&gt;kS&amp;&amp;!kP){Echo("dtmFar");lW(kV,100f);}else if(dT&gt;kT&amp;&amp;!kQ){Echo("Approach");
                kP=true;lW(kW,100f);}else if(dT&gt;kU&amp;&amp;!kR){Echo("Precision");if(!kQ)nY=0.005f;kQ=true;lW(kX,55f);}else
                {Echo("Close");if(!kR)nY=0.005f;kR=true;lW(kY,55f);}}else{if(gk)Echo("Aiming");iJ=true;kG.DampenersOverride
                =true;if(iM&lt;5){ka(iT);}else{ka(kI,jm,true);}}}double lu(List&lt;IMyTerminalBlock&gt;lv,double dT){Echo("#thrusters="
                +lv.Count.ToString());if(lv.Count&lt;1)return iz;MyShipMass jP;jP=((IMyShipController)nO).CalculateShipMass();
                double jA=jB(lv);double kn=jA/jP.PhysicalMass;double lg,ko,kp;lg=((dT*.75)/2)/(kn);Echo("COS");do{Echo("COS:DO");
                ko=lg/kn;kp=lg/2*ko;if(kp&gt;dT){lg*=0.85;}Echo("stoppingM="+kp.ToString("F1")+" distance="+dT.ToString("N1"));
                }while(kp&gt;dT);Echo("COS:X");return lg;}Vector3D lw;void lx(Vector3D dR){if(kD&gt;=0)kD+=Runtime.TimeSinceLastRun.TotalMilliseconds;
                if(kF&gt;=0)kF+=Runtime.TimeSinceLastRun.TotalMilliseconds;Vector3D ly;if(bW.HitPosition.HasValue){ly=(Vector3D)bW.HitPosition;
                }else{ly=nO.GetPosition();}Vector3D bj=bW.Position;Vector3D dS=(bj-ly);dS.Normalize();Vector3D lz=bW.BoundingBox.Min;
                Vector3D lA=bW.BoundingBox.Max;double lB=(bj-lz).Length();double lC=lB+ia.ir()*5;Vector3D lD;lD=Vector3D.Cross(dR,
                ly);lD.Normalize();lD=ly+lD*lC;lw=lD;}bool lE=true;bool lF=true;bool lG=true;bool lH=true;bool lI=true;
                bool lJ=true;MyDetectedEntityInfo lK=new MyDetectedEntityInfo();MyDetectedEntityInfo lL=new MyDetectedEntityInfo();
                MyDetectedEntityInfo lM=new MyDetectedEntityInfo();MyDetectedEntityInfo lN=new MyDetectedEntityInfo();
                MyDetectedEntityInfo lO=new MyDetectedEntityInfo();MyDetectedEntityInfo lP=new MyDetectedEntityInfo();
                void lQ(){if(kD&gt;=0)kD+=Runtime.TimeSinceLastRun.TotalMilliseconds;if(kF&gt;=0)kF+=Runtime.TimeSinceLastRun.TotalMilliseconds;
                lE=true;lF=true;lG=true;lH=true;lI=false;lJ=true;lK=new MyDetectedEntityInfo();lL=new MyDetectedEntityInfo();
                lM=new MyDetectedEntityInfo();lN=new MyDetectedEntityInfo();lO=new MyDetectedEntityInfo();lP=new MyDetectedEntityInfo();
                if(bW.Type==MyDetectedEntityType.LargeGrid||bW.Type==MyDetectedEntityType.SmallGrid){}if(bS.Count&lt;1)
                lE=false;if(bT.Count&lt;1)lF=false;if(bR.Count&lt;1)lG=false;if(bQ.Count&lt;1)lH=false;if(bO.Count&lt;1)lJ=false;
                if(bP.Count&lt;1)lI=false;}bool lR(){if(kD&gt;=0)kD+=Runtime.TimeSinceLastRun.TotalMilliseconds;if(kF&gt;=0)kF
                +=Runtime.TimeSinceLastRun.TotalMilliseconds;MatrixD lS=nO.WorldMatrix;Vector3D dS=lS.Forward;Echo("ScanEscape()");
                if(lE){if(bZ(bS,200)){lE=false;lK=bW;if(bW.IsEmpty()){dS=lS.Left;dS.Normalize();lw=nO.GetPosition()+
                dS*200;return true;}}}if(lF){if(bZ(bT,200)){lF=false;lL=bW;if(bW.IsEmpty()){dS=lS.Right;dS.Normalize();
                lw=nO.GetPosition()+dS*200;return true;}}}if(lG){if(bZ(bR,200)){lM=bW;lG=false;if(bW.IsEmpty()){dS=lS.Up;
                dS.Normalize();lw=nO.GetPosition()+dS*200;return true;}}}if(lH){if(bZ(bQ,200)){lN=bW;lH=false;if(bW.IsEmpty())
                {dS=lS.Down;dS.Normalize();lw=nO.GetPosition()+dS*200;return true;}}}if(lI){if(bZ(bP,200)){lO=bW;lI=
                false;if(bW.IsEmpty()){dS=lS.Backward;dS.Normalize();lw=nO.GetPosition()+dS*200;return true;}}}if(lJ)
                {if(bZ(bO,200)){lJ=false;if(bW.IsEmpty()){dS=lS.Forward;dS.Normalize();lw=nO.GetPosition()+dS*200;return
                true;}}}if(lJ||lI||lG||lH||lE||lF){Echo("More scans");return false;}Echo("Scans done. Choose longest");
                MyDetectedEntityInfo lT=lO;Vector3D lU=nO.GetPosition();dS=lS.Backward;if(lT.HitPosition==null||lK.HitPosition
                !=null&amp;&amp;Vector3D.DistanceSquared(lU,(Vector3D)lT.HitPosition)&lt;Vector3D.DistanceSquared(lU,(Vector3D)lK.HitPosition))
                {dS=lS.Left;lT=lK;}if(lT.HitPosition==null||lL.HitPosition!=null&amp;&amp;Vector3D.DistanceSquared(lU,(Vector3D)lT.HitPosition)
                &lt;Vector3D.DistanceSquared(lU,(Vector3D)lL.HitPosition)){dS=lS.Right;lT=lL;}if(lT.HitPosition==null||
                lM.HitPosition!=null&amp;&amp;Vector3D.DistanceSquared(lU,(Vector3D)lT.HitPosition)&lt;Vector3D.DistanceSquared(lU,
                (Vector3D)lM.HitPosition)){dS=lS.Up;lT=lM;}if(lT.HitPosition==null||lN.HitPosition!=null&amp;&amp;Vector3D.DistanceSquared(lU,
                (Vector3D)lT.HitPosition)&lt;Vector3D.DistanceSquared(lU,(Vector3D)lN.HitPosition)){dS=lS.Down;lT=lN;}if
                (lT.HitPosition==null||lP.HitPosition!=null&amp;&amp;Vector3D.DistanceSquared(lU,(Vector3D)lT.HitPosition)&lt;Vector3D.DistanceSquared(lU,
                (Vector3D)lP.HitPosition)){dS=lS.Forward;lT=lP;}if(lT.HitPosition==null)return false;double dT=Vector3D.Distance(lU,
                (Vector3D)lT.HitPosition);Echo("Distance="+fb(dT));dS.Normalize();lw=nO.GetPosition()+dS*dT/2;if(dT&gt;
                4){return true;}return false;}void lV(float ed){if(la){gB(ed);}else jW(kJ,ed);}void lW(double maxSpeed,
                float maxThrust){if(!la){if(iM&lt;1)jW(kJ,maxThrust);else if(iM&lt;maxSpeed*.75)jW(kJ,25f);else if(iM&lt;maxSpeed
                *.85)jW(kJ,15f);else if(iM&lt;=maxSpeed*.98){jW(kJ,1f);}else if(iM&gt;=maxSpeed*1.02){ka(iT);}else{ka(iT);
                ka(kI,jm,true);}}else{lV(maxThrust);}}bool lX=false;List&lt;IMyRadioAntenna&gt;lY=new List&lt;IMyRadioAntenna&gt;();
                List&lt;IMyLaserAntenna&gt;lZ=new List&lt;IMyLaserAntenna&gt;();string ma(){lY.Clear();lZ.Clear();nG&lt;IMyRadioAntenna&gt;(ref
                lY);nG&lt;IMyLaserAntenna&gt;(ref lZ);for(int i1=0;i1&lt;lY.Count;++i1){if(lY[i1].CustomName.Contains("unused")
                ||lY[i1].CustomData.Contains("unused"))continue;if(!lX){a="Wico "+lY[i1].CustomName.Split('!')[0].Trim();
                lX=true;}}return"A"+lY.Count.ToString("0");}void mb(){for(int i=0;i&lt;lY.Count;i++){lY[i].Enabled=true;
                }}string mc="";void md(){if(hU!=""){if(mc==hU){hU="";}mc=hU;}else mc="";}void me(){}void mf(){float mg
                =0;int mh=-1;for(int i=0;i&lt;lY.Count;i++){if(lY[i].AttachedProgrammableBlock==Me.EntityId){mh=i;break;
                }if(lY[i].Radius&gt;mg&amp;&amp;lY[i].AttachedProgrammableBlock==0){mh=i;mg=lY[i].Radius;}}if(mh&gt;=0){if(lY[mh].AttachedProgrammableBlock
                !=Me.EntityId)fh+="\nSetting Antenna PB";lY[mh].AttachedProgrammableBlock=Me.EntityId;}else{}}void mi(bool
                mj=false){if(lY.Count&lt;1)ma();foreach(var a in lY){a.Radius=200;if(a.AttachedProgrammableBlock&gt;0||mj)
                {a.Enabled=true;}}}void mk(float ml=200,bool mj=false){if(lY.Count&lt;1)ma();foreach(var a1 in lY){if(a1.AttachedProgrammableBlock
                &gt;0||mj){a1.Radius=ml;a1.Enabled=true;}}}Vector3D mm(){if(lY.Count&lt;1)ma();foreach(var a1 in lY){if(a1.AttachedProgrammableBlock
                ==Me.EntityId){return a1.GetPosition();}}foreach(var a1 in lY){return a1.GetPosition();}Vector3D mn=
                new Vector3D();return mn;}void mo(bool mj=false,float mp=float.MaxValue){if(lY==null||lY.Count&lt;1)ma();
                if(mp&lt;200)mp=200;foreach(var a in lY){if(a.AttachedProgrammableBlock&gt;0||mj){float mq=a.GetMaximum&lt;float&gt;("Radius");
                if(mp&lt;mq)mq=mp;a.Radius=mq;a.Enabled=true;}}}int mr(){if(lY.Count&lt;1)ma();return(lY.Count);}List&lt;string&gt;
                ms=new List&lt;string&gt;();void mt(){if(ms.Count&gt;0){mu(ms[0]);ms.RemoveAt(0);}if(ms.Count&gt;0)iJ=true;}void
                mu(string mv){bool mw=false;if(lY.Count&lt;1)ma();for(int i=0;i&lt;lY.Count;i++){mw=lY[i].TransmitMessage(mv);
                if(mw)break;}if(!mw){if(mr()&gt;0){ms.Add(mv);iJ=true;}}}List&lt;string&gt;mx=new List&lt;string&gt;();void my(bool
                mz=false){if(mx.Count&gt;0){if(hU==""){hU=mx[0];mx.RemoveAt(0);if(mz){iJ=true;}else{ky();}}}if(mx.Count
                &gt;0){}}void mA(string mv){mx.Add(mv);my();}void mB(){if(lY.Count&gt;0){Echo(mx.Count+" Pending Incoming Messages");
                for(int i=0;i&lt;mx.Count;i++)Echo(i+":"+mx[i]);}else Echo("No antennas found");}List&lt;IMyTerminalBlock&gt;
                mC=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;mD=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                mE=new List&lt;IMyTerminalBlock&gt;();bool mF=false;string mG="[BASE]";string mH="[DOCK]";string mI="CONNECTORS";
                void mJ(oo iNIHolder){iNIHolder.oP(mI,"BaseConnector",ref mG,true);iNIHolder.oP(mI,"DockConnector",ref
                mH,true);}string mK(){mF=false;mC.Clear();mD.Clear();mE.Clear();mL();return"CL"+mC.Count.ToString()+
                "CD"+mD.Count.ToString()+"CB"+mE.Count.ToString();}void mL(){if(mC.Count&lt;1&amp;&amp;!mF)mC=nG&lt;IMyShipConnector&gt;();
                if(mD.Count&lt;1&amp;&amp;!mF)mD=nJ&lt;IMyShipConnector&gt;(mH);if(mD.Count&lt;1&amp;&amp;!mF)mD=mC;if(mE.Count&lt;1&amp;&amp;!mF)mE=nJ&lt;IMyShipConnector&gt;(mG);
                mF=true;return;}bool mM(){mL();for(int i=0;i&lt;mD.Count;i++){var mN=mD[i]as IMyShipConnector;if(mN==null)
                continue;if(mN.Status==MyShipConnectorStatus.Connectable)return true;}return false;}bool mO(){mL();for
                (int i=0;i&lt;mD.Count;i++){var mN=mD[i]as IMyShipConnector;if(mN==null)continue;if(mN.Status==MyShipConnectorStatus.Connected)
                {var mP=mN.OtherConnector;if(mP.CubeGrid==mN.CubeGrid){continue;}else return true;}}return false;}IMyTerminalBlock
                mQ(){mL();if(mD.Count&gt;0){return mD[0];}return null;}IMyTerminalBlock mR(bool mS=false){mL();for(int i
                =0;i&lt;mD.Count;i++){var mN=mD[i]as IMyShipConnector;if(mN==null)continue;if(mN.Status==MyShipConnectorStatus.Connected)
                {var mP=mN.OtherConnector;if(mP.CubeGrid==mN.CubeGrid){continue;}else{if(!mS){return mN.OtherConnector;
                }else{return mD[i];}}}}return null;}void mT(bool mU=true,bool bK=true){mL();for(int i=0;i&lt;mD.Count;i++)
                {var mN=mD[i]as IMyShipConnector;if(mN==null)continue;if(mN.Status==MyShipConnectorStatus.Connected)
                {var mP=mN.OtherConnector;if(mP.CubeGrid==mN.CubeGrid){continue;}}if(mU){if(mN.Status==MyShipConnectorStatus.Connectable)
                mN.ApplyAction("SwitchLock");}else{if(mN.Status==MyShipConnectorStatus.Connected)mN.ApplyAction("SwitchLock");
                }mN.Enabled=bK;}return;}string mV="NOFOLLOW";string mW="!WCC";string mX="[NAV]";string mY="Craft Remote Control";
                string mZ="GRIDS";void na(oo iNIHolder){iNIHolder.oP(mZ,"NoFollow",ref mV,true);iNIHolder.oP(mZ,"BlockIgnore",
                ref mW,true);iNIHolder.oP(mZ,"OrientationBlockContains",ref mX,true);iNIHolder.oP(mZ,"OrientationBlockNamed",
                ref mY,true);}List&lt;IMyTerminalBlock&gt;nb=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTextPanel&gt;nc=new List&lt;IMyTextPanel&gt;();
                List&lt;IMyTextPanel&gt;nd=new List&lt;IMyTextPanel&gt;();List&lt;IMyTerminalBlock&gt;ne=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyCubeGrid&gt;nf=new List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;ng=new List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;
                nh=new List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;ni=new List&lt;IMyCubeGrid&gt;();bool nj(){List&lt;IMyTerminalBlock&gt;
                nk=new List&lt;IMyTerminalBlock&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyTerminalBlock&gt;(nk);if(allBlocksCount
                !=nk.Count){return true;}return false;}string nl(){nb.Clear();ni.Clear();nf.Clear();ng.Clear();nh.Clear();
                nc.Clear();nd.Clear();GridTerminalSystem.GetBlocksOfType&lt;IMyTerminalBlock&gt;(nb);allBlocksCount=nb.Count;
                foreach(var block in nb){var bu=block.CubeGrid;if(!ni.Contains(bu)){ni.Add(bu);}}no(Me.CubeGrid);foreach
                (var grid in ni){if(nf.Contains(grid))continue;bool nm=false;List&lt;IMyShipConnector&gt;nn=new List&lt;IMyShipConnector&gt;();
                GridTerminalSystem.GetBlocksOfType&lt;IMyShipConnector&gt;(nn,(x1=&gt;x1.CubeGrid==grid));foreach(var connector
                in nn){if(connector.Status==MyShipConnectorStatus.Connected){if(nf.Contains(connector.OtherConnector.CubeGrid)
                ||ng.Contains(connector.OtherConnector.CubeGrid)){continue;}if(nf.Contains(connector.OtherConnector.CubeGrid))
                nm=true;else nm=false;}}if(nm){if(!nh.Contains(grid)){nh.Add(grid);}}if(!ng.Contains(grid)){ng.Add(grid);
                }}string s="";s+="B"+nb.Count.ToString();s+="G"+ni.Count.ToString();s+="L"+nf.Count.ToString();s+="D"
                +nh.Count.ToString();s+="R"+ng.Count.ToString();return s;}void no(IMyCubeGrid bu){if(bu==null)return;
                if(!nf.Contains(bu)){nf.Add(bu);np(bu);ns(bu);nu(bu);nw(bu);}}void np(IMyCubeGrid grid){List&lt;IMyMotorStator&gt;
                nq=new List&lt;IMyMotorStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(nq,(x=&gt;x.TopGrid==grid));
                foreach(var rotor in nq){if(rotor.CustomName.Contains(mV)||rotor.CustomData.Contains(mV))continue;no(rotor.CubeGrid);
                }List&lt;IMyMotorAdvancedStator&gt;nr=new List&lt;IMyMotorAdvancedStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorAdvancedStator&gt;(nr,
                (x=&gt;x.TopGrid==grid));foreach(var rotor in nr){if(rotor.CustomName.Contains(mV)||rotor.CustomData.Contains(mV))
                continue;no(rotor.CubeGrid);}}void ns(IMyCubeGrid grid){List&lt;IMyPistonBase&gt;nt=new List&lt;IMyPistonBase&gt;();
                GridTerminalSystem.GetBlocksOfType&lt;IMyPistonBase&gt;(nt,(x=&gt;x.TopGrid==grid));foreach(var piston in nt)
                {no(piston.CubeGrid);}}void nu(IMyCubeGrid grid){List&lt;IMyMotorStator&gt;nq=new List&lt;IMyMotorStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(nq,
                (x1=&gt;x1.CubeGrid==grid));foreach(var rotor in nq){if(rotor.CustomName.Contains(mV)||rotor.CustomData.Contains(mV))
                continue;IMyCubeGrid nv=rotor.TopGrid;if(nv!=null&amp;&amp;nv!=grid){no(nv);}}nq.Clear();List&lt;IMyMotorAdvancedStator&gt;
                nr=new List&lt;IMyMotorAdvancedStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorAdvancedStator&gt;(nr,
                (x1=&gt;x1.CubeGrid==grid));foreach(var rotor in nr){if(rotor.CustomName.Contains(mV)||rotor.CustomData.Contains(mV))
                continue;IMyCubeGrid nv=rotor.TopGrid;if(nv!=null&amp;&amp;nv!=grid){no(nv);}}}void nw(IMyCubeGrid grid){List&lt;IMyPistonBase&gt;
                nt=new List&lt;IMyPistonBase&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyPistonBase&gt;(nt,(x1=&gt;x1.CubeGrid==
                grid));foreach(var piston in nt){IMyCubeGrid nv=piston.TopGrid;if(nv!=null&amp;&amp;nv!=grid){if(!nf.Contains(nv))
                {no(nv);}}}}List&lt;IMyCubeGrid&gt;nx(){if(nf.Count&lt;1){nl();}return nf;}List&lt;IMyCubeGrid&gt;ny(){if(nf.Count&lt;
                1){nl();}return nh;}bool nz(IMyTerminalBlock block){return nx().Contains(block.CubeGrid);}bool nA(long
                nB){for(int i1=0;i1&lt;nf.Count;i1++){if((long)nf[i1].EntityId==nB)return true;}return false;}bool nA(IMyCubeGrid
                nB){return nx().Contains(nB);}bool nC(IMyTerminalBlock hg){var g1=ny();if(g1==null)return false;return
                g1.Contains(hg.CubeGrid);}void nD(){if(nb.Count&lt;1)nl();ne.Clear();foreach(var b1 in nb){if(nz(b1)&amp;&amp;!(b1.CustomName.Contains(mW)
                ||b1.CustomData.Contains(mW)))ne.Add(b1);}}IMyTerminalBlock nE(string nF){IMyTerminalBlock hg;hg=(IMyTerminalBlock)GridTerminalSystem.GetBlockWithName(nF);
                if(hg==null)throw new Exception(nF+" Not Found");return hg;}public List&lt;T&gt;nG&lt;T&gt;(ref List&lt;T&gt;nH,string
                nI=null)where T:class{if(nH==null)nH=new List&lt;T&gt;();else nH.Clear();if(ne.Count&lt;1)nD();for(int e1=0;e1
                &lt;ne.Count;e1++){if(ne[e1]is T&amp;&amp;((nI==null)||(nI!=null&amp;&amp;ne[e1].CustomName.StartsWith(nI)))){nH.Add((T)ne[e1]);
                }}return nH;}public List&lt;IMyTerminalBlock&gt;nG&lt;T&gt;(ref List&lt;IMyTerminalBlock&gt;nH,string nI=null)where T:
                class{if(nb.Count&lt;1)nl();if(nH==null)nH=new List&lt;IMyTerminalBlock&gt;();else nH.Clear();if(ne.Count&lt;1)nD();
                for(int e1=0;e1&lt;ne.Count;e1++){if(ne[e1]is T&amp;&amp;((nI==null)||(nI!=null&amp;&amp;ne[e1].CustomName.StartsWith(nI))))
                {nH.Add(ne[e1]);}}return nH;}public List&lt;IMyTerminalBlock&gt;nG&lt;T&gt;(string nI=null)where T:class{var nH=
                new List&lt;IMyTerminalBlock&gt;();nG&lt;T&gt;(ref nH,nI);return nH;}public List&lt;IMyTerminalBlock&gt;nJ&lt;T&gt;(string Keyword
                =null)where T:class{var nH=new List&lt;IMyTerminalBlock&gt;();if(ne.Count&lt;1)nD();for(int e1=0;e1&lt;ne.Count;
                e1++){if(ne[e1]is T&amp;&amp;Keyword!=null&amp;&amp;(ne[e1].CustomName.Contains(Keyword)||ne[e1].CustomData.Contains(Keyword)))
                {nH.Add(ne[e1]);}}return nH;}public List&lt;IMyTextPanel&gt;nK(string nI=null){if(nb.Count&lt;1)nl();var nH=new
                List&lt;IMyTextPanel&gt;();if(nc.Count&gt;1){foreach(var t1 in nc){if(nI!=null&amp;&amp;(t1.CustomName.Contains(nI)||
                t1.CustomData.Contains(nI)))nH.Add(t1);}}else{foreach(var t1 in nb){if(t1 is IMyTextPanel&amp;&amp;nz(t1)&amp;&amp;!(t1.CustomName.Contains(mW)
                ||t1.CustomData.Contains(mW))){if(nI!=null&amp;&amp;(t1.CustomName.Contains(nI)||t1.CustomData.Contains(nI)))
                nH.Add(t1 as IMyTextPanel);nc.Add(t1 as IMyTextPanel);}}}return nH;}public List&lt;IMyTextPanel&gt;nL(string
                nI=null){if(ne.Count&lt;1)nD();var nH=new List&lt;IMyTextPanel&gt;();if(nd.Count&gt;1){foreach(var t1 in nd){if(nI
                !=null&amp;&amp;(t1.CustomName.Contains(nI)||t1.CustomData.Contains(nI)))nH.Add(t1);}}else{foreach(var t1 in
                ne){if(t1 is IMyTextPanel&amp;&amp;Me.CubeGrid==t1.CubeGrid){if(nI!=null&amp;&amp;(t1.CustomName.Contains(nI)||t1.CustomData.Contains(nI)))
                nH.Add(t1 as IMyTextPanel);nd.Add(t1 as IMyTextPanel);}}}return nH;}public List&lt;IMyTerminalBlock&gt;nM&lt;T&gt;(string
                nI=null)where T:class{if(ne.Count&lt;1)nD();var nH=new List&lt;IMyTerminalBlock&gt;();for(int e1=0;e1&lt;ne.Count;
                e1++){if(ne[e1]is T&amp;&amp;Me.CubeGrid==ne[e1].CubeGrid&amp;&amp;nI!=null&amp;&amp;(ne[e1].CustomName.Contains(nI)||ne[e1].CustomData.Contains(nI)))
                {nH.Add(ne[e1]);}}return nH;}public List&lt;IMyTerminalBlock&gt;nN&lt;T&gt;(string nI=null)where T:class{if(ne.Count
                &lt;1)nD();var nH=new List&lt;IMyTerminalBlock&gt;();for(int e1=0;e1&lt;ne.Count;e1++){if(ne[e1]is T&amp;&amp;nI!=null&amp;&amp;
                ne[e1].CustomName==nI){nH.Add(ne[e1]);}}return nH;}IMyTerminalBlock nO=null;string DefaultOrientationBlockInit()
                {string sInitResults="";var centerSearch=new List&lt;IMyTerminalBlock&gt;();nG&lt;IMyTerminalBlock&gt;(ref centerSearch,
                mY);if(centerSearch.Count==0){centerSearch=nJ&lt;IMyRemoteControl&gt;(mX);if(centerSearch.Count==0){nG&lt;IMyRemoteControl&gt;(ref
                centerSearch);if(centerSearch.Count==0){nG&lt;IMyCockpit&gt;(ref centerSearch);int i=0;for(;i&lt;centerSearch.Count;
                i++){Echo("Checking Controller:"+centerSearch[i].CustomName);if(centerSearch[i]is IMyCryoChamber)continue;
                break;}if(i&gt;=centerSearch.Count){sInitResults+="!!NO valid Controller";Echo("No Controller found");}
                else{sInitResults+="S";Echo("Using good ship Controller: "+centerSearch[i].CustomName);}}else{sInitResults
                +="R";Echo("Using First Remote control found: "+centerSearch[0].CustomName);}}}else{sInitResults+="N";
                Echo("Using Named: "+centerSearch[0].CustomName);}if(centerSearch.Count&gt;0)nO=centerSearch[0];return sInitResults;
                }string nR="!NAV";void nS(oo f){f.oP(mZ,"GyroIgnore",ref nR,true);f.oP(mZ,"LIMIT_GYROS",ref nU,true);
                f.oP(mZ,"LEAVE_GYROS",ref nV,true);f.oP(mZ,"CTRL_COEFF",ref nT,true);}double nT=0.9;int nU=3;int nV=
                -1;IMyShipController nW;List&lt;IMyGyro&gt;nX;float nY=0.01f;bool GyroMain(string argument){if(nW==null)ol();
                if(nW is IMyShipController){Vector3D dK=(nW as IMyShipController).GetNaturalGravity();return nZ(argument,
                dK,nO);}else{Echo("No Controller for gravity");}return true;}bool nZ(string oa,Vector3D ob,IMyTerminalBlock
                oc){bool dL=true;if(nW==null)ol();Matrix or;oc.Orientation.GetMatrix(out or);Vector3D od;oa=oa.ToLower();
                if(oa.Contains("rocket"))od=or.Backward;else if(oa.Contains("up"))od=or.Up;else if(oa.Contains("backward"))
                od=or.Backward;else if(oa.Contains("forward"))od=or.Forward;else od=or.Down;ob.Normalize();for(int i
                =0;i&lt;nX.Count;++i){var g=nX[i];g.Orientation.GetMatrix(out or);var oe=Vector3D.Transform(od,MatrixD.Transpose(or));
                var of=Vector3D.Transform(ob,MatrixD.Transpose(g.WorldMatrix.GetOrientation()));var og=Vector3D.Cross(oe,
                of);double oh=Vector3D.Dot(oe,of);double oi=og.Length();oi=Math.Atan2(oi,Math.Sqrt(Math.Max(0.0,1.0-
                oi*oi)));if(oh&lt;0)oi=Math.PI-oi;if(oi&lt;nY){g.GyroOverride=false;continue;}float oj=g.GetMaximum&lt;float&gt;("Yaw");
                double ok=oj*(oi/Math.PI)*nT;ok=Math.Min(oj,ok);ok=Math.Max(0.01,ok);og.Normalize();og*=ok;float Z=-(float)og.X;
                g.Pitch=Z;float X=-(float)og.Y;g.Yaw=X;float bb=-(float)og.Z;g.Roll=bb;g.GyroOverride=true;dL=false;
                }return dL;}string ol(){string s="";var l=new List&lt;IMyTerminalBlock&gt;();nW=nO as IMyShipController;if
                (nW==null){if(l.Count&lt;1)return"No RC!";}on();GridTerminalSystem.GetBlocksOfType&lt;IMyGyro&gt;(l,x=&gt;x.CubeGrid
                ==nO.CubeGrid);var l2=new List&lt;IMyTerminalBlock&gt;();int om=0;for(int i=0;i&lt;l.Count;i++){if(l[i].CustomName.Contains(nR)
                ||l[i].CustomData.Contains(nR)){om++;continue;}l2.Add(l[i]);}nX=l2.ConvertAll(x=&gt;(IMyGyro)x);if(nU&gt;0)
                {if(nX.Count&gt;nU){nX.RemoveRange(nU,nX.Count-nU);}else{if((nV-om)&gt;0){int hr=nX.Count-(nV-om);nX.RemoveRange(hr,
                (nV-om));}}}on();s+="GYRO#"+nX.Count.ToString("00")+"#";return s;}void on(){if(nX!=null){for(int i=0;
                i&lt;nX.Count;++i){nX[i].GyroOverride=false;nX[i].Enabled=true;}}}public class oo{Dictionary&lt;string,string&gt;
                op;Dictionary&lt;string,string[]&gt;oq;Dictionary&lt;string,Dictionary&lt;string,string&gt;&gt;or;char os='[';char ot=
                ']';string ou="";MyGridProgram cv;string ov="";static string[]ow={"true","yes","on","1"};const StringComparison
                ox=StringComparison.OrdinalIgnoreCase;const char oy='=';public bool oz{get;private set;}=false;public
                oo(MyGridProgram pg,string hJ){cv=pg;op=new Dictionary&lt;string,string&gt;();oq=new Dictionary&lt;string,string[]&gt;();
                or=new Dictionary&lt;string,Dictionary&lt;string,string&gt;&gt;();oA(hJ);}public int oA(string hJ){hJ.TrimEnd();
                if(ov==hJ){return op.Count;}op.Clear();oq.Clear();or.Clear();ou="";oz=false;ov=hJ;string[]oB=hJ.Split('\n');
                for(int oC=0;oC&lt;oB.Count();oC++){string oD="";oB[oC].Trim();if(oB[oC].StartsWith(os.ToString())){string
                cp="";for(int oE=1;oE&lt;oB[oC].Length;oE++)if(oB[oC][oE]==ot)break;else cp+=oB[oC][oE];if(cp!=""){oD=cp.ToUpper();
                }else continue;oC++;string oF="";var oG=new string[oB.Count()-oC];int oH=0;var oI=new Dictionary&lt;string,
                string&gt;();for(;oC&lt;oB.Count();oC++){oB[oC].Trim();if(oB[oC].StartsWith(os.ToString())){oC--;break;}oF
                +=oB[oC]+"\n";oG[oH++]=oB[oC];if(oB[oC].Contains(oy)){string[]oJ=oB[oC].Split('=');if(oJ.Count()&gt;1){
                string oK=oJ[0];string J="";for(int i1=1;i1&lt;oJ.Count();i1++){J+=oJ[i1];if(i1+1&lt;oJ.Count())J+=oy;}oI.Add(oK,
                J);}}}if(!or.ContainsKey(oD))or.Add(oD,oI);if(!oq.ContainsKey(oD))oq.Add(oD,oG);if(!op.ContainsKey(oD))
                op.Add(oD,oF);}else{ou+=oB[oC]+"\n";}}return op.Count;}public string oL(string oM){string oF="";if(op.ContainsKey(oM))
                oF=op[oM];return oF;}public string[]oN(string oM){string[]oO={""};if(oq.ContainsKey(oM))oO=oq[oM];return
                oO;}public bool oP(string oM,string oK,ref string oQ,bool oR=false){oM=oM.ToUpper();if(or.ContainsKey(oM))
                {var oS=or[oM];if(oS.ContainsKey(oK)){oQ=oS[oK];return true;}}if(oR)pc(oM,oK,oQ);return false;}public
                bool oP(string oM,string oK,ref long oT,bool oR=false){string oU="";if(!oP(oM,oK,ref oU)){if(oR){pc(oM,
                oK,oT);}return false;}oT=Convert.ToInt64(oU);return true;}public bool oP(string oM,string oK,ref int
                oV,bool oR=false){string oU="";if(!oP(oM,oK,ref oU)){if(oR){pc(oM,oK,oV);}return false;}oV=Convert.ToInt32(oU);
                return true;}public bool oP(string oM,string oK,ref double oW,bool oR=false){string oU="";if(!oP(oM,
                oK,ref oU)){if(oR){pc(oM,oK,oW);}return false;}bool oX=double.TryParse(oU,out oW);return true;}public
                bool oP(string oM,string oK,ref float oY,bool oR=false){string oU="";if(!oP(oM,oK,ref oU)){if(oR){pc(oM,
                oK,oY.ToString());}return false;}bool oX=float.TryParse(oU,out oY);return true;}public bool oP(string
                oM,string oK,ref DateTime oZ,bool oR=false){string oU="";if(!oP(oM,oK,ref oU)){if(oR){pc(oM,oK,oZ);}
                return false;}oZ=DateTime.Parse(oU);return true;}public bool oP(string oM,string oK,ref Vector3D pa,
                bool oR=false){string oU="";if(!oP(oM,oK,ref oU)){if(oR){pc(oM,oK,pa);}return false;}double x1,y1,z1;
                hY(oU,out x1,out y1,out z1);pa.X=x1;pa.Y=y1;pa.Z=z1;return true;}public bool oP(string oM,string oK,
                ref bool pb,bool oR=false){string oU="";if(!oP(oM,oK,ref oU)){if(oR){pc(oM,oK,pb);}return false;}pb=
                ow.Any(c=&gt;string.Equals(oU,c,ox));return true;}public bool pc(string section,string key,string oU){if
                (op.ContainsKey(section)){op[section]="";}else{op.Add(section,"");oz=true;}if(or.ContainsKey(section))
                {var oI=new Dictionary&lt;string,string&gt;();var oS=or[section];if(oS.ContainsKey(key)){if(oS[key]==oU)return
                false;oS[key]=oU;}else{oS.Add(key,oU);}oz=true;}else{var oI=new Dictionary&lt;string,string&gt;();oI.Add(key,
                oU);or.Add(section,oI);oz=true;}return true;}public bool pc(string oM,string oK,Vector3D pa){pc(oM,oK,
                hX(pa));return true;}public bool pc(string oM,string oK,bool pb){pc(oM,oK,pb.ToString());return true;
                }public bool pc(string oM,string oK,int pd){pc(oM,oK,pd.ToString());return true;}public bool pc(string
                oM,string oK,long pe){pc(oM,oK,pe.ToString());return true;}public bool pc(string oM,string oK,DateTime
                oZ){pc(oM,oK,oZ.ToString());return true;}public bool pc(string oM,string oK,float oY){pc(oM,oK,oY.ToString());
                return true;}public bool pc(string oM,string oK,double oW){pc(oM,oK,oW.ToString());return true;}public
                void pf(string oM,string oF){oF.TrimEnd();oM=oM.ToUpper();if(op.ContainsKey(oM)){if(op[oM]!=oF){op[oM]
                =oF;oz=true;}}else{oz=true;op.Add(oM,oF);}}public string pg(bool ph=true){string pi="";string s1=ou.Trim();
                if(s1!="")pi=s1+"\n";foreach(var kv in op){pi+=os+kv.Key.Trim()+ot+"\n";if(kv.Value.TrimEnd()==""){string
                pj="";if(or.ContainsKey(kv.Key)){foreach(var dk in or[kv.Key]){pj+=dk.Key+oy+dk.Value+"\n";}}pj+="\n";
                pi+=pj;}else{pi+=kv.Value.Trim()+"\n\n";}}if(ph){oz=false;ov=pi;}return pi;}bool hY(string hZ,out double
                x,out double y,out double z){string[]hz=hZ.Trim().Split(',');if(hz.Length&lt;3){hz=hZ.Trim().Split(':');
                }x=0;y=0;z=0;if(hz.Length&lt;3)return false;bool hC=double.TryParse(hz[0].Trim(),out x);bool hD=double.TryParse(hz[1].Trim(),
                out y);bool hE=double.TryParse(hz[2].Trim(),out z);if(!hC||!hD||!hE){return false;}return true;}string
                hX(Vector3D v){string s;s=v.X.ToString("0.00")+":"+v.Y.ToString("0.00")+":"+v.Z.ToString("0.00");return
                s;}}List&lt;IMyTerminalBlock&gt;pk=new List&lt;IMyTerminalBlock&gt;();string pl(){pk.Clear();pk=nG&lt;IMyLightingBlock&gt;();
                return"L"+pk.Count.ToString("00");}void pm(List&lt;IMyTerminalBlock&gt;pk,Color c){for(int i=0;i&lt;pk.Count;
                i++){var pn=pk[i]as IMyLightingBlock;if(pn==null)continue;if(pn.Color.Equals(c)&amp;&amp;pn.Enabled){continue;
                }pn.Color=c;}}List&lt;IMySensorBlock&gt;po=new List&lt;IMySensorBlock&gt;();string pp="[WICO]";double pq=0.125;const
                string pr="SENSORS";void ps(oo f){f.oP(pr,"SensorUse",ref pp,true);f.oP(pr,"SensorSettleWaitMS",ref pq,
                true);}string pt(bool pu=true){po.Clear();List&lt;IMyTerminalBlock&gt;pv=nJ&lt;IMySensorBlock&gt;(pp);foreach(var
                sb1 in pv){po.Add(sb1 as IMySensorBlock);}if(pu)py();return"S"+po.Count.ToString("00");}List&lt;IMySensorBlock&gt;
                pw(string px=null){List&lt;IMySensorBlock&gt;pw=new List&lt;IMySensorBlock&gt;();for(int i1=0;i1&lt;po.Count;i1++){
                IMySensorBlock s=po[i1]as IMySensorBlock;if(s==null)continue;if(s.IsActive&amp;&amp;s.Enabled&amp;&amp;!s.LastDetectedEntity.IsEmpty())
                {pw.Add(po[i1]);}}return pw;}void py(){for(int i1=0;i1&lt;po.Count;i1++){IMySensorBlock pz=po[i1]as IMySensorBlock;
                if(pz==null)continue;pz.LeftExtend=pz.RightExtend=pz.TopExtend=pz.BottomExtend=pz.FrontExtend=pz.BackExtend
                =1;pz.Enabled=false;}}void pA(IMyTerminalBlock tb,float pB,float pC,float pD,float pE,float pF,float
                pG){IMySensorBlock pz=tb as IMySensorBlock;if(pz==null)return;float pH=pz.Position.X*0.5f;float pI=pz.Position.Y
                *0.5f;float pJ=pz.Position.Z*0.5f;Echo("SB.x.y.z="+pH.ToString("0.0")+":"+pI.ToString("0.0")+":"+pJ.ToString("0.0"));
                Echo("MIN="+Me.CubeGrid.Min.ToString()+"\nMAX:"+Me.CubeGrid.Max.ToString());float pK;pK=(float)(ia.ir()
                /2-pH+pB);pz.LeftExtend=Math.Max(pK,1.0f);pK=(float)(ia.ir()/2+pH+pC);pz.RightExtend=Math.Max(pK,1.0f);
                pK=(float)(ia.it()/2-pI+pD);pz.TopExtend=Math.Max(pK,1.0f);pK=(float)(ia.it()/2+pI+pE);pz.BottomExtend
                =Math.Max(pK,1.0f);pK=(float)(ia.ip()+pJ+pF);pz.FrontExtend=Math.Max(pK,1.0f);pK=(float)(ia.ip()-pJ+
                pG);pz.BackExtend=Math.Max(pK,1.0f);pz.Enabled=true;}bool pL(IMySensorBlock s1,ref bool pM,ref bool pN,
                ref bool pO){pM=false;pN=false;pO=false;if(s1!=null&amp;&amp;s1.IsActive&amp;&amp;s1.Enabled&amp;&amp;!s1.LastDetectedEntity.IsEmpty())
                {List&lt;MyDetectedEntityInfo&gt;pP=new List&lt;MyDetectedEntityInfo&gt;();s1.DetectedEntities(pP);for(int j1=0;
                j1&lt;pP.Count;j1++){if(pP[j1].Type==MyDetectedEntityType.Asteroid){pM=true;}else if(pP[j1].Type==MyDetectedEntityType.LargeGrid)
                {pN=true;}else if(pP[j1].Type==MyDetectedEntityType.SmallGrid){pO=true;}}}return pM||pN||pO;}List&lt;IMyTerminalBlock&gt;
                pQ=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;pR=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                pS=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;pT=new List&lt;IMyTerminalBlock&gt;();string pU(IMyTerminalBlock
                cj){pQ.Clear();pR.Clear();pS.Clear();pT.Clear();nG&lt;IMyMotorSuspension&gt;(ref pQ);for(int i=0;i&lt;pQ.Count;
                i++){if(pQ[i].CustomName.Contains("[SLED]")||pQ[i].CustomData.Contains("[SLED]")){pR.Add(pQ[i]);if(pQ[i].CustomName.Contains("[REAR]")
                ||pQ[i].CustomData.Contains("[FRONT]")){pS.Add(pQ[i]);}if(pQ[i].CustomName.Contains("[FRONT]")||pQ[i].CustomData.Contains("[FRONT]"))
                {pT.Add(pQ[i]);}}}return"W"+pQ.Count.ToString("0")+"WS"+pR.Count.ToString("0")+"SR"+pS.Count.ToString("0")
                +"SF"+pT.Count.ToString("0");}bool pV(){if(pR.Count&gt;0)return true;return false;}void pW(){for(int i1
                =0;i1&lt;pR.Count;i1++){var w1=pR[i1]as IMyMotorSuspension;w1.SetValueFloat("Friction",0);}}
              </Program>
              <Storage />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="0" y="7" z="-3" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_RemoteControl">
              <SubtypeName>SmallBlockRemoteControl</SubtypeName>
              <EntityId>106620596677207381</EntityId>
              <Min x="0" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Remote Control</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <UseSingleWeaponMode>false</UseSingleWeaponMode>
              <Toolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots>
                  <Slot>
                    <Index>0</Index>
                    <Item />
                    <Data xsi:type="MyObjectBuilder_ToolbarItemTerminalBlock">
                      <Action>View</Action>
                      <BlockEntityId>92772807856770308</BlockEntityId>
                    </Data>
                  </Slot>
                </Slots>
              </Toolbar>
              <SelectedGunId xsi:nil="true" />
              <BuildToolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots />
              </BuildToolbar>
              <PreviousControlledEntityId xsi:nil="true" />
              <AutoPilotEnabled>false</AutoPilotEnabled>
              <FlightMode>2</FlightMode>
              <BindedCamera>0</BindedCamera>
              <CurrentWaypointIndex>-1</CurrentWaypointIndex>
              <Waypoints />
              <Direction>0</Direction>
              <DockingModeEnabled>false</DockingModeEnabled>
              <CollisionAvoidance>false</CollisionAvoidance>
              <Coords />
              <Names />
              <WaypointThresholdDistance>0</WaypointThresholdDistance>
              <IsMainRemoteControl>false</IsMainRemoteControl>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCornerInv</SubtypeName>
              <Min x="-1" y="6" z="-2" />
              <BlockOrientation Forward="Backward" Up="Right" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Gyro">
              <SubtypeName>SmallBlockGyro</SubtypeName>
              <EntityId>88670430691776406</EntityId>
              <Min x="1" y="5" z="-3" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyModStorageComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_ModStorageComponent">
                      <Storage>
                        <dictionary>
                          <item>
                            <Key>74de02b3-27f9-4960-b1c4-27351f2b06d1</Key>
                            <Value>NAV: C test;D 80;S 10;W 10031.54:60388.83:4714.83:</Value>
                          </item>
                        </dictionary>
                      </Storage>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Gyro</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <GyroPower>0.158608809</GyroPower>
              <TargetAngularVelocity x="0.005108488" y="-0.0144461272" z="0" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="4" z="-2" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_TextPanel">
              <SubtypeName>SmallTextPanel</SubtypeName>
              <EntityId>76536456195904552</EntityId>
              <Min x="-1" y="5" z="-3" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Wico Craft Save</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Description />
              <Title>Title</Title>
              <AccessFlag>READ_AND_WRITE_FACTION</AccessFlag>
              <ChangeInterval>0</ChangeInterval>
              <SelectedImages />
              <Font Type="MyObjectBuilder_FontDefinition" Subtype="Debug" />
              <FontSize>1</FontSize>
              <PublicDescription>
                [WCCM2]
                Mode=0
                current_state=0
                PassedArgument=
                SaveID=76536456195904552
                AlertStates=0
                craft_operation=16
                ReceivedMessage=

                [NAV]
                vTarget=0.00:0.00:0.00
                ValidNavTarget=False
                dStartShip=01/01/0001 00:00:00
                shipSpeedMax=100
                arrivalDistanceMin=50

              </PublicDescription>
              <PublicTitle>Public title</PublicTitle>
              <ShowText>NONE</ShowText>
              <FontColor>
                <PackedValue>4294967295</PackedValue>
                <X>255</X>
                <Y>255</Y>
                <Z>255</Z>
                <R>255</R>
                <G>255</G>
                <B>255</B>
                <A>255</A>
              </FontColor>
              <BackgroundColor>
                <PackedValue>4278190080</PackedValue>
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R>0</R>
                <G>0</G>
                <B>0</B>
                <A>255</A>
              </BackgroundColor>
              <CurrentShownTexture>0</CurrentShownTexture>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="4" z="-2" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="3" y="4" z="-2" />
              <BlockOrientation Forward="Left" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCornerInv</SubtypeName>
              <Min x="1" y="6" z="-2" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="0" y="7" z="-2" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="2" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-2" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="3" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-3" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="4" z="-3" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="4" z="-3" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="6" z="-3" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="6" z="-3" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="3" y="6" z="-3" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-3" y="6" z="-3" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="3" y="4" z="-3" />
              <BlockOrientation Forward="Left" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-3" y="4" z="-3" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="4" z="-3" />
              <BlockOrientation Forward="Left" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="4" z="-3" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="5" z="-4" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_ReflectorLight">
              <SubtypeName>SmallBlockFrontLight</SubtypeName>
              <EntityId>114432575803042665</EntityId>
              <Min x="-4" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Spotlight 4</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Radius>10</Radius>
              <ReflectorRadius>120</ReflectorRadius>
              <ColorRed>0.215686277</ColorRed>
              <ColorGreen>0.270588249</ColorGreen>
              <Falloff>1</Falloff>
              <Intensity>3</Intensity>
              <BlinkIntervalSeconds>0</BlinkIntervalSeconds>
              <BlinkLenght>10</BlinkLenght>
              <BlinkOffset>0</BlinkOffset>
              <Offset>0.5</Offset>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="2" y="4" z="-4" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="-2" y="4" z="-4" />
              <BlockOrientation Forward="Up" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="1" y="4" z="-4" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="-1" y="4" z="-4" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="0" y="4" z="-4" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="5" z="-4" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="5" z="-4" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="2" y="6" z="-4" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="-2" y="6" z="-4" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CameraBlock">
              <SubtypeName>SmallCameraBlock</SubtypeName>
              <EntityId>92772807856770308</EntityId>
              <Min x="0" y="5" z="-5" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Camera [VIEW]</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <IsActive>false</IsActive>
              <Fov>0.9065726</Fov>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="0" y="6" z="-4" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="3" y="6" z="-4" />
              <BlockOrientation Forward="Left" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="-3" y="6" z="-4" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="3" y="4" z="-4" />
              <BlockOrientation Forward="Left" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="-3" y="4" z="-4" />
              <BlockOrientation Forward="Right" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="5" z="-4" />
              <BlockOrientation Forward="Left" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="5" z="-4" />
              <BlockOrientation Forward="Right" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="3" y="5" z="-4" />
              <BlockOrientation Forward="Left" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-3" y="5" z="-4" />
              <BlockOrientation Forward="Right" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="1" y="6" z="-4" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="-1" y="6" z="-4" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_ReflectorLight">
              <SubtypeName>SmallBlockFrontLight</SubtypeName>
              <EntityId>110102323221199669</EntityId>
              <Min x="4" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Spotlight 3</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Radius>10</Radius>
              <ReflectorRadius>120</ReflectorRadius>
              <ColorRed>0.215686277</ColorRed>
              <ColorGreen>0.270588249</ColorGreen>
              <Falloff>1</Falloff>
              <Intensity>3</Intensity>
              <BlinkIntervalSeconds>0</BlinkIntervalSeconds>
              <BlinkLenght>10</BlinkLenght>
              <BlinkOffset>0</BlinkOffset>
              <Offset>0.5</Offset>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="0" y="7" z="4" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_ReflectorLight">
              <SubtypeName>SmallBlockFrontLight</SubtypeName>
              <EntityId>125983560224695011</EntityId>
              <Min x="-2" y="5" z="3" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Spotlight 6</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Radius>10</Radius>
              <ReflectorRadius>120</ReflectorRadius>
              <ColorRed>0.215686277</ColorRed>
              <ColorGreen>0.270588249</ColorGreen>
              <Falloff>1</Falloff>
              <Intensity>3</Intensity>
              <BlinkIntervalSeconds>0</BlinkIntervalSeconds>
              <BlinkLenght>10</BlinkLenght>
              <BlinkOffset>0</BlinkOffset>
              <Offset>0.5</Offset>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>76595133755094313</EntityId>
              <Min x="1" y="3" z="-4" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Atmospheric Thrusters 4</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>123850218988362302</EntityId>
              <Min x="-1" y="3" z="-4" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Atmospheric Thrusters 5</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>89916389325667905</EntityId>
              <Min x="-3" y="4" z="5" />
              <BlockOrientation Forward="Left" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Atmospheric Thrusters 12</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>136132931721053196</EntityId>
              <Min x="1" y="4" z="5" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Atmospheric Thrusters 11</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_TextPanel">
              <SubtypeName>SmallTextPanel</SubtypeName>
              <EntityId>115207433363532140</EntityId>
              <Min x="0" y="5" z="10" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Text panel</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Description />
              <Title>Title</Title>
              <AccessFlag>READ_AND_WRITE_FACTION</AccessFlag>
              <ChangeInterval>0</ChangeInterval>
              <SelectedImages>
                <string>Galactic Corporation Logo</string>
              </SelectedImages>
              <Font Type="MyObjectBuilder_FontDefinition" Subtype="Debug" />
              <FontSize>1</FontSize>
              <PublicDescription />
              <PublicTitle>Public title</PublicTitle>
              <ShowText>NONE</ShowText>
              <FontColor>
                <PackedValue>4294967295</PackedValue>
                <X>255</X>
                <Y>255</Y>
                <Z>255</Z>
                <R>255</R>
                <G>255</G>
                <B>255</B>
                <A>255</A>
              </FontColor>
              <BackgroundColor>
                <PackedValue>4278190080</PackedValue>
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R>0</R>
                <G>0</G>
                <B>0</B>
                <A>255</A>
              </BackgroundColor>
              <CurrentShownTexture>0</CurrentShownTexture>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>110710936595755115</EntityId>
              <Min x="2" y="4" z="4" />
              <BlockOrientation Forward="Up" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Atmospheric Thrusters 10</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="4" z="5" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="0" y="3" z="5" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="0" y="3" z="4" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="3" y="3" z="1" />
              <BlockOrientation Forward="Up" Up="Right" />
              <ColorMaskHSV x="0" y="-0.8" z="0.55" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="-3" y="3" z="1" />
              <BlockOrientation Forward="Up" Up="Left" />
              <ColorMaskHSV x="0" y="-0.8" z="0.55" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_LargeGatlingTurret">
              <SubtypeName>SmallGatlingTurret</SubtypeName>
              <EntityId>97416483302477595</EntityId>
              <Min x="-2" y="-1" z="-1" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0" y="-0.8" z="0.55" />
              <Owner>144115188075855897</Owner>
              <BuiltBy>144115188075855897</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyInventoryBase</TypeId>
                    <Component xsi:type="MyObjectBuilder_Inventory">
                      <Items>
                        <MyObjectBuilder_InventoryItem>
                          <Amount>5</Amount>
                          <PhysicalContent xsi:type="MyObjectBuilder_AmmoMagazine">
                            <SubtypeName>NATO_25x184mm</SubtypeName>
                            <ProjectilesCount>0</ProjectilesCount>
                          </PhysicalContent>
                          <ItemId>0</ItemId>
                        </MyObjectBuilder_InventoryItem>
                      </Items>
                      <nextItemId>1</nextItemId>
                      <Volume>0.084</Volume>
                      <Mass>9223372036854.775807</Mass>
                      <MaxItemCount>2147483647</MaxItemCount>
                      <Size xsi:nil="true" />
                      <InventoryFlags>CanReceive</InventoryFlags>
                      <RemoveEntityOnEmpty>false</RemoveEntityOnEmpty>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Gatling Turret 2</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <IsShooting>false</IsShooting>
              <IsShootingFromTerminal>false</IsShootingFromTerminal>
              <IsLargeTurret>true</IsLargeTurret>
              <MinFov>0.1</MinFov>
              <MaxFov>1.04719758</MaxFov>
              <Inventory>
                <Items>
                  <MyObjectBuilder_InventoryItem>
                    <Amount>5</Amount>
                    <PhysicalContent xsi:type="MyObjectBuilder_AmmoMagazine">
                      <SubtypeName>NATO_25x184mm</SubtypeName>
                      <ProjectilesCount>0</ProjectilesCount>
                    </PhysicalContent>
                    <ItemId>0</ItemId>
                  </MyObjectBuilder_InventoryItem>
                </Items>
                <nextItemId>1</nextItemId>
                <Volume>0.084</Volume>
                <Mass>9223372036854.775807</Mass>
                <MaxItemCount>2147483647</MaxItemCount>
                <Size xsi:nil="true" />
                <InventoryFlags>CanReceive</InventoryFlags>
                <RemoveEntityOnEmpty>false</RemoveEntityOnEmpty>
              </Inventory>
              <RemainingAmmo>0</RemainingAmmo>
              <Target>0</Target>
              <IsPotentialTarget>true</IsPotentialTarget>
              <PreviousControlledEntityId xsi:nil="true" />
              <Rotation>0</Rotation>
              <Elevation>0</Elevation>
              <GunBase>
                <CurrentAmmoMagazineName>NATO_25x184mm</CurrentAmmoMagazineName>
                <RemainingAmmosList />
                <LastShootTime>0</LastShootTime>
              </GunBase>
              <EnableIdleRotation>true</EnableIdleRotation>
              <PreviousIdleRotationState>true</PreviousIdleRotationState>
              <TargetCharacters>true</TargetCharacters>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="3" z="-2" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="0" y="3" z="-3" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="0" y="6" z="5" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Beacon">
              <SubtypeName>SmallBlockBeacon</SubtypeName>
              <EntityId>132558596682133418</EntityId>
              <Min x="0" y="6" z="-3" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Beacon</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <BroadcastRadius>100</BroadcastRadius>
              <HudText />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_LargeGatlingTurret">
              <SubtypeName>SmallGatlingTurret</SubtypeName>
              <EntityId>138752490186145717</EntityId>
              <Min x="-2" y="7" z="-1" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyInventoryBase</TypeId>
                    <Component xsi:type="MyObjectBuilder_Inventory">
                      <Items>
                        <MyObjectBuilder_InventoryItem>
                          <Amount>5</Amount>
                          <PhysicalContent xsi:type="MyObjectBuilder_AmmoMagazine">
                            <SubtypeName>NATO_25x184mm</SubtypeName>
                            <ProjectilesCount>0</ProjectilesCount>
                          </PhysicalContent>
                          <ItemId>0</ItemId>
                        </MyObjectBuilder_InventoryItem>
                      </Items>
                      <nextItemId>1</nextItemId>
                      <Volume>0.084</Volume>
                      <Mass>9223372036854.775807</Mass>
                      <MaxItemCount>2147483647</MaxItemCount>
                      <Size xsi:nil="true" />
                      <InventoryFlags>CanReceive</InventoryFlags>
                      <RemoveEntityOnEmpty>false</RemoveEntityOnEmpty>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Gatling Turret</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <IsShooting>false</IsShooting>
              <IsShootingFromTerminal>false</IsShootingFromTerminal>
              <IsLargeTurret>true</IsLargeTurret>
              <MinFov>0.1</MinFov>
              <MaxFov>1.04719758</MaxFov>
              <Inventory>
                <Items>
                  <MyObjectBuilder_InventoryItem>
                    <Amount>5</Amount>
                    <PhysicalContent xsi:type="MyObjectBuilder_AmmoMagazine">
                      <SubtypeName>NATO_25x184mm</SubtypeName>
                      <ProjectilesCount>0</ProjectilesCount>
                    </PhysicalContent>
                    <ItemId>0</ItemId>
                  </MyObjectBuilder_InventoryItem>
                </Items>
                <nextItemId>1</nextItemId>
                <Volume>0.084</Volume>
                <Mass>9223372036854.775807</Mass>
                <MaxItemCount>2147483647</MaxItemCount>
                <Size xsi:nil="true" />
                <InventoryFlags>CanReceive</InventoryFlags>
                <RemoveEntityOnEmpty>false</RemoveEntityOnEmpty>
              </Inventory>
              <RemainingAmmo>0</RemainingAmmo>
              <Target>0</Target>
              <IsPotentialTarget>true</IsPotentialTarget>
              <PreviousControlledEntityId xsi:nil="true" />
              <Rotation>0</Rotation>
              <Elevation>0</Elevation>
              <GunBase>
                <CurrentAmmoMagazineName>NATO_25x184mm</CurrentAmmoMagazineName>
                <RemainingAmmosList />
                <LastShootTime>0</LastShootTime>
              </GunBase>
              <EnableIdleRotation>true</EnableIdleRotation>
              <PreviousIdleRotationState>true</PreviousIdleRotationState>
              <TargetCharacters>true</TargetCharacters>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="3" y="7" z="1" />
              <BlockOrientation Forward="Down" Up="Right" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="-3" y="7" z="1" />
              <BlockOrientation Forward="Down" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_ReflectorLight">
              <SubtypeName>SmallBlockFrontLight</SubtypeName>
              <EntityId>107764113702671350</EntityId>
              <Min x="2" y="5" z="3" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Spotlight 5</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Radius>10</Radius>
              <ReflectorRadius>120</ReflectorRadius>
              <ColorRed>0.215686277</ColorRed>
              <ColorGreen>0.270588249</ColorGreen>
              <Falloff>1</Falloff>
              <Intensity>3</Intensity>
              <BlinkIntervalSeconds>0</BlinkIntervalSeconds>
              <BlinkLenght>10</BlinkLenght>
              <BlinkOffset>0</BlinkOffset>
              <Offset>0.5</Offset>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>142883632130958948</EntityId>
              <Min x="-2" y="4" z="4" />
              <BlockOrientation Forward="Up" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <BuiltBy>144115188075855897</BuiltBy>
              <CustomName>Atmospheric Thrusters 9</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
          </CubeBlocks>
          <XMirroxPlane x="0" y="5" z="1" />
          <ConveyorLines>
            <MyObjectBuilder_ConveyorLine>
              <StartPosition x="0" y="5" z="2" />
              <StartDirection>Forward</StartDirection>
              <EndPosition x="0" y="5" z="1" />
              <EndDirection>Backward</EndDirection>
              <Sections />
              <ConveyorLineType>LARGE_LINE</ConveyorLineType>
            </MyObjectBuilder_ConveyorLine>
          </ConveyorLines>
          <DisplayName>Envoy</DisplayName>
          <DestructibleBlocks>true</DestructibleBlocks>
          <IsRespawnGrid>false</IsRespawnGrid>
          <LocalCoordSys>0</LocalCoordSys>
          <TargetingTargets />
        </CubeGrid>
      </CubeGrids>
    </Prefab>
  </Prefabs>
</Definitions>
