<?xml version="1.0"?>
<Definitions xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <Prefabs>
    <Prefab xsi:type="MyObjectBuilder_PrefabDefinition">
      <Id Type="MyObjectBuilder_PrefabDefinition" Subtype="Envoy" />
      <CubeGrids>
        <CubeGrid>
          <SubtypeName />
          <EntityId>79296692041584947</EntityId>
          <PersistentFlags>CastShadows InScene</PersistentFlags>
          <PositionAndOrientation>
            <Position x="0" y="0" z="0" />
            <Forward x="0.335206658" y="-0.9149471" z="0.224740654" />
            <Up x="0.6575046" y="0.398027927" z="0.63973546" />
            <Orientation>
              <X>0.1948946</X>
              <Y>0.757882833</Y>
              <Z>0.51283735</Z>
              <W>-0.353026271</W>
            </Orientation>
          </PositionAndOrientation>
          <GridSizeEnum>Small</GridSizeEnum>
          <CubeBlocks>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CargoContainer">
              <SubtypeName>SmallBlockMediumContainer</SubtypeName>
              <EntityId>129136755479915757</EntityId>
              <Min x="-1" y="4" z="-1" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyInventoryBase</TypeId>
                    <Component xsi:type="MyObjectBuilder_Inventory">
                      <Items />
                      <nextItemId>0</nextItemId>
                      <Volume>3.375</Volume>
                      <Mass>9223372036854.775807</Mass>
                      <MaxItemCount>2147483647</MaxItemCount>
                      <Size xsi:nil="true" />
                      <InventoryFlags>CanReceive CanSend</InventoryFlags>
                      <RemoveEntityOnEmpty>false</RemoveEntityOnEmpty>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Medium Cargo Container 2</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="2" y="4" z="-2" />
              <BlockOrientation Forward="Up" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="-3" y="4" z="-2" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CargoContainer">
              <SubtypeName>SmallBlockMediumContainer</SubtypeName>
              <EntityId>73431164616237133</EntityId>
              <Min x="-1" y="4" z="2" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyInventoryBase</TypeId>
                    <Component xsi:type="MyObjectBuilder_Inventory">
                      <Items />
                      <nextItemId>0</nextItemId>
                      <Volume>3.375</Volume>
                      <Mass>9223372036854.775807</Mass>
                      <MaxItemCount>2147483647</MaxItemCount>
                      <Size xsi:nil="true" />
                      <InventoryFlags>CanReceive CanSend</InventoryFlags>
                      <RemoveEntityOnEmpty>false</RemoveEntityOnEmpty>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Medium Cargo Container 2</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <ContainerType>CargoLargeTrade1A</ContainerType>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="-2" y="6" z="-2" />
              <BlockOrientation Forward="Down" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_MyProgrammableBlock">
              <SubtypeName>SmallProgrammableBlock</SubtypeName>
              <EntityId>101825802510577311</EntityId>
              <Min x="-1" y="5" z="-2" />
              <BlockOrientation Forward="Right" Up="Backward" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyModStorageComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_ModStorageComponent">
                      <Storage>
                        <dictionary>
                          <item>
                            <Key>74de02b3-27f9-4960-b1c4-27351f2b06d1</Key>
                            <Value>
                              [WORLD]
                              MaxWorldMps=100

                              [GRIDS]
                              NoFollow=NOFOLLOW
                              BlockIgnore=!WCC
                              OrientationBlockContains=[NAV]
                              OrientationBlockNamed=Craft Remote Control
                              GyroIgnore=!NAV
                              LIMIT_GYROS=3
                              LEAVE_GYROS=-1

                              [LOGGING]
                              TextPanelReport=Craft Report
                              StatusName=Wico Craft Status
                              LongStatus=Wico Craft Log
                              RangeReport=[RANGE]
                              SledReport=[SMREPORT]
                              GPSTag=[GPS]

                              [CONNECTORS]
                              BaseConnector=[BASE]
                              DockConnector=[DOCK]
                              GearUse=[DOCK]

                              [CAMERAS]
                              CameraViewOnly=[VIEW]

                              [POWER]
                              batterypcthigh=80
                              batterypctlow=20

                              [CARGO]
                              cargopctmin=5

                              [Wico Craft]
                              EchoOn=True

                            </Value>
                          </item>
                        </dictionary>
                      </Storage>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>PB WIco Craft Main</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Program>
                /*
                * Wico craft controller Master Control Script
                *
                * Control Script for Rovers and Drones and Oribtal craft
                *
                * Uncompressed source for this script here: https://github.com/Wicorel/SpaceEngineers/tree/master/MDK%20Craft%20Control
                *
                *
                * Handles:
                * Master timer for sub-modules
                * Calculates ship speed and vectors (obsolete)
                * Calculates simspeed (obsolete)
                * Configure craft_operation settings
                * making sure antenna doesn't get turned off (bug in SE turn off antenna when trying to remotely connect to grid)
                *
                * Calculates cargo and power percentages and cargo multiplier and hydro fill and oxy tank fill
                *
                * Detects grid changes and initiates re-init
                *
                * *
                * MODE_IDLE
                * MODE_ATTENTION
                *
                * Commands:
                *
                * setsimspeed &lt;value&gt;: sets the current simspeed so the calculations can be accurate. (obsolete)
                * init: re-init all blocks
                * idle : force MODE_IDLE
                * coast: turns on/off backward thrusters
                * setvaluef &lt;blockname&gt;:&lt;property&gt;:&lt;value&gt;  -&gt; sets specified block's property to specified value
                * Example:
                *  setvaluef Advanced Rotor:UpperLimit:-24
                *
                * Need:

                * Want:
                *
                * menu management for commands (including sub-modules)
                *
                * minimize serialized data and make sub-modules pass their own seperately, OR support extra data in state
                *
                * common function for 'handle this' combining 'me' grid and an exclusion name check
                *
                * multi-script handling for modes
                *
                * * advanced trigger: only when module handles that mode... (so need mode-&gt;module dictionary)
                * override base modes?
                *
                *
                *
                * WANT:
                * setvalueb
                * Actions
                * Trigger timers on 'events'.
                * set antenna name to match mode?
                * *
                * 2.0 Removed many built-in functions to make script room. These functions were duplicated in sub-modules anyway.
                * 2.0.1
                * 0.2 Remove items from serialize that main control no longer calculates (cargo, battery, etc).
                * if simspeed&gt;1.01, assume 1.0 and recalculate.
                * 0.3 re-org code sections
                * Pass arguments to sub-modules
                * 0.4 (re)integrate power and cargo
                * 0.4a process multiple arguments on a command line
                * 0.4b check mass change and request reinit including sub-modules.
                *
                * 2.1 Code Reorg
                * Cache all blocks and grids.  Support for multi-grid constructions.
                * !Needs handling for grids connected via connectors..
                *
                * .1a Don't force re-init on working projector.
                * .1b Add 'brake' command
                * Add braking for sleds (added wheelinit)
                *
                * 2.2 PB changes in 1.172
                *
                * .2a Added modes. Default PB name
                *
                * 2.3 Start to add Power information
                *
                * .3a Add drills and ejectors to reset motion. Add welders, drills, connectors and grinders to cargo check.
                * don't set PB name because it erases settings.. :(
                *
                * .3b getblocks fixes when called before gridsinit
                *
                * 3.0 remove older items from serialize that are no longer needed
                * removed NAV support
                * fixed battery maxoutput values
                *
                * 3.0a support no remote control blocks. Check for Cryo when getting default controller.
                * 3.0b sBanner
                * 3.0c caching optimizations
                * 3.0d fix connectorsanyconnectors not using localdock
                * 3.0e Add Master Reset command
                * 3.0f
                * check for grid changes and re-init
                * rotor NOFOLLOW
                * ignore projectors with !WCC in name or customdata
                * ignore 'cutter' thrusters
                *
                * 3.0g Fix problem with allBlockCount being loaded after it has changed
                *
                * 3.0H
                * fix problems with docking/undocking and perm re-init
                *
                * 05/13: fix GetBlocksContains&lt;T&gt;()
                *
                * 3.0I MDK Version 08/20/2017   MDK: https://github.com/malware-dev/MDK-SE/
                * Uncompressed source for this script here: https://github.com/Wicorel/SpaceEngineers/tree/master/MDK%20Craft%20Control
                *
                * 3.0J Add moduleDoPreModes() to Main()
                * Move pre-mode to moduleDoPreModes()
                * add clearing of gpsPanel to moduleDoPreModes()
                *
                * 3.0K more init states if larger number of blocks in grid system.
                *
                * 3.0K2  search order for text panels
                *
                * 3.1 Verison for SE 1.185 PB Major changes
                *
                * 3.1A init cycle optimizations
                *
                * 3.1B Handle no controller (stations, etc)
                * 12092017
                *
                * 3.1C 12132017
                * don't count ejectors in cargo%
                * fix bug in DoTriggerMain() causing updates to stop
                *
                * 3.1D Section processing for save information (text panels)
                * fix bug in serialize wrting z,y z, instead of x,y,z (oops)
                *
                * 3.2 INI WCCM 01062018
                *
                * 3.2A
                * FilledRatio Change
                *
                * 3.2B Lots of INI processing
                *
                * 3.3 Handle multiple output panels.
                * Only write to panels at end
                *
                * 3.3A Redo Serlialize.
                * Module Serlialize
                *
                * 3.4
                * add namecameras
                *
                * 3.4a
                * init optimizations for text panels
                *
                * 3.4B turn off auto-pirate mode.
                *
                */
                string a="Wico Craft";string b="Master";string c="3.4B";const string d="0.00";double e=2;double f=-1;
                double g=5;double h=-1;void i(){fr("clear",fb);fr("clear",gpsPanel);string j="";if(fX&gt;0){j+="Ship\n";
                }else{j+="Station\n";}if(la())j+="Connected";else j+="Not Connected";if(kY())j+="\nLocked";else j+=" : Not Locked";
                Echo(j);fD(j);j="";if(lv)Echo("FAST!");if(f&gt;e){f=0;dr();}else{if(f&lt;0){f=e+5;}f+=Runtime.TimeSinceLastRun.TotalSeconds;
                }Echo("Cargo="+dd.ToString()+"%");if(h&gt;g){h=0;bw(0,false);}else{if(h&lt;0){h=g+5;}h+=Runtime.TimeSinceLastRun.TotalSeconds;
                }j+="Batteries: #="+bo.Count.ToString();if(bo.Count&gt;0&amp;&amp;bm&gt;0){j+=" : "+(bv()/bm*100).ToString("0.00")
                +"%";j+="\n Storage="+batteryPercentage.ToString()+"%";}Echo(j);j="";Echo("Solar: #"+iy.Count.ToString()
                +" "+iz.ToString("0.00"+"MW"));float k=0;hZ(out k);if(hV.Count&gt;0){j="Reactors: #"+hV.Count.ToString();
                j+=" - "+hU.ToString("0.00")+"MW\n";float l=(float)(k/op*100);j+=" Curr Output="+k.ToString("0.00")+
                "MW"+" : "+l.ToString("0.00")+"%";}Echo(j);j="";Echo("TotalMaxPower="+op.ToString("0.00"+"MW"));TanksCalculate();
                if(es&gt;=0){Echo("O:"+es.ToString("000.0%"));}else Echo("No Oxygen Tanks");if(er&gt;=0){Echo("H:"+er.ToString("000.0%"));
                }else Echo("No Hydrogen Tanks");if(ee.Count&gt;0){Echo(ee.Count+" Gas Gens");}if(lD&gt;=0){Echo("Grav="+lD.ToString(d));
                fD("Planet Gravity "+lD.ToString(d)+" g");fD(fE((int)(lD/1.1*100)));}else fD("ERROR: No Remote Control found!");
                fr("clear",gpsPanel);}void m(){lI();}void n(bool o=false){jF(iD);nq();hF(hu);hF(hv);if(mN is IMyRemoteControl)
                ((IMyRemoteControl)mN).SetAutoPilotEnabled(false);if(mN is IMyShipController)((IMyShipController)mN).DampenersOverride
                =true;if(!o)lO();}void p(){ec();n();@in=0;io="";sPassedArgument="init";iniWicoCraftSave.nD("");ib();
                lv=true;}void q(){il=dC;if((il&amp;dM)==dC){int r=0;if(Me.CustomName.ToLower().Contains("nad"))il|=dI;if
                (Me.CustomName.ToLower().Contains("rotor"))il|=dE;else if(Me.CustomName.ToLower().Contains("sled"))il
                |=CRAFT_MODE_SLED;if(iQ&gt;0){r++;}if(iR&gt;0){r++;}if(iS&gt;0){r++;}if(hu.Count&gt;0&amp;&amp;hv.Count&gt;0)il|=dE;if(ou.Count
                &gt;0&amp;&amp;r&gt;0)il|=CRAFT_MODE_SLED;if(r&gt;1||Me.CustomName.ToLower().Contains("orbital"))il|=CRAFT_MODE_ORBITAL;
                if(Me.CustomName.ToLower().Contains("rocket"))il|=dG;if(Me.CustomName.ToLower().Contains("pet"))il|=
                dH;if(Me.CustomName.ToLower().Contains("noautogyro"))il|=dJ;if(Me.CustomName.ToLower().Contains("nopower"))
                il|=dK;if(Me.CustomName.ToLower().Contains("notank"))il|=dL;}}void s(){string j="";j+=ly.ToString(d)
                +" m/s";j+=" ("+(ly*3.6).ToString(d)+"km/h)";fD(j);}void t(nr u){}void v(nr u){}List&lt;z&gt;w=new List&lt;z&gt;();
                string x="";const string y="ASTEROIDS";public class z{public long A;public BoundingBoxD B;public Vector3D
                C{get{return B.Center;}}}void D(){if(iniWicoCraftSave==null)return;string S1="";S1+=w.Count+"\n";for
                (int i=0;i&lt;w.Count;i++){S1+=w[i].A.ToString()+"\n";S1+=ir(w[i].B.Min)+"\n";S1+=ir(w[i].B.Max)+"\n";}
                if(x!=S1){iniWicoCraftSave.oi(y,S1);}else{}}void E(){if(iniWicoCraftSave==null)return;string F;F=iniWicoCraftSave.nO(y);
                if(F.Length&lt;1){return;}if(F==x){return;}w.Clear();double x1,y1,z1;x=F;string[]G=F.Split('\n');int H=
                0;int I=-1;if(G.Length&lt;2)return;I=Convert.ToInt32(G[H++]);for(int j=0;j&lt;I;j++){long J;J=Convert.ToInt64(G[H++]);
                BoundingBoxD K;@is(G[H++],out x1,out y1,out z1);K.Min=new Vector3D(x1,y1,z1);@is(G[H++],out x1,out y1,
                out z1);K.Max=new Vector3D(x1,y1,z1);z L=new z();L.A=J;L.B=K;w.Add(L);}}void M(){w.Clear();E();}void
                N(long O,BoundingBoxD K,bool P=true){bool Q=false;for(int i=0;i&lt;w.Count;i++){if(w[i].A==O){Q=true;break;
                }}if(!Q){z ai=new z();ai.A=O;ai.B=K;w.Add(ai);D();if(P){kG("WICO:AST:"+ih.EntityId.ToString()+":"+O.ToString()
                +":"+ir(K.Min)+":"+ir(K.Max));}}}void N(MyDetectedEntityInfo R,bool P=true){if(R.IsEmpty()||R.Type!=
                MyDetectedEntityType.Asteroid)return;N((long)R.EntityId,R.BoundingBox,P);}bool S(List&lt;MyDetectedEntityInfo&gt;
                T){bool U=false;for(int j=0;j&lt;T.Count;j++){if(T[j].Type==MyDetectedEntityType.Asteroid){if(V(T[j]))U
                =true;}}return U;}bool V(MyDetectedEntityInfo dei){dW(dei);bool U=false;if(dei.Type==MyDetectedEntityType.Asteroid)
                {N(dei);U=true;}return U;}long X(bool Y=false){long Z=-1;if(mN==null)return Z;if(w.Count&lt;1)E();double
                ba=double.MaxValue;foreach(var ast in w){if(Y){if(ast.B.Contains(mN.GetPosition())==ContainmentType.Contains)
                {Z=ast.A;}}else{double bb=Vector3D.DistanceSquared(ast.C,mN.GetPosition());if(bb&lt;ba){Z=ast.A;ba=bb;}
                }}return Z;}Vector3D bc(long Z){if(w.Count&lt;1)E();Vector3D bd=new Vector3D(0,0,0);for(int i=0;i&lt;w.Count;
                i++){if(w[i].A==Z)bd=w[i].C;}return bd;}BoundingBoxD be(long Z){if(w.Count&lt;1)E();BoundingBoxD K=new BoundingBoxD();
                for(int i=0;i&lt;w.Count;i++){if(w[i].A==Z)K=w[i].B;}return K;}bool bf(string bg){double x1,y1,z1;string[]
                bh=bg.Trim().Split(':');if(bh.Length&gt;1){if(bh[0]!="WICO"){Echo("not wico system message");return false;
                }if(bh.Length&gt;2){if(bh[1]=="AST"){int bi=2;long id=0;long.TryParse(bh[bi++],out id);long bj=0;long.TryParse(bh[bi++],
                out bj);x1=Convert.ToDouble(bh[bi++]);y1=Convert.ToDouble(bh[bi++]);z1=Convert.ToDouble(bh[bi++]);Vector3D
                bk=new Vector3D(x1,y1,z1);x1=Convert.ToDouble(bh[bi++]);y1=Convert.ToDouble(bh[bi++]);z1=Convert.ToDouble(bh[bi++]);
                Vector3D bl=new Vector3D(x1,y1,z1);BoundingBoxD K=new BoundingBoxD(bk,bl);N(bj,K,false);return true;
                }else if(bh[1]=="AST?"){}}}return false;}double bm=-1;int batteryPercentage=-1;List&lt;IMyTerminalBlock&gt;
                bo=new List&lt;IMyTerminalBlock&gt;();bool bp(IMyTerminalBlock bq){if(bq is IMyBatteryBlock){IMyBatteryBlock
                br=bq as IMyBatteryBlock;return br.OnlyRecharge;}else return false;}bool bs(IMyTerminalBlock bq){if(bq
                is IMyBatteryBlock){IMyBatteryBlock br=bq as IMyBatteryBlock;return br.OnlyDischarge;}else return false;
                }bool bt(IMyTerminalBlock bq){if(bq is IMyBatteryBlock){IMyBatteryBlock br=bq as IMyBatteryBlock;return
                br.IsCharging;}else return false;}void bu(){bo.Clear();batteryPercentage=-1;bm=-1;GridTerminalSystem.GetBlocksOfType&lt;IMyBatteryBlock&gt;(bo,
                mz);if(bo.Count&gt;0)bm=0;foreach(var tb in bo){IMyBatteryBlock r=tb as IMyBatteryBlock;bm+=r.MaxOutput;
                }}double bv(){double j=0;foreach(var tb in bo){IMyBatteryBlock r=tb as IMyBatteryBlock;j+=r.CurrentOutput;
                }return j;}bool bw(int bx,bool by=true,bool bz=false){float bA=0;float bB=0;bool bC=false;float f1;if
                (bo.Count&lt;1)bu();if(bo.Count&lt;1)return false;batteryPercentage=0;for(int ib=0;ib&lt;bo.Count;ib++){float
                bD=0;float bE=0;int bF=100;IMyBatteryBlock b;b=bo[ib]as IMyBatteryBlock;f1=b.MaxStoredPower;bE+=f1;bA
                +=f1;f1=b.CurrentStoredPower;bD+=f1;bB+=f1;if(bE&gt;0){f1=((bD*100)/bE);f1=(float)Math.Round(f1,0);bF=(int)f1;
                }string s;s="";if(bp(bo[ib]))s+="R";else if(bs(bo[ib]))s+="D";else s+="a";float bG;bG=b.CurrentInput;
                if(bG&gt;0)s+="+";else s+=" ";bG=b.CurrentOutput;if(bG&gt;0)s+="-";else s+=" ";s+=bF+"%";s+=":"+bo[ib].CustomName;
                if(by)Echo(s);if(bp(bo[ib])&amp;&amp;bx&gt;0){if(bF&lt;bx)bC=true;else if(bF&gt;99)b.OnlyRecharge=false;}if(!b.OnlyRecharge
                &amp;&amp;bF&lt;bx&amp;&amp;!bC){b.OnlyDischarge=false;b.OnlyRecharge=true;b.SemiautoEnabled=false;bC=true;}}if(bA&gt;0){f1
                =((bB*100)/bA);f1=(float)Math.Round(f1,0);batteryPercentage=(int)f1;}else batteryPercentage=-1;return
                bC;}void bH(bool by=false,bool bI=true){Echo(bo.Count+" Batteries");string s;for(int i=0;i&lt;bo.Count;
                i++){IMyBatteryBlock b;b=bo[i]as IMyBatteryBlock;b.OnlyRecharge=!bI;b.OnlyDischarge=bI;b.SemiautoEnabled
                =false;s=b.CustomName+": ";if(b.OnlyRecharge){s+="RECHARGE/";}else s+="NOTRECHARGE/";if(b.OnlyDischarge)
                {s+="DISCHARGE";}else{s+="NOTDISCHARGE";}if(by)Echo(s);}}void bJ(List&lt;IMyTerminalBlock&gt;bK,bool bL=true)
                {foreach(var b in bK){IMyFunctionalBlock f=b as IMyFunctionalBlock;if(f==null)continue;f.Enabled=bL;
                }}void bM(List&lt;IMyTerminalBlock&gt;bK){foreach(var b in bK){IMyFunctionalBlock f=b as IMyFunctionalBlock;
                if(f==null)continue;f.Enabled=!f.Enabled;}}string bN="[VIEW]";Matrix bO=new Matrix(1,0,0,0,0,1,0,0,0,
                0,1,0,0,0,0,1);List&lt;IMyTerminalBlock&gt;bP=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;bQ=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;bR=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;bS=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;bT=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;bU=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;bV=new List&lt;IMyTerminalBlock&gt;();IMyTerminalBlock bW=null;private MyDetectedEntityInfo
                bX;string bY="CAMERAS";void bZ(nr u){u.nS(bY,"CameraViewOnly",ref bN,true);}bool ca(List&lt;IMyTerminalBlock&gt;
                cb,double cc=100,float cd=0,float ce=0){double cf=0;bW=null;for(int i=0;i&lt;cb.Count;i++){double cg=((IMyCameraBlock)cb[i]).AvailableScanRange;
                if(cg&gt;cf){cf=cg;bW=cb[i];}}var ch=bW as IMyCameraBlock;if(bW==null){return false;}if(ch.CanScan(cc))
                {bX=ch.Raycast(cc,cd,ce);bW=ch;if(!bX.IsEmpty())dW(bX);return true;}else{}return false;}bool ca(List&lt;IMyTerminalBlock&gt;
                cb,Vector3D ci){double cf=0;bW=null;for(int i=0;i&lt;cb.Count;i++){double cg=((IMyCameraBlock)cb[i]).AvailableScanRange;
                if(cg&gt;cf){cf=cg;bW=cb[i];}}var ch=bW as IMyCameraBlock;if(bW==null)return false;{bX=ch.Raycast(ci);bW
                =ch;if(!bX.IsEmpty())dW(bX);return true;}}double cj(List&lt;IMyTerminalBlock&gt;cb){double ck=0;for(int i=
                0;i&lt;cb.Count;i++){IMyCameraBlock ch=cb[i]as IMyCameraBlock;if(ck&lt;ch.AvailableScanRange)ck=ch.AvailableScanRange;
                }return ck;}string cl(IMyTerminalBlock cm){bP.Clear();bQ.Clear();bR.Clear();bS.Clear();bT.Clear();bU.Clear();
                bV.Clear();if(cm==null)return"\nCameras:No OrientationBlock";GridTerminalSystem.GetBlocksOfType&lt;IMyCameraBlock&gt;(bV,
                (x1=&gt;x1.CubeGrid==Me.CubeGrid));Matrix cn;cm.Orientation.GetMatrix(out cn);Matrix.Transpose(ref cn,out
                cn);for(int i=0;i&lt;bV.Count;++i){if(bV[i].CustomName.Contains(bN))continue;IMyCameraBlock ch=bV[i]as IMyCameraBlock;
                ch.EnableRaycast=true;Matrix co;ch.Orientation.GetMatrix(out co);Vector3 cp=Vector3.Transform(co.Forward,
                cn);if(cp==bO.Left){bT.Add(bV[i]);}else if(cp==bO.Right){bU.Add(bV[i]);}else if(cp==bO.Backward){bQ.Add(bV[i]);
                }else if(cp==bO.Forward){bP.Add(bV[i]);}else if(cp==bO.Up){bS.Add(bV[i]);}else if(cp==bO.Down){bR.Add(bV[i]);
                }}string s;s="CS:&lt;";s+="F"+bP.Count.ToString("00");s+="B"+bQ.Count.ToString("00");s+="D"+bR.Count.ToString("00");
                s+="U"+bS.Count.ToString("00");s+="L"+bT.Count.ToString("00");s+="R"+bU.Count.ToString("00");s+="&gt;";
                return s;}void cq(List&lt;IMyTerminalBlock&gt;cb,string cr){string cs;for(int i=0;i&lt;cb.Count;i++){if(!cb[i].CustomName.Contains(cr))
                {cs="Camera ";if(cb.Count&gt;1)cs+=(i+1).ToString()+" ";cs+=cr;cb[i].CustomName=cs;}}}List&lt;IMyTerminalBlock&gt;
                ct=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;cu=new List&lt;IMyTerminalBlock&gt;();string cv(IMyTerminalBlock
                cm){string s="";if(bV.Count&lt;1)s+=cl(cm);ct.Clear();cu.Clear();foreach(var camera in bR){if(camera.CustomName.ToLower().Contains("fore")
                ||camera.CustomData.ToLower().Contains("fore"))ct.Add(camera);else if(camera.CustomName.ToLower().Contains("aft")
                ||camera.CustomData.ToLower().Contains("aft"))cu.Add(camera);}s+="HCS:&lt;";s+="F"+ct.Count.ToString("00");
                s+="A"+cu.Count.ToString("00");s+="&gt;";return s;}public class cw{bool cx=false;Program cy;public double
                cz=1250;double cA=5000;float cB=25f;float cC=25f;double cD=5;float cE=3;float cF=0.5f;float cG=0;float
                cH=0;float cI=0;float cJ=0;List&lt;IMyTerminalBlock&gt;cK=new List&lt;IMyTerminalBlock&gt;();private int cL=0;private
                int cM=1;public MyDetectedEntityInfo bX;public List&lt;MyDetectedEntityInfo&gt;cN=new List&lt;MyDetectedEntityInfo&gt;();
                public IMyTerminalBlock bW=null;public cw(Program pg,List&lt;IMyTerminalBlock&gt;bK,double cO=1250,float cP
                =45f,float cQ=45f,float cR=2,float cS=1,float cT=0.5f,double cU=5000){cy=pg;cx=false;cK.Clear();cN.Clear();
                bX=new MyDetectedEntityInfo();foreach(var b in bK){if(b is IMyCameraBlock){cK.Add(b);IMyCameraBlock c
                =b as IMyCameraBlock;c.EnableRaycast=true;if(cB&gt;c.RaycastConeLimit)cB=c.RaycastConeLimit;if(cC&gt;c.RaycastConeLimit)
                cC=c.RaycastConeLimit;}}if(cO&gt;cU)cU=cO;cz=cO;cB=cP;cC=cQ;cD=cR;cE=cS;cF=cT;cA=cU;cG=0;cH=0;cI=0;cJ=0;
                cL=0;cM=cK.Count;}public bool cV(){return cx;}void cW(MyDetectedEntityInfo bX){bool cX=true;for(int i
                =0;i&lt;cN.Count;i++){if(cN[i].EntityId==bX.EntityId)cX=false;}if(cX){cN.Add(bX);}}public bool cY(){if(cK.Count
                &lt;1)cx=true;if(cx)return false;bool cZ=false;for(int da=0;da&lt;cM;da++){if(cy.ca(cK,cz,cJ,cI)){bX=cy.bX;
                if(!bX.IsEmpty()){bool db=true;if((bX.Type==MyDetectedEntityType.LargeGrid)||(bX.Type==MyDetectedEntityType.SmallGrid))
                {if(cy.IsGridLocal(bX.EntityId)){db=false;}}if(db){cy.fV+="\nDoScan HIT!";cW(bX);cZ=true;}}cL++;if(cJ
                ==0&amp;&amp;cI==0){cG=cF;cH=cF;cL=0;}if(cL&gt;3){cL=0;cH+=Math.Abs(cH/cE)+cF;if(Math.Abs(cH)&gt;cB){cL=0;cH=0;cG+=
                Math.Abs(cG/cE)+cF;}if(Math.Abs(cG)&gt;cC){cG=0;cH=0;cL=0;{cz*=cD;if(cz&gt;cA){cx=true;return false;}}}}switch
                (cL){case 0:cJ=cG;cI=cH;break;case 1:cJ=-cG;cI=cH;break;case 2:cJ=cG;cI=-cH;break;case 3:cJ=-cG;cI=-cH;
                break;}}}return cZ;}}int dc=5;int dd=-1;double de=-1;string df="CARGO";void dg(nr u){u.nS(df,"cargopctmin",
                ref dc,true);}List&lt;IMyTerminalBlock&gt;dh=null;bool di=false;double dj=0.0;void dk(){var bK=new List&lt;IMyTerminalBlock&gt;();
                if(dh==null)dh=new List&lt;IMyTerminalBlock&gt;();else dh.Clear();mG&lt;IMyCargoContainer&gt;(ref bK);dh.AddRange(bK);
                dd=-1;de=-1;}void dl(){var bK=new List&lt;IMyTerminalBlock&gt;();mG&lt;IMyShipConnector&gt;(ref bK);foreach(var c
                in bK){if(c.CustomName.Contains("Ejector")||c.CustomData.Contains("Ejector"))continue;else dh.Add(c);
                }}void dm(){var bK=new List&lt;IMyTerminalBlock&gt;();mG&lt;IMyShipDrill&gt;(ref bK);dh.AddRange(bK);}void dn(){
                var bK=new List&lt;IMyTerminalBlock&gt;();mG&lt;IMyShipWelder&gt;(ref bK);dh.AddRange(bK);}void@do(){var bK=new List&lt;IMyTerminalBlock&gt;();
                mG&lt;IMyShipGrinder&gt;(ref bK);dh.AddRange(bK);}bool dp=true;void dq(){var bK=new List&lt;IMyTerminalBlock&gt;();
                if(dh==null)dh=new List&lt;IMyTerminalBlock&gt;();else dh.Clear();if(!dp)GridTerminalSystem.GetBlocksOfType&lt;IMyCargoContainer&gt;(bK,
                mz);else mG&lt;IMyCargoContainer&gt;(ref bK);dh.AddRange(bK);bK.Clear();if(!dp)GridTerminalSystem.GetBlocksOfType&lt;IMyShipConnector&gt;(bK,
                mz);else mG&lt;IMyShipConnector&gt;(ref bK);foreach(var c in bK){if(c.CustomName.Contains("Ejector")||c.CustomData.Contains("Ejector"))
                continue;else dh.Add(c);}bK.Clear();if(!dp)GridTerminalSystem.GetBlocksOfType&lt;IMyShipDrill&gt;(bK,mz);else
                mG&lt;IMyShipDrill&gt;(ref bK);dh.AddRange(bK);bK.Clear();if(!dp)GridTerminalSystem.GetBlocksOfType&lt;IMyShipWelder&gt;(bK,
                mz);else mG&lt;IMyShipWelder&gt;(ref bK);dh.AddRange(bK);bK.Clear();if(!dp)GridTerminalSystem.GetBlocksOfType&lt;IMyShipGrinder&gt;(bK,
                mz);else mG&lt;IMyShipGrinder&gt;(ref bK);dh.AddRange(bK);dd=-1;de=-1;}void dr(){if(dh==null)dq();if(dh.Count
                &lt;1){dd=-1;de=-1;return;}dj=0.0;double ds=0.0;double dt=0;for(int i=0;i&lt;dh.Count;i++){ds+=du(dh[i]);}
                if(ds&gt;0){dt=(dj/ds)*100;}else{dt=100;}dd=(int)dt;}double du(IMyTerminalBlock dv){double bE=-1;var dw
                =dv.InventoryCount;for(var dx=0;dx&lt;dw;dx++){var dy=dv.GetInventory(dx);if(dy!=null){dj+=(double)dy.CurrentVolume;
                if((double)dy.MaxVolume&gt;9223372036854){di=true;}else{di=false;}if(!di){bE=(double)dy.MaxVolume;double
                dz=dA(dv);if(dz&gt;0)de=bE/dz;}else{bE=dA(dv)*10;de=9999;}}}return bE;}double dA(IMyTerminalBlock theContainer)
                {var dy=theContainer.GetInventory(0);string dB=theContainer.BlockDefinition.SubtypeId;double bE=(double)dy.MaxVolume;
                if(bE&lt;999999999)return bE;if(theContainer is IMyCargoContainer){if(dB.Contains("LargeBlockLargeContainer"))
                bE=421.875008;else if(dB.Contains("LargeBlockSmallContainer"))bE=15.625;else if(dB.Contains("SmallBlockLargeContainer"))
                bE=15.625;else if(dB.Contains("SmallBlockMediumContainer"))bE=3.375;else if(dB.Contains("SmallBlockSmallContainer"))
                bE=0.125;else if(dB.Contains("Azimuth_LargeContainer"))bE=7780.8;else if(dB.Contains("Azimuth_MediumLargeContainer"))
                bE=1945.2;else if(dB.Contains("Azimuth_MediumContainer"))bE=1878.6;else if(dB.Contains("Azimuth_SmallContainer"))
                bE=10.125;}else if(dB.Contains("SmallBlockDrill"))bE=3.375;else if(dB.Contains("LargeBlockDrill"))bE
                =23.4375;else if(dB.Contains("ConnectorMedium"))bE=1.152;else if(dB.Contains("ConnectorSmall"))bE=0.064;
                else if(dB.Contains("Connector"))bE=8.000;else if(dB.Contains("LargeShipWelder"))bE=15.625;else if(dB.Contains("LargeShipGrinder"))
                bE=15.625;else if(dB.Contains("SmallShipWelder"))bE=3.375;else if(dB.Contains("SmallShipGrinder"))bE
                =3.375;else{Echo("Unknown cargo for default Capacity:"+theContainer.DefinitionDisplayNameText+":"+theContainer.BlockDefinition.SubtypeId);
                bE=12;}return bE;}const int dC=0;const int CRAFT_MODE_SLED=2;const int dE=4;const int CRAFT_MODE_ORBITAL
                =32;const int dG=64;const int dH=128;const int dI=256;const int dJ=512;const int dK=1024;const int dL
                =2048;const int dM=0xfff;string craftOperation(){string dO="FLAGS:";if((il&amp;CRAFT_MODE_SLED)&gt;0)dO+="SLED ";
                if((il&amp;CRAFT_MODE_ORBITAL)&gt;0)dO+="ORBITAL ";if((il&amp;dG)&gt;0)dO+="ROCKET ";if((il&amp;dE)&gt;0)dO+="ROTOR ";if((il
                &amp;dH)&gt;0)dO+="PET ";if((il&amp;dI)&gt;0)dO+="NAD ";if((il&amp;dJ)&gt;0)dO+="NO Gyro ";if((il&amp;dL)&gt;0)dO+="No Tank ";if
                ((il&amp;dK)&gt;0)dO+="No Power ";return dO;}long dP=0;void dQ(){string dR;if(ih==null){dR=Storage;}else{dR
                =ih.GetPublicText();}if(iniWicoCraftSave==null)return;iniWicoCraftSave.nD(dR);iniWicoCraftSave.nS(@if,
                "SaveID",ref dP);if(dS())iniWicoCraftSave.nD("");t(iniWicoCraftSave);iniWicoCraftSave.nS(@if,"Mode",
                ref ge,true);iniWicoCraftSave.nS(@if,"current_state",ref ij,true);iniWicoCraftSave.nS(@if,"PassedArgument",
                ref sPassedArgument,true);iniWicoCraftSave.nS(@if,"AlertStates",ref@in,true);iniWicoCraftSave.nS(@if,
                "craft_operation",ref il,true);iniWicoCraftSave.nS(@if,"PassedArgument",ref sPassedArgument);iniWicoCraftSave.nS(@if,
                "ReceivedMessage",ref io);}bool dS(){if(ih==null)return false;if(dP==(long)ih.EntityId)return false;
                else return true;}bool dT(string dU){dU=dU.Trim().ToLower();return(dU=="True"||dU=="true");}Dictionary&lt;long,
                MyDetectedEntityInfo&gt;dV=new Dictionary&lt;long,MyDetectedEntityInfo&gt;();void dW(MyDetectedEntityInfo thisDetectedInfo)
                {if(thisDetectedInfo.EntityId!=0){if(!dV.ContainsKey(thisDetectedInfo.EntityId)){dV.Add(thisDetectedInfo.EntityId,
                thisDetectedInfo);}else{dV[thisDetectedInfo.EntityId]=thisDetectedInfo;}}else Echo("Not adding: Zero Entity");
                }string dX(MyDetectedEntityInfo W){string s="";s+="ETBV";s+=":"+W.EntityId.ToString();s+=":"+W.TimeStamp;
                Vector3D dY=W.BoundingBox.Min;s+=":"+ir(dY);Vector3D dZ=W.BoundingBox.Max;s+=":"+ir(dZ);Vector3D ea=
                (Vector3)W.Velocity;s+=":"+ir(ea);return s;}void eb(){Echo("mode="+ge.ToString());if(ge==gf)ed();if(ge
                ==gR)he();else if(ge==gi){fr("clear",fb);fr(b+":ATTENTION!",fb);fr(b+": current_state="+ij.ToString(),
                fb);fr("\nCraft Needs attention",fb);}}void ec(){fr(DateTime.Now.ToString()+" ACTION: Reset To Idle",
                eZ,true);n();gV(gf);if(fX&gt;0&amp;&amp;la()&amp;&amp;ge!=gk&amp;&amp;ge!=gs&amp;&amp;!((il&amp;CRAFT_MODE_ORBITAL)&gt;0)&amp;&amp;!((il&amp;dI)&gt;0))gV(go);
                }void ed(){fr("clear",fb);fr(a+":"+b+":Manual Control (idle)",fb);if(fX&gt;0&amp;&amp;la()&amp;&amp;ge!=gk&amp;&amp;ge!=gs&amp;&amp;!((il
                &amp;CRAFT_MODE_ORBITAL)&gt;0)&amp;&amp;!((il&amp;dI)&gt;0))gV(go);}List&lt;IMyTerminalBlock&gt;ee=new List&lt;IMyTerminalBlock&gt;();
                string ef(){ee.Clear();ee=mG&lt;IMyGasGenerator&gt;();return"GG"+ee.Count.ToString("00");}void eg(bool bL=
                true){bJ(ee,bL);}bool eh(){return true;}void ei(){if(ev()&gt;99){bJ(ee,false);}else{bJ(ee,true);}}List&lt;IMyTerminalBlock&gt;
                ej=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;ek=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                el=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;em=new List&lt;IMyTerminalBlock&gt;();const int en=1;
                const int eo=2;int ep=0;int eq=0;double er=-1;double es=-1;void TanksCalculate(){er=ev(eo);es=ev(en);
                }string eu(){{ej=new List&lt;IMyTerminalBlock&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyGasTank&gt;(ej,(x=&gt;
                x.CubeGrid==Me.CubeGrid));}ep=0;eq=0;for(int i=0;i&lt;ej.Count;++i){if(eD(ej[i])==en){if(ej[i].CustomName.ToLower().Contains("isolated"))
                em.Add(ej[i]);else ek.Add(ej[i]);eq++;}else if(eD(ej[i])==eo){el.Add(ej[i]);ep++;}}return"T"+ej.Count.ToString("00");
                }double ev(List&lt;IMyTerminalBlock&gt;ej){double ew=0;int ex=0;for(int i=0;i&lt;ej.Count;++i){{IMyGasTank ey
                =ej[i]as IMyGasTank;if(ey==null)continue;float ez=(float)ey.FilledRatio;ew+=ez;ex++;}}if(ex&gt;0){return
                ew*100/ex;}else return 0;}double ev(int iTypes=0xff){if(ej.Count&lt;1)eu();if(ej.Count&lt;1)return-1;double
                eB=0;int ex=0;for(int i=0;i&lt;ej.Count;++i){int eC=eD(ej[i]);if((eC&amp;iTypes)&gt;0){IMyGasTank ey=ej[i]as IMyGasTank;
                if(ey==null)continue;float ez=(float)ey.FilledRatio;eB+=ez;ex++;}}if(ex&gt;0){return eB/ex;}else return
                -1;}int eD(IMyTerminalBlock eE){if(eE is IMyGasTank){if(eE.BlockDefinition.SubtypeId.Contains("Hydro"))
                return eo;else return en;}return 0;}void eF(bool eG=true,int eA=0xff){if(ej.Count&lt;1)eu();if(ej.Count
                &lt;1)return;for(int i=0;i&lt;ej.Count;++i){int eC=eD(ej[i]);if((eC&amp;eA)&gt;0){IMyGasTank ey=ej[i]as IMyGasTank;
                if(ey==null)continue;ey.Stockpile=eG;}}}string eH="[DOCK]";List&lt;IMyTerminalBlock&gt;eI=new List&lt;IMyTerminalBlock&gt;();
                void eJ(nr u){u.nS(kU,"GearUse",ref eH,true);}void eK(){if(eI.Count&lt;1)eI=mI&lt;IMyLandingGear&gt;(eH);if(eI.Count
                &lt;1)eI=mG&lt;IMyLandingGear&gt;();return;}string eL(){{eI.Clear();eK();}return"LG"+eI.Count.ToString("00");
                }bool eM(){for(int i=0;i&lt;eI.Count;i++){IMyLandingGear eN;eN=eI[i]as IMyLandingGear;if(eN!=null&amp;&amp;eN.IsLocked)
                return true;}return false;}bool eO(IMyTerminalBlock bq){var g=bq as IMyLandingGear;if(g==null)return
                false;return((int)g.LockMode==1);}bool eP(){var eQ=new StringBuilder();for(int i=0;i&lt;eI.Count;i++){if
                (eO(eI[i]))return true;}return false;}void eR(bool eS=true){for(int i=0;i&lt;eI.Count;i++){IMyLandingGear
                g=eI[i]as IMyLandingGear;if(g==null)continue;if(eS)g.Lock();else g.Unlock();}}string eT="LOGGING";void
                eU(nr u){u.nS(eT,"TextPanelReport",ref sTextPanelReport,true);u.nS(eT,"StatusName",ref eY,true);u.nS(eT,
                "LongStatus",ref fa,true);u.nS(eT,"RangeReport",ref eW,true);u.nS(eT,"SledReport",ref fg,true);u.nS(eT,
                "GPSTag",ref fe,true);}fj eV=null;string eW="[RANGE]";fj eX=null;string eY="Wico Craft Status";fj eZ
                =null;string fa="Wico Craft Log";fj fb=null;string sTextPanelReport="Craft Report";fj gpsPanel=null;
                string fe="[GPS]";fj ff=null;string fg="[SMREPORT]";bool fh=false;bool fi=false;public class fj{Program
                cy;string fk="";List&lt;IMyTextPanel&gt;fl=new List&lt;IMyTextPanel&gt;();string fm="";string fn="";bool fo=false;
                bool fp=true;public fj(Program pg,string cs,bool fq=false){cy=pg;fk=cs;fo=fq;fp=true;fm="";fn="";fl.Clear();
                fl=cy.mK(fk);if(fl.Count&lt;1)fl=cy.mJ(fk);}public void fr(string fs,bool ft=false){if(fs=="clear"){fm=
                "";fn="X";fp=false;return;}if(fo&amp;&amp;fp){fp=false;if(fl.Count&gt;0){fm=fl[0].GetPublicText();fn="X";}}if(ft)
                {fm=fs+"\n"+fm;}else fm+=fs+"\n";}public void fu(){if(fn!=fm){fp=true;foreach(var t in fl){t.WritePublicText(fm);
                }fn=fm;}}}void fv(){eX=fA(true);eZ=fx(fa,true);;fb=fx(sTextPanelReport);eV=fx(eW);gpsPanel=fx(fe,lm);
                ff=fx(fg);fh=true;}void fw(){if(eX!=null)eX.fu();if(eZ!=null)eZ.fu();if(fb!=null)fb.fu();if(eV!=null)
                eV.fu();if(gpsPanel!=null)gpsPanel.fu();if(ff!=null)ff.fu();}fj fx(string stheName,bool bRefresh=false)
                {fj fz=new fj(this,stheName,bRefresh);return fz;}fj fA(bool force_update=false){if((eX!=null||fh)&amp;&amp;!force_update)
                return eX;eX=fx(eY);return eX;}void fr(string text,fj wLog,bool bReverse=false){if(wLog==null)return;
                wLog.fr(text,bReverse);}void fD(string fs){fr(fs,fA());if(fi&amp;&amp;fs!="clear")Echo(fs);}string fE(double
                fF){int fG=75;if(fF&lt;0)fF=0;int fH=(int)(fF*fG)/100;if(fH&gt;fG)fH=fG;string dO="["+new String('|',fH)+new
                String('\'',fG-fH)+"]";return dO;}void fI(string cs,Vector3D fJ){string s1;s1="GPS:"+cs+":"+ir(fJ)+":";
                fr(s1,gpsPanel);}string fK(string fL,string fM){string s;int fN=fL.Length;int fO=fM.Length;if(fN+fO&gt;
                32){if(fO&gt;31)return"INVALID";fN=32-fO;}s=fL.Substring(0,fN)+fM;s.Replace(":","_");s.Replace(";","_");
                return s;}string fP(double fQ){string fR="";if(fQ&gt;1000){fR=fQ.ToString("N0")+"km";}else if(fQ&gt;10){fR
                =fQ.ToString("0.0")+"m";}else{fR=fQ.ToString("0.000")+"m";}return fR;}void fS(){}void fT(nr fU){kV(fU);
                jb(fU);mR(fU);bZ(fU);eJ(fU);or(fU);dg(fU);}string fV="";int fW=0;double fX=0;string doInit(){Echo(ma.Count.ToString()
                +" Blocks");do{lI("Init:"+fW+" ");switch(fW){case 0:fr(DateTime.Now.ToString()+" "+a+":"+b+":INIT",eZ,
                true);break;case 1:if(!lh.ContainsKey("doscans"))lh.Add("doscans",gR);break;case 2:fV+=mk();break;case
                3:fv();break;case 4:kd();break;case 5:fV+=SerializeInit();dQ();break;case 6:fV+=DefaultOrientationBlockInit();
                break;case 7:dq();break;case 8:os();break;case 9:fV+=jc(mN);break;case 10:fV+=nn();break;case 11:if(mN
                is IMyRemoteControl){Vector3D fZ;bool ga=((IMyRemoteControl)mN).GetNearestPlayer(out fZ);IMyRemoteControl
                gb=(IMyRemoteControl)mN;gb.SetCollisionAvoidance(false);gb.SetDockingMode(false);gb.Direction=Base6Directions.Direction.Forward;
                gb.FlightMode=FlightMode.OneWay;gb.ClearWaypoints();}break;case 12:fV+=ox(mN);break;case 13:fV+=hw();
                break;case 14:fV+=kW();break;case 15:fV+=eu();break;case 16:fV+=lL();break;case 17:fV+=cl(mN);break;
                case 18:fV+=lR();break;case 19:fV+=km();break;case 20:fV+=ef();break;case 21:q();break;case 22:if(kj)
                li="*"+a+":"+b+" V"+c+" ";if(li.Length&gt;34){li=a+":"+b+"\nV"+c+" ";}if(mN is IMyShipController){MyShipMass
                gc;gc=((IMyShipController)mN).CalculateShipMass();fX=gc.BaseMass;}fV+=gd();lt=true;break;}fW++;}while
                (!lt&amp;&amp;(((float)Runtime.CurrentInstructionCount/(float)Runtime.MaxInstructionCount)&lt;0.5f));if(lt)fW=0;
                fD(fV);return fV;}string gd(){return"&gt;";}int ge=0;const int gf=0;const int gg=1;const int gh=2;const
                int gi=3;const int gj=4;const int gk=5;const int gl=7;const int gm=8;const int gn=9;const int go=13;
                const int gp=10;const int gq=11;const int gr=12;const int gs=14;const int gt=15;const int gu=16;const
                int gv=17;const int gw=18;const int gx=19;const int gy=20;const int gz=21;const int gA=22;const int gB
                =23;const int gC=24;const int gD=25;const int gE=26;const int gF=27;const int gG=28;const int gH=29;
                const int gI=30;const int gJ=31;const int gK=50;const int gL=60;const int gM=111;const int gN=200;const
                int gO=210;const int gP=220;const int gQ=290;const int gR=400;const int gS=410;const int gT=500;const
                int gU=510;void gV(int gW){if(ge==gW)return;ge=gW;ij=0;ki();}cw gX;cw gY;cw gZ;cw ha;cw hb;cw hc;double
                hd=0;void he(){fr("clear",fb);fr(b+":SCAN!",fb);Echo("Scan:current_state="+ij.ToString());switch(ij)
                {case 0:{n();hd=0;gX=new cw(this,bP,5000);gY=new cw(this,bQ,5000);gZ=new cw(this,bT,5000);ha=new cw(this,
                bU,5000);hb=new cw(this,bS,5000);hc=new cw(this,bR,5000);ij=410;break;}case 410:{fr("Long Range Scan",
                fb);if(gX==null)ij=0;bWantMedium=true;hd+=Runtime.TimeSinceLastRun.TotalMilliseconds;if(gX.cY()){S(gX.cN);
                }if(gY.cY()){S(gY.cN);}if(gZ.cY()){S(gZ.cN);}if(ha.cY()){S(ha.cN);}if(hb.cY()){S(hb.cN);}if(hc.cY())
                {S(hc.cN);}string s="";s+="Front: ";if(gX.cV())s+="DONE!";else{s+=gX.cz.ToString("0")+" meters";}s+=
                " "+gX.cN.Count+" asteroids";s+="\n";s+="Back: ";if(gY.cV())s+="DONE!";else{s+=gY.cz.ToString("0")+" meters";
                }s+=" "+gY.cN.Count+" asteroids";s+="\n";s+="Left: ";if(gZ.cV())s+="DONE!";else{s+=gZ.cz.ToString("0")
                +" meters";}s+=" "+gZ.cN.Count+" asteroids";s+="\n";s+="Right: ";if(ha.cV())s+="DONE!";else{s+=ha.cz.ToString("0")
                +" meters";}s+=" "+ha.cN.Count+" asteroids";s+="\n";s+="Top: ";if(hb.cV())s+="DONE!";else{s+=hb.cz.ToString("0")
                +" meters";}s+=" "+hb.cN.Count+" asteroids";s+="\n";s+="Bottom: ";if(hc.cV())s+="DONE!";else{s+=hc.cz.ToString("0")
                +" meters";}s+=" "+hc.cN.Count+" asteroids";s+="\n";if(X()&lt;0)s+="No Known Asteroid";else s+="FOUND at least one asteroid!";
                fr(s,fb);Echo(s);if(gX.cV()&amp;&amp;gY.cV()&amp;&amp;gZ.cV()&amp;&amp;ha.cV()&amp;&amp;hb.cV()&amp;&amp;hc.cV()){gV(gS);}break;}}}Vector3D hf;
                bool hg=false;DateTime hh;double hi=100;double hj=50;bool hk=false;bool hl=true;bool hm=true;bool hn
                =true;float ho=-1;string hp="NAV";void hq(nr u){u.nS(hp,"DTMDebug",ref hk,true);u.nS(hp,"CameraCollision",
                ref hl,true);u.nS(hp,"SensorCollision",ref hm,true);u.nS(hp,"NAVEmulateOld",ref hn,true);u.nS(hp,"NAVGravityMinElevation",
                ref ho,true);}void hr(nr u){u.of(hp,"vTarget",hf);u.of(hp,"ValidNavTarget",hg);u.of(hp,"dStartShip",
                hh);u.of(hp,"shipSpeedMax",hi);u.of(hp,"arrivalDistanceMin",hj);}void hs(nr u){u.nS(hp,"vTarget",ref
                hf,true);u.nS(hp,"ValidNavTarget",ref hg,true);u.nS(hp,"dStartShip",ref hh,true);u.nS(hp,"shipSpeedMax",
                ref hi,true);u.nS(hp,"arrivalDistanceMin",ref hj,true);}List&lt;IMyTerminalBlock&gt;ht=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;hu=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;hv=new List&lt;IMyTerminalBlock&gt;();
                string hw(){ht.Clear();hu.Clear();hv.Clear();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(ht,mz);
                for(int i=0;i&lt;ht.Count;i++){if(ht[i].CustomName.Contains("[LEFT]")||ht[i].CustomData.Contains("[LEFT]"))
                {hu.Add(ht[i]);}else if(ht[i].CustomName.Contains("[RIGHT]")||ht[i].CustomData.Contains("[RIGHT]")){
                hv.Add(ht[i]);}}return"NR:L"+hu.Count.ToString("0")+"R"+hv.Count.ToString("0");}bool hx(float hy){if
                (hu.Count&lt;1)return false;float hz=hu[0].GetMaximum&lt;float&gt;("Velocity");var hA=hu[0]as IMyMotorStator;
                float hB=hA.TargetVelocityRPM;float hC=(hB/hz*100);hC=Math.Abs(hC);if(hy&gt;(hC+5f))hy=hC+5;if(hy&lt;(hC-5))
                hy=hC-5;if(hy&lt;0f)hy=0f;if(hy&gt;100f)hy=100f;if(Math.Abs(hy)&gt;0){hx(hu,-hy);hx(hv,hy);return true;}else return
                false;}bool hx(List&lt;IMyTerminalBlock&gt;rotorList,float hy){for(int i=0;i&lt;rotorList.Count;i++){var hA=rotorList[i]
                as IMyMotorStator;float hz=hA.GetMaximum&lt;float&gt;("Velocity");if(!hA.Enabled)hA.Enabled=true;float hE=
                hz*(hy/100.0f);hA.TargetVelocityRPM=hE;}return true;}bool hF(){hF(hu);hF(hv);return true;}bool hF(List&lt;IMyTerminalBlock&gt;
                rotorList){for(int i=0;i&lt;rotorList.Count;i++){IMyMotorStator hA=rotorList[i]as IMyMotorStator;hA.TargetVelocityRPM
                =0;}return true;}bool hG(double hH){float hy;if(Math.Abs(hH)&gt;1.0){hy=50;}else if(Math.Abs(hH)&gt;.7){hy
                =50;}else if(Math.Abs(hH)&gt;0.5){hy=30;}else if(Math.Abs(hH)&gt;0.1){hy=20;}else if(Math.Abs(hH)&gt;0.01){hy
                =5;}else if(Math.Abs(hH)&gt;0.001){hy=0;}else hy=0;hy/=3;hy=hy*-Math.Sign(hH);if(Math.Abs(hy)&gt;0){hx(hu,
                hy);}if(Math.Abs(hy)&gt;0){hx(hv,hy);}if(Math.Abs(hy)&gt;0)return false;else return true;}bool hI(string hJ)
                {string[]hK=hJ.Trim().Split(';');for(int hL=0;hL&lt;hK.Length;hL++){string[]hM=hK[hL].Trim().Split(' ');
                if(hM[0]=="timer"){s();}else if(hM[0]=="idle")ec();else if(hM[0]=="masterreset")p();else if(hM[0].ToLower()
                =="coast"){if(iF.Count&gt;1){bM(iF);}}else if(hM[0]=="setvaluef"){Echo("SetValueFloat");string hN="";for
                (int i=1;i&lt;hM.Length;i++){hN+=hM[i];if(i&lt;hM.Length-1){hN+=" ";}}string[]hO=hN.Trim().Split(':');if(hO.Length
                &lt;3){Echo("Invalid Args");continue;}IMyTerminalBlock bq;bq=(IMyTerminalBlock)GridTerminalSystem.GetBlockWithName(hO[0]);
                if(bq==null){Echo("Block not found:"+hO[0]);continue;}float hP=0;bool hQ=float.TryParse(hO[2].Trim(),
                out hP);if(!hQ){Echo("invalid float value:"+hO[2]);continue;}Echo("SetValueFloat:"+hO[0]+" "+hO[1]+" to:"
                +hP.ToString());bq.SetValueFloat(hO[1],hP);}else if(hM[0]=="brake"){Echo("brake");if(mN is IMyShipController)
                {IMyShipController hR=mN as IMyShipController;bool hS=hR.HandBrake;hR.ApplyAction("HandBrake");}else
                Echo("No Ship Controller found");}else if(hM[0]=="namecameras"){cq(bP,"Front");cq(bQ,"Back");cq(bR,"Down");
                cq(bS,"Up");cq(bT,"Left");cq(bU,"Right");}else if(hM[0]=="wcct"||hM[0]==""){}else{int hT;if(lh.TryGetValue(hM[0].ToLower(),
                out hT)){gV(hT);}else Echo("Unrecognized Command:"+hK[hL]);}}return false;}double hU=-1;List&lt;IMyTerminalBlock&gt;
                hV=new List&lt;IMyTerminalBlock&gt;();void hW(){hV.Clear();mG&lt;IMyReactor&gt;(ref hV);float hX;hZ(out hX);}double
                hY(){double j=0;foreach(var tb in hV){IMyReactor r=tb as IMyReactor;j+=r.CurrentOutput;}return j;}bool
                hZ(out float currentOutput){currentOutput=0;hU=-1;bool ia=false;if(hV.Count&gt;0)hU=0;foreach(IMyReactor
                r in hV){currentOutput+=r.CurrentOutput;hU+=r.MaxOutput;}return ia;}void ib(){if(iniWicoCraftSave==null)
                return;v(iniWicoCraftSave);iniWicoCraftSave.of(@if,"Mode",ge.ToString());iniWicoCraftSave.of(@if,"current_state",
                ij.ToString());iniWicoCraftSave.of(@if,"PassedArgument",sPassedArgument);iniWicoCraftSave.of(@if,"AlertStates",
                @in.ToString());iniWicoCraftSave.of(@if,"craft_operation",il.ToString());iniWicoCraftSave.of(@if,"PassedArgument",
                sPassedArgument);iniWicoCraftSave.of(@if,"ReceivedMessage",io);long ic=0;if(ih!=null)ic=ih.EntityId;
                iniWicoCraftSave.of(@if,"SaveID",(long)ic);if(iniWicoCraftSave.nC){if(iniWicoCraftSave.nC){string id
                =iniWicoCraftSave.oj();if(ih==null){Storage=id;}else{ih.WritePublicText(id,false);}}}else{Echo("Not saving: Same");
                }}string ie="Wico Craft Save";string@if="WCCM2";void SerializeInitCustomData(nr iNIHolder){iNIHolder.nS(@if,
                "SAVE_FILE_NAME",ref ie,true);}IMyTextPanel ih=null;nr iniWicoCraftSave;int ij=0;long allBlocksCount
                =0;int il=dC;string sPassedArgument="";int@in=0;string io="";string SerializeInit(){string fV="S";ih
                =null;List&lt;IMyTerminalBlock&gt;bK=new List&lt;IMyTerminalBlock&gt;();bK=mM&lt;IMyTextPanel&gt;(ie);if(bK.Count&gt;1)Echo("Multiple blocks found: \""
                +ie+"\"");else if(bK.Count==0){bK=mI&lt;IMyTextPanel&gt;(ie);if(bK.Count==1)ih=bK[0]as IMyTextPanel;else{bK
                =mL&lt;IMyTextPanel&gt;(ie);if(bK.Count==1)ih=bK[0]as IMyTextPanel;}}else ih=bK[0]as IMyTextPanel;iniWicoCraftSave
                =new nr(this,"");if(ih==null){fV="-";Echo(ie+" (TextPanel) is missing or Named incorrectly. ");}return
                fV;}bool iq(){return ih!=null;}string ir(Vector3D v){string s;s=v.X.ToString("0.00")+":"+v.Y.ToString("0.00")
                +":"+v.Z.ToString("0.00");return s;}bool@is(string sVector,out double x,out double y,out double z){string[]
                iu=sVector.Trim().Split(',');if(iu.Length&lt;3){iu=sVector.Trim().Split(':');}x=0;y=0;z=0;if(iu.Length&lt;
                3)return false;bool iv=double.TryParse(iu[0].Trim(),out x);bool iw=double.TryParse(iu[1].Trim(),out y);
                bool ix=double.TryParse(iu[2].Trim(),out z);if(!iv||!iw||!ix){return false;}return true;}List&lt;IMyTerminalBlock&gt;
                iy=new List&lt;IMyTerminalBlock&gt;();float iz=0;double iA=-1;void iB(){iy.Clear();iA=-1;GridTerminalSystem.GetBlocksOfType&lt;IMySolarPanel&gt;(iy,
                mz);iC();}void iC(){if(iy.Count&gt;0)iA=0;iz=0;foreach(var tb in iy){IMySolarPanel r=tb as IMySolarPanel;
                iA+=r.MaxOutput;iz+=r.CurrentOutput;}}List&lt;IMyTerminalBlock&gt;iD=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                iE=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;iF=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                iG=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;iH=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                iI=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;iJ=new List&lt;IMyTerminalBlock&gt;();double iK=0;double
                iL=0;double iM=0;double iN=0;double iO=0;double iP=0;int iQ=0;int iR=0;int iS=0;const int iT=1;const
                int iU=2;const int iV=4;const int iW=0xff;Matrix iX=new Matrix(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);string
                iY="IGNORE";string iZ="cutter";string ja="THRUSTERS";void jb(nr iNIHolder){iNIHolder.nS(ja,"IgnoreThruster",
                ref iY);iNIHolder.nS(ja,"CutterThruster",ref iZ);}void jc(IMyTerminalBlock cm,ref List&lt;IMyTerminalBlock&gt;
                iE,ref List&lt;IMyTerminalBlock&gt;iF,ref List&lt;IMyTerminalBlock&gt;iG,ref List&lt;IMyTerminalBlock&gt;iH,ref List&lt;IMyTerminalBlock&gt;
                iI,ref List&lt;IMyTerminalBlock&gt;iJ,int jd=iW){iE.Clear();iF.Clear();iG.Clear();iH.Clear();iI.Clear();iJ.Clear();
                iD.Clear();if(cm==null)return;var je=new List&lt;IMyTerminalBlock&gt;();mG&lt;IMyThrust&gt;(ref je);for(int i=0;
                i&lt;je.Count;i++){if(je[i].CustomName.ToLower().Contains(iZ)||je[i].CustomData.ToLower().Contains(iZ))
                continue;if(je[i].CustomName.ToLower().Contains(iY)||je[i].CustomData.ToLower().Contains(iY))continue;
                iD.Add(je[i]);}Matrix cn;cm.Orientation.GetMatrix(out cn);Matrix.Transpose(ref cn,out cn);iK=0;iL=0;
                iM=0;iN=0;iO=0;iP=0;for(int i=0;i&lt;iD.Count;++i){var jf=iD[i]as IMyThrust;Matrix jg;jf.Orientation.GetMatrix(out
                jg);Vector3 cp=Vector3.Transform(jg.Backward,cn);int jh=ji(iD[i]);if(jh==iT)iS++;else if(jh==iU)iR++;
                else if(jh==iV)iQ++;if(cp==iX.Left){iO+=jj((IMyThrust)iD[i]);iI.Add(iD[i]);}else if(cp==iX.Right){iP
                +=jj((IMyThrust)iD[i]);iJ.Add(iD[i]);}else if(cp==iX.Backward){iL+=jj((IMyThrust)iD[i]);iF.Add(iD[i]);
                }else if(cp==iX.Forward){iK+=jj((IMyThrust)iD[i]);iE.Add(iD[i]);}else if(cp==iX.Up){iN+=jj((IMyThrust)iD[i]);
                iH.Add(iD[i]);}else if(cp==iX.Down){iM+=jj((IMyThrust)iD[i]);iG.Add(iD[i]);}}}string jc(IMyTerminalBlock
                cm){iE.Clear();iF.Clear();iG.Clear();iH.Clear();iI.Clear();iJ.Clear();iD.Clear();if(cm==null)return"No Orientation Block";
                var je=new List&lt;IMyTerminalBlock&gt;();mG&lt;IMyThrust&gt;(ref je);for(int i=0;i&lt;je.Count;i++){if(je[i].CustomName.ToLower().Contains(iZ)
                ||je[i].CustomData.ToLower().Contains(iZ))continue;if(je[i].CustomName.ToLower().Contains(iY)||je[i].CustomData.ToLower().Contains(iY))
                continue;iD.Add(je[i]);}Matrix cn;cm.Orientation.GetMatrix(out cn);Matrix.Transpose(ref cn,out cn);iK
                =0;iL=0;iM=0;iN=0;iO=0;iP=0;for(int i=0;i&lt;iD.Count;++i){var jf=iD[i]as IMyThrust;Matrix jg;jf.Orientation.GetMatrix(out
                jg);Vector3 cp=Vector3.Transform(jg.Backward,cn);int jh=ji(iD[i]);if(jh==iT)iS++;else if(jh==iU)iR++;
                else if(jh==iV)iQ++;if(cp==iX.Left){iO+=jj((IMyThrust)iD[i]);iI.Add(iD[i]);}else if(cp==iX.Right){iP
                +=jj((IMyThrust)iD[i]);iJ.Add(iD[i]);}else if(cp==iX.Backward){iL+=jj((IMyThrust)iD[i]);iF.Add(iD[i]);
                }else if(cp==iX.Forward){iK+=jj((IMyThrust)iD[i]);iE.Add(iD[i]);}else if(cp==iX.Up){iN+=jj((IMyThrust)iD[i]);
                iH.Add(iD[i]);}else if(cp==iX.Down){iM+=jj((IMyThrust)iD[i]);iG.Add(iD[i]);}}string s;s="&gt;";s+="F"+iE.Count.ToString("00");
                s+="B"+iF.Count.ToString("00");s+="D"+iG.Count.ToString("00");s+="U"+iH.Count.ToString("00");s+="L"+
                iI.Count.ToString("00");s+="R"+iJ.Count.ToString("00");s+="&lt;";return s;}int ji(IMyTerminalBlock theBlock)
                {if(theBlock is IMyThrust){if(theBlock.BlockDefinition.SubtypeId.Contains("Atmo"))return iT;else if(theBlock.BlockDefinition.SubtypeId.Contains("Hydro"))
                return iU;else return iV;}return 0;}double jj(IMyThrust thruster){return thruster.MaxEffectiveThrust;
                }double jk(List&lt;IMyTerminalBlock&gt;jl,int eA=iW){double jm=0;for(int jn=0;jn&lt;jl.Count;jn++){int jo=ji(jl[jn]);
                if((jo&amp;eA)&gt;0){IMyThrust jf=jl[jn]as IMyThrust;double jp=jf.MaxEffectiveThrust;jm+=jp;}}return jm;}bool
                jq(List&lt;IMyTerminalBlock&gt;jl,out float jr,out float er,out float js){jr=0;er=0;js=0;double jt=jk(jl,iV);
                double ju=jk(jl,iT);double jv=jk(jl,iU);MyShipMass gc;gc=((IMyShipController)mN).CalculateShipMass();
                double jw=0;jw=gc.PhysicalMass*lD*9.810;if(ju&gt;0){if(ju&lt;jw){jr=100;jw-=ju;}else{jr=(float)(jw/ju*100);
                if(jr&gt;0)jw-=(ju*jr/100);}}if(jt&gt;0&amp;&amp;jw&gt;0){if(jt&lt;jw){js=100;jw-=jt;}else{js=(float)(jw/jt*100);if(js&gt;0)
                jw-=((jt*js)/100);}}if(jv&gt;0&amp;&amp;jw&gt;0){if(jv&lt;jw){er=100;jw-=jv;}else{er=(float)(jw/jv*100);if(er&gt;0)jw-=((jv
                *er)/100);;}}if(jw&gt;0)return false;return true;}List&lt;IMyTerminalBlock&gt;jx(string jy){var jz=new List&lt;IMyTerminalBlock&gt;();
                var jA=new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(jA);for(int jB=0;jB&lt;jA.Count;jB++)
                {if(jA[jB].Name==jy){List&lt;IMyTerminalBlock&gt;jl=null;jA[jB].GetBlocks(jl,mz);for(int jn=0;jn&lt;jl.Count;
                jn++){jz.Add(jl[jn]);}break;}}return jz;}int jC(List&lt;IMyTerminalBlock&gt;jl,float bG,int eA=iW){int I=0;
                if(bG&gt;100)bG=100;if(bG&lt;0)bG=0;for(int jn=0;jn&lt;jl.Count;jn++){int jo=ji(jl[jn]);if((jo&amp;eA)&gt;0){IMyThrust
                jf=jl[jn]as IMyThrust;if(!jf.IsWorking){jf.Enabled=true;}I+=1;jf.ThrustOverridePercentage=bG/100f;}}
                return I;}int jC(List&lt;IMyTerminalBlock&gt;jl,int jD=100,int eA=iW){return jC(jl,(float)jD,eA);}bool jC(string
                jE,int jD=100,int eA=iW){if(jD&gt;100)jD=100;var jA=new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(jA);
                for(int jB=0;jB&lt;jA.Count;jB++){if(jA[jB].Name==jE){List&lt;IMyTerminalBlock&gt;jl=null;jA[jB].GetBlocks(jl,
                mz);return(jC(jl,jD,eA)&gt;0);}}return false;}int jF(List&lt;IMyTerminalBlock&gt;thrusters,int eA=iW,bool jG=
                false){int I=0;for(int jn=0;jn&lt;thrusters.Count;jn++){int jo=ji(thrusters[jn]);if((jo&amp;eA)&gt;0){I++;IMyThrust
                jf=thrusters[jn]as IMyThrust;jf.ThrustOverride=0;if(jf.IsWorking&amp;&amp;jG)jf.Enabled=false;else if(!jf.IsWorking
                &amp;&amp;!jG)jf.Enabled=true;}}return I;}bool jF(string jE){var jA=new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(jA);
                for(int jB=0;jB&lt;jA.Count;jB++){if(jA[jB].Name==jE){List&lt;IMyTerminalBlock&gt;jl=null;jA[jB].GetBlocks(jl,
                mz);return(jF(jl)&gt;0);}}return false;}bool jC(){return(jC(iE)&gt;0);}bool jF(){return(jF(iE)&gt;0);}double jH(List&lt;IMyTerminalBlock&gt;
                jI,int eA=iW){for(int i=0;i&lt;jI.Count;i++){int jo=ji(jI[i]);if((jo&amp;eA)&gt;0&amp;&amp;jI[i].IsWorking){var jf=jI[i]
                as IMyThrust;return jf.ThrustOverride;}}return 0;}bool jJ(List&lt;IMyTerminalBlock&gt;jI,int eA=iW){for(int
                i=0;i&lt;jI.Count;i++){int jo=ji(jI[i]);if((jo&amp;eA)&gt;0&amp;&amp;jI[i].IsWorking){return true;}}return false;}int jK(List&lt;IMyTerminalBlock&gt;
                jI,int eA=iW){int I=0;for(int i=0;i&lt;jI.Count;i++){int jo=ji(jI[i]);if((jo&amp;eA)&gt;0&amp;&amp;jI[i].IsWorking){I++;
                }}return I;}IMyThrust jL(List&lt;IMyTerminalBlock&gt;jM,int jN=iW){foreach(var thrust in iD){if(thrust is IMyThrust
                &amp;&amp;(ji(thrust)&amp;jN)&gt;0)return thrust as IMyThrust;}return null;}double jO(){if(iS&lt;1)return 0;var jP=jL(iD,
                iT);if(jP==null)return 0;return jP.MaxEffectiveThrust/jP.MaxThrust;}double jQ(List&lt;IMyTerminalBlock&gt;
                iH,double jR,double jS){var gc=((IMyShipController)mN).CalculateShipMass();double jw=0;jw=gc.PhysicalMass
                *jS*9.810;double jj=jk(iH);double jT=(jj-jw)/gc.TotalMass;double jU=jR/jT;double jV=jR/2*jU;return jV;
                }string[]jW={"-","\\","|","/","-","\\","|","/"};int jX=99;string jY(){jX++;if(jX&gt;=jW.Length)jX=0;return
                jW[jX];}const string jZ="[WCCT]";const string ka="[WCCS]";const string kb="[WCCM]";Dictionary&lt;string,
                List&lt;IMyTerminalBlock&gt;&gt;kc=new Dictionary&lt;string,List&lt;IMyTerminalBlock&gt;&gt;();void kd(){kc.Clear();}bool
                ke(string kf="[WCCS]"){bool kg=false;List&lt;IMyTerminalBlock&gt;bK=new List&lt;IMyTerminalBlock&gt;();IMyTimerBlock
                kh=null;if(kc.ContainsKey(kf)){bK=kc[kf];}else{bK=mI&lt;IMyTerminalBlock&gt;(kf);kc.Add(kf,bK);}for(int i=
                0;i&lt;bK.Count;i++){kh=bK[i]as IMyTimerBlock;if(kh!=null){kh.ApplyAction("TriggerNow");kg=true;}}return
                kg;}void ki(){Runtime.UpdateFrequency|=UpdateFrequency.Once;}bool kj=false;List&lt;IMyRadioAntenna&gt;kk=new
                List&lt;IMyRadioAntenna&gt;();List&lt;IMyLaserAntenna&gt;kl=new List&lt;IMyLaserAntenna&gt;();string km(){kk.Clear();kl.Clear();
                mG&lt;IMyRadioAntenna&gt;(ref kk);mG&lt;IMyLaserAntenna&gt;(ref kl);for(int i1=0;i1&lt;kk.Count;++i1){if(kk[i1].CustomName.Contains("unused")
                ||kk[i1].CustomData.Contains("unused"))continue;if(!kj){a="Wico "+kk[i1].CustomName.Split('!')[0].Trim();
                kj=true;}}return"A"+kk.Count.ToString("0");}void kn(){for(int i=0;i&lt;kk.Count;i++){kk[i].Enabled=true;
                }}string ko="";void kp(){if(io!=""){if(ko==io){io="";}ko=io;}else ko="";}void kq(){}void kr(){float ks
                =0;int kt=-1;for(int i=0;i&lt;kk.Count;i++){if(kk[i].AttachedProgrammableBlock==Me.EntityId){kt=i;break;
                }if(kk[i].Radius&gt;ks&amp;&amp;kk[i].AttachedProgrammableBlock==0){kt=i;ks=kk[i].Radius;}}if(kt&gt;=0){if(kk[kt].AttachedProgrammableBlock
                !=Me.EntityId)fV+="\nSetting Antenna PB";kk[kt].AttachedProgrammableBlock=Me.EntityId;}else{}}void ku(bool
                kv=false){if(kk.Count&lt;1)km();foreach(var a in kk){a.Radius=200;if(a.AttachedProgrammableBlock&gt;0||kv)
                {a.Enabled=true;}}}void kw(float kx=200,bool kv=false){if(kk.Count&lt;1)km();foreach(var a1 in kk){if(a1.AttachedProgrammableBlock
                &gt;0||kv){a1.Radius=kx;a1.Enabled=true;}}}Vector3D ky(){if(kk.Count&lt;1)km();foreach(var a1 in kk){if(a1.AttachedProgrammableBlock
                ==Me.EntityId){return a1.GetPosition();}}foreach(var a1 in kk){return a1.GetPosition();}Vector3D kz=
                new Vector3D();return kz;}void kA(bool kv=false,float kB=float.MaxValue){if(kk==null||kk.Count&lt;1)km();
                if(kB&lt;200)kB=200;foreach(var a in kk){if(a.AttachedProgrammableBlock&gt;0||kv){float kC=a.GetMaximum&lt;float&gt;("Radius");
                if(kB&lt;kC)kC=kB;a.Radius=kC;a.Enabled=true;}}}int kD(){if(kk.Count&lt;1)km();return(kk.Count);}List&lt;string&gt;
                kE=new List&lt;string&gt;();void kF(){if(kE.Count&gt;0){kG(kE[0]);kE.RemoveAt(0);}if(kE.Count&gt;0)lv=true;}void
                kG(string kH){bool kI=false;if(kk.Count&lt;1)km();for(int i=0;i&lt;kk.Count;i++){kI=kk[i].TransmitMessage(kH);
                if(kI)break;}if(!kI){if(kD()&gt;0){kE.Add(kH);lv=true;}}}List&lt;string&gt;kJ=new List&lt;string&gt;();void kK(bool
                kL=false){if(kJ.Count&gt;0){if(io==""){io=kJ[0];kJ.RemoveAt(0);if(kL){lv=true;}else{ki();}}}if(kJ.Count
                &gt;0){}}void kM(string kH){kJ.Add(kH);kK();}void kN(){if(kk.Count&gt;0){Echo(kJ.Count+" Pending Incoming Messages");
                for(int i=0;i&lt;kJ.Count;i++)Echo(i+":"+kJ[i]);}else Echo("No antennas found");}List&lt;IMyTerminalBlock&gt;
                kO=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;kP=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                kQ=new List&lt;IMyTerminalBlock&gt;();bool kR=false;string kS="[BASE]";string kT="[DOCK]";string kU="CONNECTORS";
                void kV(nr iNIHolder){iNIHolder.nS(kU,"BaseConnector",ref kS,true);iNIHolder.nS(kU,"DockConnector",ref
                kT,true);}string kW(){kR=false;kO.Clear();kP.Clear();kQ.Clear();kX();return"CL"+kO.Count.ToString()+
                "CD"+kP.Count.ToString()+"CB"+kQ.Count.ToString();}void kX(){if(kO.Count&lt;1&amp;&amp;!kR)kO=mG&lt;IMyShipConnector&gt;();
                if(kP.Count&lt;1&amp;&amp;!kR)kP=mI&lt;IMyShipConnector&gt;(kT);if(kP.Count&lt;1&amp;&amp;!kR)kP=kO;if(kQ.Count&lt;1&amp;&amp;!kR)kQ=mI&lt;IMyShipConnector&gt;(kS);
                kR=true;return;}bool kY(){kX();for(int i=0;i&lt;kP.Count;i++){var kZ=kP[i]as IMyShipConnector;if(kZ==null)
                continue;if(kZ.Status==MyShipConnectorStatus.Connectable)return true;}return false;}bool la(){kX();for
                (int i=0;i&lt;kP.Count;i++){var kZ=kP[i]as IMyShipConnector;if(kZ==null)continue;if(kZ.Status==MyShipConnectorStatus.Connected)
                {var lb=kZ.OtherConnector;if(lb.CubeGrid==kZ.CubeGrid){continue;}else return true;}}return false;}IMyTerminalBlock
                lc(){kX();if(kP.Count&gt;0){return kP[0];}return null;}IMyTerminalBlock ld(bool le=false){kX();for(int i
                =0;i&lt;kP.Count;i++){var kZ=kP[i]as IMyShipConnector;if(kZ==null)continue;if(kZ.Status==MyShipConnectorStatus.Connected)
                {var lb=kZ.OtherConnector;if(lb.CubeGrid==kZ.CubeGrid){continue;}else{if(!le){return kZ.OtherConnector;
                }else{return kP[i];}}}}return null;}void lf(bool lg=true,bool bL=true){kX();for(int i=0;i&lt;kP.Count;i++)
                {var kZ=kP[i]as IMyShipConnector;if(kZ==null)continue;if(kZ.Status==MyShipConnectorStatus.Connected)
                {var lb=kZ.OtherConnector;if(lb.CubeGrid==kZ.CubeGrid){continue;}}if(lg){if(kZ.Status==MyShipConnectorStatus.Connectable)
                kZ.ApplyAction("SwitchLock");}else{if(kZ.Status==MyShipConnectorStatus.Connected)kZ.ApplyAction("SwitchLock");
                }kZ.Enabled=bL;}return;}Dictionary&lt;string,int&gt;lh=new Dictionary&lt;string,int&gt;();string li="";UpdateFrequency
                lj=UpdateFrequency.Once;bool lk=true;bool ll=true;bool lm=false;float ln=100;string lo="WORLD";void lp(nr
                u){u.nS(lo,"MaxWorldMps",ref ln,true);}public Program(){fS();nr fU=new nr(this,Me.CustomData);fU.nS(a,
                "EchoOn",ref lq,true);lr=Echo;Echo=MyEcho;lp(fU);lZ(fU);eU(fU);fT(fU);if(fU.nC){Me.CustomData=fU.oj(true);
                }li=a+":"+b+" V"+c+" ";lr(li+"Creator");fv();fr("clear",eZ,true);if(!ke(kb)){Runtime.UpdateFrequency
                |=UpdateFrequency.Update100;}if(!Me.Enabled){Echo("I am turned OFF!");}}bool lq=true;Action&lt;string&gt;lr;
                void MyEcho(string j){if(lq)lr(j);}bool lt=false;bool lu=false;bool lv=false;bool bWantMedium=false;
                bool lx=false;double ly;double lz=5;double lA=-1;double lB=3;double lC=-1;double lD=-2;void Main(string
                hJ,UpdateType ut){Echo(li+jY());lv=false;bWantMedium=false;if(lA&gt;lz){lA=0;lx=false;var jM=new List&lt;IMyTerminalBlock&gt;();
                GridTerminalSystem.GetBlocksOfType&lt;IMyProjector&gt;(jM,mz);for(int i=0;i&lt;jM.Count;i++){if(jM[i].IsWorking)
                {if(jM[i].CustomName.Contains("!WCC")||jM[i].CustomData.Contains("!WCC"))continue;Echo("Working local Projector found!");
                lx=true;}}}else{if(lA&lt;0){lA=lz+5;}lA+=Runtime.TimeSinceLastRun.TotalSeconds;}sPassedArgument="";double
                lE=0;if(mN is IMyShipController){if(lC&gt;lB||!lt){Echo("DO Grid Check");lC=0;MyShipMass gc;gc=((IMyShipController)mN).CalculateShipMass();
                lE=gc.BaseMass;Echo("New="+lE+" CurrentM="+fX);if(gc.BaseMass==0)Echo("No Mass--Station?");if(lE!=fX
                &amp;&amp;fX&gt;0){Echo("MASS CHANGE");fr(a+":"+b+":MASS CHANGE",eZ,true);}}else{if(lC&lt;0){lC=lB+5;}lC+=Runtime.TimeSinceLastRun.TotalSeconds;
                lE=fX;}}else{fX=lE=0;}if(hJ=="init"||(Math.Abs(lE-fX)&gt;1&amp;&amp;fX&gt;0&amp;&amp;fW==0)||(fW==0&amp;&amp;mi())){fD("INIT or GRID/MASS CHANGE!");
                Echo("Arg init or grid/mass change!");fV="";lt=false;fW=0;sPassedArgument="init";}fD("clear");if(!lt)
                {if(lx){fD("Construction in Progress\nTurn off projector to continue");fr("Construction in Progress\nTurn off projector to continue",
                fb);}else{}lv=true;doInit();lu=true;}else{if(lk)dQ();sPassedArgument=hJ;if(lu){fr(DateTime.Now.ToString()
                +" "+fV,eZ,true);}IMyTerminalBlock lF=mN;if(mN!=null){}if(mN is IMyShipController){ly=((IMyShipController)mN).GetShipSpeed();
                Vector3D lG=((IMyShipController)mN).GetNaturalGravity();double lH=lG.Length();lD=lH/9.81;}else{lD=-1.0;
                }if(hI(hJ)){fw();return;}i();eb();}if(lk)ib();if((ih==null)){if(lk)Echo("Cannot use sub-modules; missing controller and/or SaveFile");
                }else{if(lt||lu){ke();}}if(lv){Echo("FAST!");Runtime.UpdateFrequency|=lj;}else{Runtime.UpdateFrequency
                &amp;=~(lj);}if(bWantMedium){Runtime.UpdateFrequency|=UpdateFrequency.Update10;}else{Runtime.UpdateFrequency
                &amp;=~(UpdateFrequency.Update10);}lu=false;if(ll)Echo(craftOperation());m();fw();}void lI(string li=null)
                {float lJ=0;lJ=Runtime.CurrentInstructionCount/(float)Runtime.MaxInstructionCount;if(li==null)li="Instructions=";
                Echo(li+(lJ*100).ToString("0.00")+"%");}List&lt;IMyTerminalBlock&gt;lK=new List&lt;IMyTerminalBlock&gt;();string
                lL(){List&lt;IMyTerminalBlock&gt;lM=new List&lt;IMyTerminalBlock&gt;();lK.Clear();lM=mG&lt;IMyShipDrill&gt;();foreach(var
                b in lM)lK.Add(b as IMyTerminalBlock);return"D"+lK.Count.ToString("00");}void lN(){foreach(IMyFunctionalBlock
                b in lK){b.Enabled=true;}}void lO(){if(lK.Count&lt;1)lL();foreach(IMyFunctionalBlock b in lK){b.Enabled
                =false;}}bool lP(){if(lK.Count&lt;1)lL();if(lK.Count&lt;1)return false;return true;}List&lt;IMyTerminalBlock&gt;
                lQ=new List&lt;IMyTerminalBlock&gt;();string lR(){List&lt;IMyTerminalBlock&gt;lM=new List&lt;IMyTerminalBlock&gt;();lQ.Clear();
                lM=mI&lt;IMyShipConnector&gt;("Ejector");foreach(var b in lM)lQ.Add(b as IMyTerminalBlock);return"E"+lQ.Count.ToString("00");
                }void lS(){foreach(IMyFunctionalBlock b in lQ){b.Enabled=true;}}void lT(){if(lQ.Count&lt;1)lR();foreach
                (IMyFunctionalBlock b in lQ){b.Enabled=false;}}string lU="NOFOLLOW";string lV="!WCC";string lW="[NAV]";
                string lX="Craft Remote Control";string lY="GRIDS";void lZ(nr iNIHolder){iNIHolder.nS(lY,"NoFollow",
                ref lU,true);iNIHolder.nS(lY,"BlockIgnore",ref lV,true);iNIHolder.nS(lY,"OrientationBlockContains",ref
                lW,true);iNIHolder.nS(lY,"OrientationBlockNamed",ref lX,true);}List&lt;IMyTerminalBlock&gt;ma=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTextPanel&gt;mb=new List&lt;IMyTextPanel&gt;();List&lt;IMyTextPanel&gt;mc=new List&lt;IMyTextPanel&gt;();List&lt;IMyTerminalBlock&gt;
                md=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyCubeGrid&gt;me=new List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;mf=new List&lt;IMyCubeGrid&gt;();
                List&lt;IMyCubeGrid&gt;mg=new List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;mh=new List&lt;IMyCubeGrid&gt;();bool mi(){List&lt;IMyTerminalBlock&gt;
                mj=new List&lt;IMyTerminalBlock&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyTerminalBlock&gt;(mj);if(allBlocksCount
                !=mj.Count){return true;}return false;}string mk(){ma.Clear();mh.Clear();me.Clear();mf.Clear();mg.Clear();
                mb.Clear();mc.Clear();GridTerminalSystem.GetBlocksOfType&lt;IMyTerminalBlock&gt;(ma);allBlocksCount=ma.Count;
                foreach(var block in ma){var ml=block.CubeGrid;if(!mh.Contains(ml)){mh.Add(ml);}}mo(Me.CubeGrid);foreach
                (var grid in mh){if(me.Contains(grid))continue;bool mm=false;List&lt;IMyShipConnector&gt;mn=new List&lt;IMyShipConnector&gt;();
                GridTerminalSystem.GetBlocksOfType&lt;IMyShipConnector&gt;(mn,(x1=&gt;x1.CubeGrid==grid));foreach(var connector
                in mn){if(connector.Status==MyShipConnectorStatus.Connected){if(me.Contains(connector.OtherConnector.CubeGrid)
                ||mf.Contains(connector.OtherConnector.CubeGrid)){continue;}if(me.Contains(connector.OtherConnector.CubeGrid))
                mm=true;else mm=false;}}if(mm){if(!mg.Contains(grid)){mg.Add(grid);}}if(!mf.Contains(grid)){mf.Add(grid);
                }}string s="";s+="B"+ma.Count.ToString();s+="G"+mh.Count.ToString();s+="L"+me.Count.ToString();s+="D"
                +mg.Count.ToString();s+="R"+mf.Count.ToString();return s;}void mo(IMyCubeGrid ml){if(ml==null)return;
                if(!me.Contains(ml)){me.Add(ml);mp(ml);ms(ml);mu(ml);mw(ml);}}void mp(IMyCubeGrid grid){List&lt;IMyMotorStator&gt;
                mq=new List&lt;IMyMotorStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(mq,(x=&gt;x.TopGrid==grid));
                foreach(var rotor in mq){if(rotor.CustomName.Contains(lU)||rotor.CustomData.Contains(lU))continue;mo(rotor.CubeGrid);
                }List&lt;IMyMotorAdvancedStator&gt;mr=new List&lt;IMyMotorAdvancedStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorAdvancedStator&gt;(mr,
                (x=&gt;x.TopGrid==grid));foreach(var rotor in mr){if(rotor.CustomName.Contains(lU)||rotor.CustomData.Contains(lU))
                continue;mo(rotor.CubeGrid);}}void ms(IMyCubeGrid grid){List&lt;IMyPistonBase&gt;mt=new List&lt;IMyPistonBase&gt;();
                GridTerminalSystem.GetBlocksOfType&lt;IMyPistonBase&gt;(mt,(x=&gt;x.TopGrid==grid));foreach(var piston in mt)
                {mo(piston.CubeGrid);}}void mu(IMyCubeGrid grid){List&lt;IMyMotorStator&gt;mq=new List&lt;IMyMotorStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(mq,
                (x1=&gt;x1.CubeGrid==grid));foreach(var rotor in mq){if(rotor.CustomName.Contains(lU)||rotor.CustomData.Contains(lU))
                continue;IMyCubeGrid mv=rotor.TopGrid;if(mv!=null&amp;&amp;mv!=grid){mo(mv);}}mq.Clear();List&lt;IMyMotorAdvancedStator&gt;
                mr=new List&lt;IMyMotorAdvancedStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorAdvancedStator&gt;(mr,
                (x1=&gt;x1.CubeGrid==grid));foreach(var rotor in mr){if(rotor.CustomName.Contains(lU)||rotor.CustomData.Contains(lU))
                continue;IMyCubeGrid mv=rotor.TopGrid;if(mv!=null&amp;&amp;mv!=grid){mo(mv);}}}void mw(IMyCubeGrid grid){List&lt;IMyPistonBase&gt;
                mt=new List&lt;IMyPistonBase&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyPistonBase&gt;(mt,(x1=&gt;x1.CubeGrid==
                grid));foreach(var piston in mt){IMyCubeGrid mv=piston.TopGrid;if(mv!=null&amp;&amp;mv!=grid){if(!me.Contains(mv))
                {mo(mv);}}}}List&lt;IMyCubeGrid&gt;mx(){if(me.Count&lt;1){mk();}return me;}List&lt;IMyCubeGrid&gt;my(){if(me.Count&lt;
                1){mk();}return mg;}bool mz(IMyTerminalBlock block){return mx().Contains(block.CubeGrid);}bool IsGridLocal(long
                myCubeGrid){for(int i1=0;i1&lt;me.Count;i1++){if((long)me[i1].EntityId==myCubeGrid)return true;}return false;
                }bool mA(IMyCubeGrid mB){return mx().Contains(mB);}bool mC(IMyTerminalBlock bq){var g1=my();if(g1==null)
                return false;return g1.Contains(bq.CubeGrid);}void mD(){if(ma.Count&lt;1)mk();md.Clear();foreach(var b1
                in ma){if(mz(b1)&amp;&amp;!(b1.CustomName.Contains(lV)||b1.CustomData.Contains(lV)))md.Add(b1);}}IMyTerminalBlock
                mE(string mF){IMyTerminalBlock bq;bq=(IMyTerminalBlock)GridTerminalSystem.GetBlockWithName(mF);if(bq
                ==null)throw new Exception(mF+" Not Found");return bq;}public List&lt;T&gt;mG&lt;T&gt;(ref List&lt;T&gt;lM,string mH=null)where
                T:class{if(lM==null)lM=new List&lt;T&gt;();else lM.Clear();if(md.Count&lt;1)mD();for(int e1=0;e1&lt;md.Count;e1++)
                {if(md[e1]is T&amp;&amp;((mH==null)||(mH!=null&amp;&amp;md[e1].CustomName.StartsWith(mH)))){lM.Add((T)md[e1]);}}return
                lM;}public List&lt;IMyTerminalBlock&gt;mG&lt;T&gt;(ref List&lt;IMyTerminalBlock&gt;Output,string Keyword=null)where T:
                class{if(ma.Count&lt;1)mk();if(Output==null)Output=new List&lt;IMyTerminalBlock&gt;();else Output.Clear();if(md.Count
                &lt;1)mD();for(int e1=0;e1&lt;md.Count;e1++){if(md[e1]is T&amp;&amp;((Keyword==null)||(Keyword!=null&amp;&amp;md[e1].CustomName.StartsWith(Keyword))))
                {Output.Add(md[e1]);}}return Output;}public List&lt;IMyTerminalBlock&gt;mG&lt;T&gt;(string Keyword=null)where T:
                class{var lM=new List&lt;IMyTerminalBlock&gt;();mG&lt;T&gt;(ref lM,Keyword);return lM;}public List&lt;IMyTerminalBlock&gt;
                mI&lt;T&gt;(string Keyword=null)where T:class{var lM=new List&lt;IMyTerminalBlock&gt;();if(md.Count&lt;1)mD();for(int
                e1=0;e1&lt;md.Count;e1++){if(md[e1]is T&amp;&amp;Keyword!=null&amp;&amp;(md[e1].CustomName.Contains(Keyword)||md[e1].CustomData.Contains(Keyword)))
                {lM.Add(md[e1]);}}return lM;}public List&lt;IMyTextPanel&gt;mJ(string mH=null){if(ma.Count&lt;1)mk();var lM=new
                List&lt;IMyTextPanel&gt;();if(mb.Count&gt;1){foreach(var t1 in mb){if(mH!=null&amp;&amp;(t1.CustomName.Contains(mH)||
                t1.CustomData.Contains(mH)))lM.Add(t1);}}else{foreach(var t1 in ma){if(t1 is IMyTextPanel&amp;&amp;mz(t1)&amp;&amp;!(t1.CustomName.Contains(lV)
                ||t1.CustomData.Contains(lV))){if(mH!=null&amp;&amp;(t1.CustomName.Contains(mH)||t1.CustomData.Contains(mH)))
                lM.Add(t1 as IMyTextPanel);mb.Add(t1 as IMyTextPanel);}}}return lM;}public List&lt;IMyTextPanel&gt;mK(string
                mH=null){if(md.Count&lt;1)mD();var lM=new List&lt;IMyTextPanel&gt;();if(mc.Count&gt;1){foreach(var t1 in mc){if(mH
                !=null&amp;&amp;(t1.CustomName.Contains(mH)||t1.CustomData.Contains(mH)))lM.Add(t1);}}else{foreach(var t1 in
                md){if(t1 is IMyTextPanel&amp;&amp;Me.CubeGrid==t1.CubeGrid){if(mH!=null&amp;&amp;(t1.CustomName.Contains(mH)||t1.CustomData.Contains(mH)))
                lM.Add(t1 as IMyTextPanel);mc.Add(t1 as IMyTextPanel);}}}return lM;}public List&lt;IMyTerminalBlock&gt;mL&lt;T&gt;(string
                mH=null)where T:class{if(md.Count&lt;1)mD();var lM=new List&lt;IMyTerminalBlock&gt;();for(int e1=0;e1&lt;md.Count;
                e1++){if(md[e1]is T&amp;&amp;Me.CubeGrid==md[e1].CubeGrid&amp;&amp;mH!=null&amp;&amp;(md[e1].CustomName.Contains(mH)||md[e1].CustomData.Contains(mH)))
                {lM.Add(md[e1]);}}return lM;}public List&lt;IMyTerminalBlock&gt;mM&lt;T&gt;(string mH=null)where T:class{if(md.Count
                &lt;1)mD();var lM=new List&lt;IMyTerminalBlock&gt;();for(int e1=0;e1&lt;md.Count;e1++){if(md[e1]is T&amp;&amp;mH!=null&amp;&amp;
                md[e1].CustomName==mH){lM.Add(md[e1]);}}return lM;}IMyTerminalBlock mN=null;string DefaultOrientationBlockInit()
                {string sInitResults="";var centerSearch=new List&lt;IMyTerminalBlock&gt;();mG&lt;IMyTerminalBlock&gt;(ref centerSearch,
                lX);if(centerSearch.Count==0){centerSearch=mI&lt;IMyRemoteControl&gt;(lW);if(centerSearch.Count==0){mG&lt;IMyRemoteControl&gt;(ref
                centerSearch);if(centerSearch.Count==0){mG&lt;IMyCockpit&gt;(ref centerSearch);int i=0;for(;i&lt;centerSearch.Count;
                i++){Echo("Checking Controller:"+centerSearch[i].CustomName);if(centerSearch[i]is IMyCryoChamber)continue;
                break;}if(i&gt;=centerSearch.Count){sInitResults+="!!NO valid Controller";Echo("No Controller found");}
                else{sInitResults+="S";Echo("Using good ship Controller: "+centerSearch[i].CustomName);}}else{sInitResults
                +="R";Echo("Using First Remote control found: "+centerSearch[0].CustomName);}}}else{sInitResults+="N";
                Echo("Using Named: "+centerSearch[0].CustomName);}if(centerSearch.Count&gt;0)mN=centerSearch[0];return sInitResults;
                }string mQ="!NAV";void mR(nr u){u.nS(lY,"GyroIgnore",ref mQ,true);u.nS(lY,"LIMIT_GYROS",ref mT,true);
                u.nS(lY,"LEAVE_GYROS",ref mU,true);}double mS=0.9;int mT=3;int mU=-1;IMyShipController mV;List&lt;IMyGyro&gt;
                mW;float mX=0.01f;bool mY(string mZ){if(mV==null)nn();if(mV is IMyShipController){Vector3D na=(mV as
                IMyShipController).GetNaturalGravity();return mY(mZ,na,mN);}else{Echo("No Controller for gravity");}
                return true;}bool mY(string mZ,Vector3D nb,IMyTerminalBlock nc){bool nd=true;if(mV==null)nn();Matrix
                or;nc.Orientation.GetMatrix(out or);Vector3D ne;mZ=mZ.ToLower();if(mZ.Contains("rocket"))ne=or.Backward;
                else if(mZ.Contains("up"))ne=or.Up;else if(mZ.Contains("backward"))ne=or.Backward;else if(mZ.Contains("forward"))
                ne=or.Forward;else ne=or.Down;nb.Normalize();for(int i=0;i&lt;mW.Count;++i){var g=mW[i];g.Orientation.GetMatrix(out
                or);var nf=Vector3D.Transform(ne,MatrixD.Transpose(or));var ng=Vector3D.Transform(nb,MatrixD.Transpose(g.WorldMatrix.GetOrientation()));
                var nh=Vector3D.Cross(nf,ng);double ni=Vector3D.Dot(nf,ng);double nj=nh.Length();nj=Math.Atan2(nj,Math.Sqrt(Math.Max(0.0,
                1.0-nj*nj)));if(ni&lt;0)nj=Math.PI-nj;if(nj&lt;mX){g.GyroOverride=false;continue;}float nk=g.GetMaximum&lt;float&gt;("Yaw");
                double nl=nk*(nj/Math.PI)*mS;nl=Math.Min(nk,nl);nl=Math.Max(0.01,nl);nh.Normalize();nh*=nl;float cd=
                -(float)nh.X;g.Pitch=cd;float ce=-(float)nh.Y;g.Yaw=ce;float nm=-(float)nh.Z;g.Roll=nm;g.GyroOverride
                =true;nd=false;}return nd;}string nn(){string s="";var l=new List&lt;IMyTerminalBlock&gt;();mV=mN as IMyShipController;
                if(mV==null){if(l.Count&lt;1)return"No RC!";}nq();GridTerminalSystem.GetBlocksOfType&lt;IMyGyro&gt;(l,x=&gt;x.CubeGrid
                ==mN.CubeGrid);var l2=new List&lt;IMyTerminalBlock&gt;();int no=0;for(int i=0;i&lt;l.Count;i++){if(l[i].CustomName.Contains(mQ)
                ||l[i].CustomData.Contains(mQ)){no++;continue;}l2.Add(l[i]);}mW=l2.ConvertAll(x=&gt;(IMyGyro)x);if(mT&gt;0)
                {if(mW.Count&gt;mT){mW.RemoveRange(mT,mW.Count-mT);}else{if((mU-no)&gt;0){int np=mW.Count-(mU-no);mW.RemoveRange(np,
                (mU-no));}}}nq();s+="GYRO#"+mW.Count.ToString("00")+"#";return s;}void nq(){if(mW!=null){for(int i=0;
                i&lt;mW.Count;++i){mW[i].GyroOverride=false;mW[i].Enabled=true;}}}public class nr{Dictionary&lt;string,string&gt;
                ns;Dictionary&lt;string,string[]&gt;nt;Dictionary&lt;string,Dictionary&lt;string,string&gt;&gt;nu;char nv='[';char nw=
                ']';string nx="";MyGridProgram cy;string ny="";static string[]nz={"true","yes","on","1"};const StringComparison
                nA=StringComparison.OrdinalIgnoreCase;const char nB='=';public bool nC{get;private set;}=false;public
                nr(MyGridProgram pg,string id){cy=pg;ns=new Dictionary&lt;string,string&gt;();nt=new Dictionary&lt;string,string[]&gt;();
                nu=new Dictionary&lt;string,Dictionary&lt;string,string&gt;&gt;();nD(id);}public int nD(string id){id.TrimEnd();
                if(ny==id){return ns.Count;}ns.Clear();nt.Clear();nu.Clear();nx="";nC=false;ny=id;string[]nE=id.Split('\n');
                for(int H=0;H&lt;nE.Count();H++){string nF="";nE[H].Trim();if(nE[H].StartsWith(nv.ToString())){string cs
                ="";for(int nG=1;nG&lt;nE[H].Length;nG++)if(nE[H][nG]==nw)break;else cs+=nE[H][nG];if(cs!=""){nF=cs.ToUpper();
                }else continue;H++;string nH="";var nI=new string[nE.Count()-H];int nJ=0;var nK=new Dictionary&lt;string,
                string&gt;();for(;H&lt;nE.Count();H++){nE[H].Trim();if(nE[H].StartsWith(nv.ToString())){H--;break;}nH+=nE[H]
                +"\n";nI[nJ++]=nE[H];if(nE[H].Contains(nB)){string[]nL=nE[H].Split('=');if(nL.Count()&gt;1){string nM=nL[0];
                string nN="";for(int i1=1;i1&lt;nL.Count();i1++){nN+=nL[i1];if(i1+1&lt;nL.Count())nN+=nB;}nK.Add(nM,nN);}}
                }if(!nu.ContainsKey(nF))nu.Add(nF,nK);if(!nt.ContainsKey(nF))nt.Add(nF,nI);if(!ns.ContainsKey(nF))ns.Add(nF,
                nH);}else{nx+=nE[H]+"\n";}}return ns.Count;}public string nO(string nP){string nH="";if(ns.ContainsKey(nP))
                nH=ns[nP];return nH;}public string[]nQ(string nP){string[]nR={""};if(nt.ContainsKey(nP))nR=nt[nP];return
                nR;}public bool nS(string nP,string nM,ref string nT,bool nU=false){nP=nP.ToUpper();if(nu.ContainsKey(nP))
                {var nV=nu[nP];if(nV.ContainsKey(nM)){nT=nV[nM];return true;}}if(nU)of(nP,nM,nT);return false;}public
                bool nS(string nP,string nM,ref long nW,bool nU=false){string nX="";if(!nS(nP,nM,ref nX)){if(nU){of(nP,
                nM,nW);}return false;}nW=Convert.ToInt64(nX);return true;}public bool nS(string nP,string nM,ref int
                nY,bool nU=false){string nX="";if(!nS(nP,nM,ref nX)){if(nU){of(nP,nM,nY);}return false;}nY=Convert.ToInt32(nX);
                return true;}public bool nS(string nP,string nM,ref double nZ,bool nU=false){string nX="";if(!nS(nP,
                nM,ref nX)){if(nU){of(nP,nM,nZ);}return false;}bool oa=double.TryParse(nX,out nZ);return true;}public
                bool nS(string nP,string nM,ref float ob,bool nU=false){string nX="";if(!nS(nP,nM,ref nX)){if(nU){of(nP,
                nM,ob.ToString());}return false;}bool oa=float.TryParse(nX,out ob);return true;}public bool nS(string
                nP,string nM,ref DateTime oc,bool nU=false){string nX="";if(!nS(nP,nM,ref nX)){if(nU){of(nP,nM,oc);}
                return false;}oc=DateTime.Parse(nX);return true;}public bool nS(string nP,string nM,ref Vector3D od,
                bool nU=false){string nX="";if(!nS(nP,nM,ref nX)){if(nU){of(nP,nM,od);}return false;}double x1,y1,z1;
                @is(nX,out x1,out y1,out z1);od.X=x1;od.Y=y1;od.Z=z1;return true;}public bool nS(string nP,string nM,
                ref bool oe,bool nU=false){string nX="";if(!nS(nP,nM,ref nX)){if(nU){of(nP,nM,oe);}return false;}oe=
                nz.Any(c=&gt;string.Equals(nX,c,nA));return true;}public bool of(string section,string key,string nX){if
                (ns.ContainsKey(section)){ns[section]="";}else{ns.Add(section,"");nC=true;}if(nu.ContainsKey(section))
                {var nK=new Dictionary&lt;string,string&gt;();var nV=nu[section];if(nV.ContainsKey(key)){if(nV[key]==nX)return
                false;nV[key]=nX;}else{nV.Add(key,nX);}nC=true;}else{var nK=new Dictionary&lt;string,string&gt;();nK.Add(key,
                nX);nu.Add(section,nK);nC=true;}return true;}public bool of(string nP,string nM,Vector3D od){of(nP,nM,
                ir(od));return true;}public bool of(string nP,string nM,bool oe){of(nP,nM,oe.ToString());return true;
                }public bool of(string nP,string nM,int og){of(nP,nM,og.ToString());return true;}public bool of(string
                nP,string nM,long oh){of(nP,nM,oh.ToString());return true;}public bool of(string nP,string nM,DateTime
                oc){of(nP,nM,oc.ToString());return true;}public bool of(string nP,string nM,float ob){of(nP,nM,ob.ToString());
                return true;}public bool of(string nP,string nM,double nZ){of(nP,nM,nZ.ToString());return true;}public
                void oi(string nP,string nH){nH.TrimEnd();nP=nP.ToUpper();if(ns.ContainsKey(nP)){if(ns[nP]!=nH){ns[nP]
                =nH;nC=true;}}else{nC=true;ns.Add(nP,nH);}}public string oj(bool ok=true){string ol="";string s1=nx.Trim();
                if(s1!="")ol=s1+"\n";foreach(var kv in ns){ol+=nv+kv.Key.Trim()+nw+"\n";if(kv.Value.TrimEnd()==""){string
                om="";if(nu.ContainsKey(kv.Key)){foreach(var dk in nu[kv.Key]){om+=dk.Key+nB+dk.Value+"\n";}}om+="\n";
                ol+=om;}else{ol+=kv.Value.Trim()+"\n\n";}}if(ok){nC=false;ny=ol;}return ol;}bool@is(string it,out double
                x,out double y,out double z){string[]iu=it.Trim().Split(',');if(iu.Length&lt;3){iu=it.Trim().Split(':');
                }x=0;y=0;z=0;if(iu.Length&lt;3)return false;bool iv=double.TryParse(iu[0].Trim(),out x);bool iw=double.TryParse(iu[1].Trim(),
                out y);bool ix=double.TryParse(iu[2].Trim(),out z);if(!iv||!iw||!ix){return false;}return true;}string
                ir(Vector3D v){string s;s=v.X.ToString("0.00")+":"+v.Y.ToString("0.00")+":"+v.Z.ToString("0.00");return
                s;}}int on=80;int oo=20;double op=0;string sPowerSection="POWER";void or(nr iNIHolder){iNIHolder.nS(sPowerSection,
                "batterypcthigh",ref on,true);iNIHolder.nS(sPowerSection,"batterypctlow",ref oo,true);}void os(){op=
                0;Echo("Init Reactors");hW();Echo("Init Solar");iB();Echo("Init Batteries");bu();if(hU&gt;0)op+=hU;if(bm
                &gt;0)op+=bm;}List&lt;IMyTerminalBlock&gt;ot=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;ou=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;ov=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;ow=new List&lt;IMyTerminalBlock&gt;();
                string ox(IMyTerminalBlock cm){ot.Clear();ou.Clear();ov.Clear();ow.Clear();mG&lt;IMyMotorSuspension&gt;(ref
                ot);for(int i=0;i&lt;ot.Count;i++){if(ot[i].CustomName.Contains("[SLED]")||ot[i].CustomData.Contains("[SLED]"))
                {ou.Add(ot[i]);if(ot[i].CustomName.Contains("[REAR]")||ot[i].CustomData.Contains("[FRONT]")){ov.Add(ot[i]);
                }if(ot[i].CustomName.Contains("[FRONT]")||ot[i].CustomData.Contains("[FRONT]")){ow.Add(ot[i]);}}}return
                "W"+ot.Count.ToString("0")+"WS"+ou.Count.ToString("0")+"SR"+ov.Count.ToString("0")+"SF"+ow.Count.ToString("0");
                }bool oy(){if(ou.Count&gt;0)return true;return false;}void oz(){for(int i1=0;i1&lt;ou.Count;i1++){var w1=ou[i1]
                as IMyMotorSuspension;w1.SetValueFloat("Friction",0);}}
              </Program>
              <Storage />
              <DefaultRunArgument>idle</DefaultRunArgument>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="3" y="6" z="-2" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="5" z="5" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="5" z="5" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="5" z="5" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockLargeAtmosphericThrust</SubtypeName>
              <EntityId>132486606629600172</EntityId>
              <Min x="-1" y="3" z="6" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Large Atmospheric Thruster</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-2" y="5" z="7" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="5" z="9" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="2" y="5" z="7" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="-2" y="4" z="-2" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="2" y="6" z="-2" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_BatteryBlock">
              <SubtypeName>SmallBlockBatteryBlock</SubtypeName>
              <EntityId>78061830895560795</EntityId>
              <Min x="-3" y="4" z="0" />
              <BlockOrientation Forward="Forward" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Battery 2</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <CurrentStoredPower>1.08</CurrentStoredPower>
              <ProducerEnabled>true</ProducerEnabled>
              <MaxStoredPower>0</MaxStoredPower>
              <SemiautoEnabled>false</SemiautoEnabled>
              <OnlyDischargeEnabled>false</OnlyDischargeEnabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_TimerBlock">
              <SubtypeName>TimerBlockSmall</SubtypeName>
              <EntityId>109917181126772951</EntityId>
              <Min x="0" y="5" z="-2" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyModStorageComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_ModStorageComponent">
                      <Storage>
                        <dictionary>
                          <item>
                            <Key>74de02b3-27f9-4960-b1c4-27351f2b06d1</Key>
                            <Value />
                          </item>
                        </dictionary>
                      </Storage>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Timer Block [WCCS]</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Toolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots>
                  <Slot>
                    <Index>0</Index>
                    <Item />
                    <Data xsi:type="MyObjectBuilder_ToolbarItemTerminalBlock">
                      <Action>Run</Action>
                      <Parameters>
                        <MyObjectBuilder_ToolbarItemActionParameter>
                          <TypeCode>String</TypeCode>
                          <Value>wccs</Value>
                        </MyObjectBuilder_ToolbarItemActionParameter>
                      </Parameters>
                      <BlockEntityId>136784861028087692</BlockEntityId>
                    </Data>
                  </Slot>
                </Slots>
              </Toolbar>
              <Delay>10000</Delay>
              <CurrentTime>0</CurrentTime>
              <IsCountingDown>false</IsCountingDown>
              <Silent>false</Silent>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_BatteryBlock">
              <SubtypeName>SmallBlockBatteryBlock</SubtypeName>
              <EntityId>142114225999408195</EntityId>
              <Min x="2" y="4" z="0" />
              <BlockOrientation Forward="Forward" Up="Right" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Battery 3</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <CurrentStoredPower>1.08</CurrentStoredPower>
              <ProducerEnabled>true</ProducerEnabled>
              <MaxStoredPower>0</MaxStoredPower>
              <SemiautoEnabled>false</SemiautoEnabled>
              <OnlyDischargeEnabled>false</OnlyDischargeEnabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="4" z="-3" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="4" z="-2" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-3" y="5" z="-2" />
              <BlockOrientation Forward="Right" Up="Backward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="3" y="5" z="-2" />
              <BlockOrientation Forward="Left" Up="Backward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="5" z="6" />
              <BlockOrientation Forward="Backward" Up="Right" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="5" z="8" />
              <BlockOrientation Forward="Forward" Up="Right" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="2" y="5" z="5" />
              <BlockOrientation Forward="Backward" Up="Right" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="5" z="-2" />
              <BlockOrientation Forward="Right" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="2" y="5" z="9" />
              <BlockOrientation Forward="Forward" Up="Right" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="5" z="9" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="5" z="6" />
              <BlockOrientation Forward="Backward" Up="Left" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-2" y="5" z="5" />
              <BlockOrientation Forward="Backward" Up="Left" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="5" z="8" />
              <BlockOrientation Forward="Forward" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-2" y="5" z="9" />
              <BlockOrientation Forward="Forward" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="5" z="9" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="6" z="-3" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>87449474124098569</EntityId>
              <Min x="-3" y="5" z="6" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Atmospheric Thrusters B</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>94121480975838617</EntityId>
              <Min x="3" y="5" z="6" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Atmospheric Thrusters A</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="5" z="-2" />
              <BlockOrientation Forward="Left" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="6" z="-3" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="-3" y="6" z="-2" />
              <BlockOrientation Forward="Right" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_MyProgrammableBlock">
              <SubtypeName>SmallProgrammableBlock</SubtypeName>
              <EntityId>136784861028087692</EntityId>
              <Min x="1" y="5" z="-2" />
              <BlockOrientation Forward="Left" Up="Backward" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyModStorageComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_ModStorageComponent">
                      <Storage>
                        <dictionary>
                          <item>
                            <Key>74de02b3-27f9-4960-b1c4-27351f2b06d1</Key>
                            <Value>
                              [WORLD]
                              MaxWorldMps=100

                              [GRIDS]
                              NoFollow=NOFOLLOW
                              BlockIgnore=!WCC
                              OrientationBlockContains=[NAV]
                              OrientationBlockNamed=Craft Remote Control
                              GyroIgnore=!NAV
                              LIMIT_GYROS=3
                              LEAVE_GYROS=-1
                              CTRL_COEFF=0.3

                              [LOGGING]
                              TextPanelReport=Craft Report
                              StatusName=Wico Craft Status
                              LongStatus=Wico Craft Log
                              RangeReport=[RANGE]
                              SledReport=[SMREPORT]
                              GPSTag=[GPS]

                              [CONNECTORS]
                              BaseConnector=[BASE]
                              DockConnector=[DOCK]

                              [CAMERAS]
                              CameraViewOnly=[VIEW]

                              [NAV]
                              DTMDebug=False
                              CameraCollision=False
                              SensorCollision=False
                              NAVEmulateOld=True
                              NAVGravityMinElevation=25
                              NavBeaconDebug=False

                              [WICO CRAFT]
                              EchoOn=True

                            </Value>
                          </item>
                        </dictionary>
                      </Storage>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>PB Wico Craft NAV</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Program>
                /* Wico Craft NAV Control sub-module
                *
                * Commands:
                * XXX
                *
                *
                *
                * Handles MODES:
                * MODE_DOCKED
                * MODE_LAUNCH
                * MODE_RELAUNCH
                * MODE_SLEDMOVE
                * MODE_ARRIVEDTARGET
                *
                *
                *
                * 2.0.4 Upate to new save format
                *  .04A Camera Scans for Obstacles...!!!one
                *
                *  2.1 Use new blockInint and localgrids
                *
                *  .1g Add Docked
                *  copy from SLED PATROL
                *  .1h fixed yaw only gyromain
                *  .1i tested in space. Added !NAV to gyro check
                *  .1j add doroll
                *  .1k use (and fix/test) IMyGyroControl
                2.2: Update for 1.72

                2.9 Copy from Sled Dock 2.2

                Needs LOTS of updates.

                3.0 Move code into 3.0

                3.0A Start NAV processing: W and O
                3.0B Add D, S, C
                3.0C Add arrivedtarget

                3.0D 110517  search order for text panels

                3.1 Version for PB Updates SE 1.185
                o Added support for GPS-formatted nav locations
                Ex:  W GPS:Wicorel #1:53970.01:128270.31:-123354.92:

                3.1a
                remove blockApplyActions() and make routines for each block type that needs it

                3.2 Collision Avoidance from Docking module for thruster travel

                Added Rotors

                3.2A travelmovement calculating target speeds and distances with more precision

                3.2B Sled Testing

                3.2C INI Save
                fix bug in serialize wrting z,y z, instead of x,y,z (oops)

                3.2D INI WCCM 01062018

                3.2E Major INI settings

                3.3 Lists of text panels
                Only output to textpanels and end of run

                3.3A Redo Serialize

                3.4 Sled testing
                (EFM Update 8 Drones)

                3.4a Save NAV settings so nav can properly resume
                (EFM Update 9 Drones)

                3.4B

                3.4C AvionicsGyro fixes (terminal properties changed units)
                Fix for bug in SE wheel setter for friction
                Add Gyro limits to CustomData
                (EFM Update 11 wheeled Drones)

                3.4D Air unit NAV changes
                terrain auto-follow
                alignment in gravity
                (EFM Update 11 Air unit drones)

                * TODO:
                */

                string a="Wico Craft";string b="NAV";string c="3.4D";const string d="0.00";void e(oo f){gt(f);}void g(oo
                f){gs(f);}void h(){}void i(){iR();}void j(bool k=false){ka(iT);on();gJ(gy);gJ(gz);if(nO is IMyRemoteControl)
                ((IMyRemoteControl)nO).SetAutoPilotEnabled(false);if(nO is IMyShipController)((IMyShipController)nO).DampenersOverride
                =true;}m l=new m();class m{public const Base6Directions.Direction n=Base6Directions.Direction.Forward;
                public const Base6Directions.Direction o=Base6Directions.Direction.Backward;public const Base6Directions.Direction
                p=Base6Directions.Direction.Left;public const Base6Directions.Direction q=Base6Directions.Direction.Right;
                public const Base6Directions.Direction Up=Base6Directions.Direction.Up;public const Base6Directions.Direction
                r=Base6Directions.Direction.Down;public float s=30.0f;public List&lt;IMyGyro&gt;t=new List&lt;IMyGyro&gt;();Base6Directions.Direction
                u=Up;Base6Directions.Direction v=p;Base6Directions.Direction w=n;Base6Directions.Direction x=Up;Base6Directions.Direction
                y=p;Base6Directions.Direction z=n;public void A(List&lt;IMyTerminalBlock&gt;B){t=B.ConvertAll(x=&gt;(IMyGyro)x);
                if(t.Count&gt;0)s=t[0].GetMaximum&lt;float&gt;("Yaw");}public void A(List&lt;IMyGyro&gt;B){t.Clear();if(B==null)return;
                t=B;if(t.Count&gt;0)s=t[0].GetMaximum&lt;float&gt;("Yaw");}public void A(IMyProgrammableBlock PB,IMyGridTerminalSystem
                C){t.Clear();if((C!=null)&amp;&amp;(PB!=null))C.GetBlocksOfType&lt;IMyGyro&gt;(t,x=&gt;((x.CubeGrid==PB.CubeGrid)&amp;&amp;x.IsFunctional));
                if(t.Count&gt;0)s=t[0].GetMaximum&lt;float&gt;("Yaw");}public void D(IMyTerminalBlock E,Base6Directions.Direction
                F=n,Base6Directions.Direction G=Up){if(Base6Directions.GetAxis(F)==Base6Directions.GetAxis(G))G=Base6Directions.GetPerpendicular(F);
                if(E==null){}else{Vector3 H=Base6Directions.GetVector(F);Vector3.TransformNormal(ref H,E.Orientation,
                out H);F=Base6Directions.GetDirection(ref H);H=Base6Directions.GetVector(G);Vector3.TransformNormal(ref
                H,E.Orientation,out H);G=Base6Directions.GetDirection(ref H);}x=G;z=F;y=Base6Directions.GetLeft(x,z);
                }public void I(bool J){for(int i=0;i&lt;t.Count;i++){t[i].GyroOverride=J;}}public void I(int K,bool J){
                if(K&lt;t.Count){t[K].GyroOverride=J;}}public void L(float M){for(int i=0;i&lt;t.Count;i++){t[i].GyroPower
                =M;}}public void L(int K,float M){if(K&lt;t.Count){t[K].GyroPower=M;}}public void N(bool O){for(int i=0;
                i&lt;t.Count;i++){t[i].Enabled=O;}}public void N(int K,bool O){if(K&lt;t.Count){t[K].Enabled=O;}}public void
                P(bool Q){for(int i=0;i&lt;t.Count;i++){t[i].ShowOnHUD=Q;}}public void P(int K,bool Q){if(K&lt;t.Count){t[K].ShowOnHUD
                =Q;}}void R(Base6Directions.Direction S,out string T,out float U){T="Yaw";U=-1.0f;if(Base6Directions.GetAxis(u)
                ==Base6Directions.GetAxis(S)){if(u==S)U=1.0f;}if(Base6Directions.GetAxis(v)==Base6Directions.GetAxis(S))
                {T="Pitch";if(v==S)U=1.0f;}if(Base6Directions.GetAxis(w)==Base6Directions.GetAxis(S)){T="Roll";if(w==
                S){}else U=1.0f;}}public void V(IMyGyro K,string T,float J){if(T=="Yaw"){K.Yaw=J;}else if(T=="Pitch")
                {K.Pitch=J;}else{K.Roll=J;}}public void W(float X){for(int i=0;i&lt;t.Count;i++){string T;float U;Vector3
                H=Base6Directions.GetVector(Up);Vector3.TransformNormal(ref H,t[i].Orientation,out H);u=Base6Directions.GetDirection(ref
                H);R(x,out T,out U);V(t[i],T,U*X);}}public void Y(float Z){for(int i=0;i&lt;t.Count;i++){string T;float
                U;Vector3 H=Base6Directions.GetVector(p);Vector3.TransformNormal(ref H,t[i].Orientation,out H);v=Base6Directions.GetDirection(ref
                H);R(y,out T,out U);V(t[i],T,U*Z);}}public void ba(float bb){for(int i=0;i&lt;t.Count;i++){string T;float
                U;Vector3 H=Base6Directions.GetVector(n);Vector3.TransformNormal(ref H,t[i].Orientation,out H);w=Base6Directions.GetDirection(ref
                H);R(z,out T,out U);V(t[i],T,U*bb);}}public void bc(float X,float Z,float bb){for(int i=0;i&lt;t.Count;
                i++){string T;float U;Vector3 H=Base6Directions.GetVector(n);Vector3.TransformNormal(ref H,t[i].Orientation,
                out H);w=Base6Directions.GetDirection(ref H);H=Base6Directions.GetVector(p);Vector3.TransformNormal(ref
                H,t[i].Orientation,out H);v=Base6Directions.GetDirection(ref H);H=Base6Directions.GetVector(Up);Vector3.TransformNormal(ref
                H,t[i].Orientation,out H);u=Base6Directions.GetDirection(ref H);R(x,out T,out U);V(t[i],T,U*X);R(y,out
                T,out U);V(t[i],T,U*Z);R(z,out T,out U);V(t[i],T,U*bb);}}}double bd(Vector3D be,IMyTerminalBlock bf)
                {double bg=0;bool bh=false;MatrixD bi=by(bf);Vector3D bj=bf.GetPosition();Vector3D bk=bj+1.0*Vector3D.Normalize(bi.Backward);
                Vector3D bl=bj+1.0*Vector3D.Normalize(bi.Right);Vector3D bm=bj-1.0*Vector3D.Normalize(bi.Right);double
                bn=bs(bl,be);double bo=bs(bm,be);double bp=bs(bl,bm);double bq=Vector3D.DistanceSquared(bj,be);double
                br=Vector3D.DistanceSquared(bk,be);bh=bq&lt;br;bg=(bo-bn)/bp;Echo("calc Angle="+Math.Round(bg,5));if(!bh)
                {bg+=(bg&lt;0)?-1:1;}return bg;}double bs(Vector3D a,Vector3D b){return Vector3D.Distance(a,b);}MatrixD
                bt(IMyCubeGrid bu){Vector3D bv=bu.GridIntegerToWorld(new Vector3I(0,0,0));Vector3D bw=bu.GridIntegerToWorld(new
                Vector3I(0,1,0))-bv;Vector3D bx=bu.GridIntegerToWorld(new Vector3I(0,0,1))-bv;return MatrixD.CreateScale(bu.GridSize)
                *MatrixD.CreateWorld(bv,-bx,bw);}MatrixD by(IMyCubeBlock blk){Matrix bA;blk.Orientation.GetMatrix(out
                bA);return bA*MatrixD.CreateTranslation(((Vector3D)new Vector3D(blk.Min+blk.Max))/2.0)*bt(blk.CubeGrid);
                }bool bB(double bC,string bD="Roll",float bE=-1,float bF=1f){float bG=0;IMyGyro K=nX[0]as IMyGyro;float
                bH=K.GetMaximum&lt;float&gt;(bD);if(bE&gt;0)bH=bE;if(Math.Abs(bC)&gt;1.0){bG=bH*(float)(bC)*bF;}else if(Math.Abs(bC)
                &gt;.7){bG=bH*(float)(bC)/4;}else if(Math.Abs(bC)&gt;0.5){bG=0.11f*Math.Sign(bC);}else if(Math.Abs(bC)&gt;0.1)
                {bG=0.11f*Math.Sign(bC);}else if(Math.Abs(bC)&gt;0.01){bG=0.11f*Math.Sign(bC);}else if(Math.Abs(bC)&gt;0.001)
                {bG=0.09f*Math.Sign(bC);}else bG=0;l.W(bG);if(Math.Abs(bC)&lt;nY){l.I(false);}else{l.I(true);l.N(true);
                return false;}return true;}void bI(List&lt;IMyTerminalBlock&gt;bJ,bool bK=true){foreach(var b in bJ){IMyFunctionalBlock
                f=b as IMyFunctionalBlock;if(f==null)continue;f.Enabled=bK;}}void bL(List&lt;IMyTerminalBlock&gt;bJ){foreach
                (var b in bJ){IMyFunctionalBlock f=b as IMyFunctionalBlock;if(f==null)continue;f.Enabled=!f.Enabled;
                }}string bM="[VIEW]";Matrix bN=new Matrix(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);List&lt;IMyTerminalBlock&gt;bO=
                new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;bP=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                bQ=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;bR=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                bS=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;bT=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                bU=new List&lt;IMyTerminalBlock&gt;();IMyTerminalBlock bV=null;private MyDetectedEntityInfo bW;string bX="CAMERAS";
                void bY(oo f){f.oP(bX,"CameraViewOnly",ref bM,true);}bool bZ(List&lt;IMyTerminalBlock&gt;ca,double cb=100,
                float Z=0,float X=0){double cc=0;bV=null;for(int i=0;i&lt;ca.Count;i++){double cd=((IMyCameraBlock)ca[i]).AvailableScanRange;
                if(cd&gt;cc){cc=cd;bV=ca[i];}}var ce=bV as IMyCameraBlock;if(bV==null){return false;}if(ce.CanScan(cb))
                {bW=ce.Raycast(cb,Z,X);bV=ce;if(!bW.IsEmpty())dt(bW);return true;}else{}return false;}bool bZ(List&lt;IMyTerminalBlock&gt;
                ca,Vector3D cf){double cc=0;bV=null;for(int i=0;i&lt;ca.Count;i++){double cd=((IMyCameraBlock)ca[i]).AvailableScanRange;
                if(cd&gt;cc){cc=cd;bV=ca[i];}}var ce=bV as IMyCameraBlock;if(bV==null)return false;{bW=ce.Raycast(cf);bV
                =ce;if(!bW.IsEmpty())dt(bW);return true;}}double cg(List&lt;IMyTerminalBlock&gt;ca){double ch=0;for(int i=
                0;i&lt;ca.Count;i++){IMyCameraBlock ce=ca[i]as IMyCameraBlock;if(ch&lt;ce.AvailableScanRange)ch=ce.AvailableScanRange;
                }return ch;}string ci(IMyTerminalBlock cj){bO.Clear();bP.Clear();bQ.Clear();bR.Clear();bS.Clear();bT.Clear();
                bU.Clear();if(cj==null)return"\nCameras:No OrientationBlock";GridTerminalSystem.GetBlocksOfType&lt;IMyCameraBlock&gt;(bU,
                (x1=&gt;x1.CubeGrid==Me.CubeGrid));Matrix ck;cj.Orientation.GetMatrix(out ck);Matrix.Transpose(ref ck,out
                ck);for(int i=0;i&lt;bU.Count;++i){if(bU[i].CustomName.Contains(bM))continue;IMyCameraBlock ce=bU[i]as IMyCameraBlock;
                ce.EnableRaycast=true;Matrix cl;ce.Orientation.GetMatrix(out cl);Vector3 cm=Vector3.Transform(cl.Forward,
                ck);if(cm==bN.Left){bS.Add(bU[i]);}else if(cm==bN.Right){bT.Add(bU[i]);}else if(cm==bN.Backward){bP.Add(bU[i]);
                }else if(cm==bN.Forward){bO.Add(bU[i]);}else if(cm==bN.Up){bR.Add(bU[i]);}else if(cm==bN.Down){bQ.Add(bU[i]);
                }}string s;s="CS:&lt;";s+="F"+bO.Count.ToString("00");s+="B"+bP.Count.ToString("00");s+="D"+bQ.Count.ToString("00");
                s+="U"+bR.Count.ToString("00");s+="L"+bS.Count.ToString("00");s+="R"+bT.Count.ToString("00");s+="&gt;";
                return s;}void cn(List&lt;IMyTerminalBlock&gt;ca,string co){string cp;for(int i=0;i&lt;ca.Count;i++){if(!ca[i].CustomName.Contains(co))
                {cp="Camera ";if(ca.Count&gt;1)cp+=(i+1).ToString()+" ";cp+=co;ca[i].CustomName=cp;}}}List&lt;IMyTerminalBlock&gt;
                cq=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;cr=new List&lt;IMyTerminalBlock&gt;();string cs(IMyTerminalBlock
                cj){string s="";if(bU.Count&lt;1)s+=ci(cj);cq.Clear();cr.Clear();foreach(var camera in bQ){if(camera.CustomName.ToLower().Contains("fore")
                ||camera.CustomData.ToLower().Contains("fore"))cq.Add(camera);else if(camera.CustomName.ToLower().Contains("aft")
                ||camera.CustomData.ToLower().Contains("aft"))cr.Add(camera);}s+="HCS:&lt;";s+="F"+cq.Count.ToString("00");
                s+="A"+cr.Count.ToString("00");s+="&gt;";return s;}public class ct{bool cu=false;Program cv;public double
                cw=1250;double cx=5000;float cy=25f;float cz=25f;double cA=5;float cB=3;float cC=0.5f;float cD=0;float
                cE=0;float cF=0;float cG=0;List&lt;IMyTerminalBlock&gt;cH=new List&lt;IMyTerminalBlock&gt;();private int cI=0;private
                int cJ=1;public MyDetectedEntityInfo bW;public List&lt;MyDetectedEntityInfo&gt;cK=new List&lt;MyDetectedEntityInfo&gt;();
                public IMyTerminalBlock bV=null;public ct(Program pg,List&lt;IMyTerminalBlock&gt;bJ,double cL=1250,float cM
                =45f,float cN=45f,float cO=2,float cP=1,float cQ=0.5f,double cR=5000){cv=pg;cu=false;cH.Clear();cK.Clear();
                bW=new MyDetectedEntityInfo();foreach(var b in bJ){if(b is IMyCameraBlock){cH.Add(b);IMyCameraBlock c
                =b as IMyCameraBlock;c.EnableRaycast=true;if(cy&gt;c.RaycastConeLimit)cy=c.RaycastConeLimit;if(cz&gt;c.RaycastConeLimit)
                cz=c.RaycastConeLimit;}}if(cL&gt;cR)cR=cL;cw=cL;cy=cM;cz=cN;cA=cO;cB=cP;cC=cQ;cx=cR;cD=0;cE=0;cF=0;cG=0;
                cI=0;cJ=cH.Count;}public bool cS(){return cu;}void cT(MyDetectedEntityInfo bW){bool cU=true;for(int i
                =0;i&lt;cK.Count;i++){if(cK[i].EntityId==bW.EntityId)cU=false;}if(cU){cK.Add(bW);}}public bool cV(){if(cH.Count
                &lt;1)cu=true;if(cu)return false;bool cW=false;for(int cX=0;cX&lt;cJ;cX++){if(cv.bZ(cH,cw,cG,cF)){bW=cv.bW;
                if(!bW.IsEmpty()){bool cY=true;if((bW.Type==MyDetectedEntityType.LargeGrid)||(bW.Type==MyDetectedEntityType.SmallGrid))
                {if(cv.nA(bW.EntityId)){cY=false;}}if(cY){cv.fh+="\nDoScan HIT!";cT(bW);cW=true;}}cI++;if(cG==0&amp;&amp;cF==
                0){cD=cC;cE=cC;cI=0;}if(cI&gt;3){cI=0;cE+=Math.Abs(cE/cB)+cC;if(Math.Abs(cE)&gt;cy){cI=0;cE=0;cD+=Math.Abs(cD
                /cB)+cC;}if(Math.Abs(cD)&gt;cz){cD=0;cE=0;cI=0;{cw*=cA;if(cw&gt;cx){cu=true;return false;}}}}switch(cI){case
                0:cG=cD;cF=cE;break;case 1:cG=-cD;cF=cE;break;case 2:cG=cD;cF=-cE;break;case 3:cG=-cD;cF=-cE;break;}
                }}return cW;}}const int cZ=0;const int da=2;const int db=4;const int dc=32;const int dd=64;const int
                de=128;const int df=256;const int dg=512;const int dh=1024;const int di=2048;const int dj=0xfff;string
                dk(){string dl="FLAGS:";if((hR&amp;da)&gt;0)dl+="SLED ";if((hR&amp;dc)&gt;0)dl+="ORBITAL ";if((hR&amp;dd)&gt;0)dl+="ROCKET ";
                if((hR&amp;db)&gt;0)dl+="ROTOR ";if((hR&amp;de)&gt;0)dl+="PET ";if((hR&amp;df)&gt;0)dl+="NAD ";if((hR&amp;dg)&gt;0)dl+="NO Gyro ";
                if((hR&amp;di)&gt;0)dl+="No Tank ";if((hR&amp;dh)&gt;0)dl+="No Power ";return dl;}long dm=0;void dn(){string@do;if
                (SaveFile==null){@do=Storage;}else{@do=SaveFile.GetPublicText();}if(hO==null)return;hO.oA(@do);hO.oP(hL,
                "SaveID",ref dm);if(dp())hO.oA("");e(hO);hO.oP(hL,"Mode",ref fm,true);hO.oP(hL,"current_state",ref current_state,
                true);hO.oP(hL,"PassedArgument",ref sPassedArgument,true);hO.oP(hL,"AlertStates",ref hT,true);hO.oP(hL,
                "craft_operation",ref hR,true);hO.oP(hL,"PassedArgument",ref sPassedArgument);hO.oP(hL,"ReceivedMessage",
                ref hU);}bool dp(){if(SaveFile==null)return false;if(dm==(long)SaveFile.EntityId)return false;else return
                true;}bool dq(string dr){dr=dr.Trim().ToLower();return(dr=="True"||dr=="true");}Dictionary&lt;long,MyDetectedEntityInfo&gt;
                ds=new Dictionary&lt;long,MyDetectedEntityInfo&gt;();void dt(MyDetectedEntityInfo thisDetectedInfo){if(thisDetectedInfo.EntityId
                !=0){if(!ds.ContainsKey(thisDetectedInfo.EntityId)){ds.Add(thisDetectedInfo.EntityId,thisDetectedInfo);
                }else{ds[thisDetectedInfo.EntityId]=thisDetectedInfo;}}else Echo("Not adding: Zero Entity");}string dv(MyDetectedEntityInfo
                dw){string s="";s+="ETBV";s+=":"+dw.EntityId.ToString();s+=":"+dw.TimeStamp;Vector3D dx=dw.BoundingBox.Min;
                s+=":"+hX(dx);Vector3D dy=dw.BoundingBox.Max;s+=":"+hX(dy);Vector3D dz=(Vector3)dw.Velocity;s+=":"+hX(dz);
                return s;}void dA(){Echo("mode="+fm.ToString());if(fm==ft){dG();return;}}void dB(){eD(DateTime.Now.ToString()
                +" ACTION: Reset To Idle",el,true);j();gd(fn);}void dC(){eD(b+" Manual Control",en);}bool dD=true;bool
                dE=false;bool dF=false;void dG(){eD("clear",en);eD(b+":Going Target!",en);eD(b+":GT: current_state="
                +current_state.ToString(),en);Echo("Going Target: state="+current_state.ToString());string dH="";dH+=
                "GT:S="+current_state;if(current_state==0){lc();if((hR&amp;da)&gt;0){dE=true;if(gi&gt;45)gi=45;}else dE=false;
                if((hR&amp;db)&gt;0){dF=true;if(gi&gt;15)gi=15;}else dF=false;l.D(nO);double dI=0;((IMyShipController)nO).TryGetPlanetElevation(MyPlanetElevation.Surface,
                out dI);if(!dE&amp;&amp;!dF){if(go&lt;0)go=75;}if(gg){if(dI&gt;ia.it()){current_state=150;}else current_state=160;
                }else gd(fq);iJ=true;}else if(current_state==150){iJ=true;if(dGravity&gt;0){double dI=0;((IMyShipController)nO).TryGetPlanetElevation(MyPlanetElevation.Surface,
                out dI);dH+=" E="+dI.ToString("0.0");float dJ=nY;nY=0.1f;Vector3D dK=(nO as IMyShipController).GetNaturalGravity();
                bool dL=nZ("",dK,nO);dH+=" Aligned="+dL.ToString();Echo("bAligned="+dL.ToString());nY=dJ;if(dL||dI&lt;ia.it()
                *2){on();if(go&gt;0)current_state=155;else current_state=160;}}else current_state=160;}else if(current_state
                ==151){iJ=true;if(dGravity&gt;0){double dI=0;((IMyShipController)nO).TryGetPlanetElevation(MyPlanetElevation.Surface,
                out dI);dH+=" E="+dI.ToString("0.0");float dJ=nY;nY=0.1f;Vector3D dK=(nO as IMyShipController).GetNaturalGravity();
                bool dL=nZ("",dK,nO);dH+=" Aligned="+dL.ToString();Echo("bAligned="+dL.ToString());nY=dJ;if(dL||dI&lt;ia.it()
                *2){on();if(go&gt;0)current_state=155;else current_state=160;}else current_state=150;}else current_state
                =160;}else if(current_state==155){iJ=true;if(dGravity&gt;0){Vector3D dK=(nO as IMyShipController).GetNaturalGravity();
                bool dL=nZ("",dK,nO);dH+=" Aligned="+dL.ToString();double dM=-999;dM=bd(gf,nO);bool dN=Math.Abs(dM)&lt;
                0.1;Echo("yawangle="+dM.ToString());dH+=" Yaw="+dM.ToString("0.00");if(!dN){if(la){Echo("Rotor");gK(dM);
                }else{bB(dM,"Yaw");}}if(dL&amp;&amp;dN){on();current_state=160;}else if(dL&amp;&amp;Math.Abs(dM)&lt;0.5){float dO;float
                dP;float dQ;jI(iU,out dO,out dP,out dQ);dO+=1;dP+=1;dQ+=1;jW(iU,dO,jj);jW(iU,dP,jk);jW(iU,dQ,thrustion);
                }else ka(iU);}else current_state=160;}else if(current_state==156){iJ=true;Vector3D dK=(nO as IMyShipController).GetNaturalGravity();
                bool dN=nZ("",dK,nO);if(dN){on();current_state=160;}}else if(current_state==160){Echo("Moving to Target");
                Vector3D dR=gf;Vector3D dS=dR-nO.GetPosition();double dT=dS.Length();Echo("distance="+fb(dT));Echo("velocity="
                +iM.ToString("0.00"));eD("clear",er);eD("Moving to Target\nD:"+fb(dT)+" V:"+iM.ToString(d),er);if(dD
                &amp;&amp;(dT&lt;gj)){current_state=200;Echo("we have arrived");iJ=true;return;}bool dU=true;if(go&gt;0&amp;&amp;dGravity&gt;
                0){double dI=0;MyShipVelocities dV=((IMyShipController)nO).GetShipVelocities();Vector3D lv=dV.LinearVelocity;
                double dW=lv.X;Echo("LV="+hX(lv));((IMyShipController)nO).TryGetPlanetElevation(MyPlanetElevation.Surface,
                out dI);dH+=" E="+dI.ToString("0.0");dH+=" V="+iM.ToString("0.00");Echo("Elevation="+dI.ToString("0.0"));
                Echo("MinEle="+go.ToString("0.0"));double dX=0;if(dW&lt;0){dX=kk(iX,Math.Abs(dW),dGravity);}double dY=kk(iX,
                iz,dGravity);float dO;float dP;float dQ;jI(iX,out dO,out dP,out dQ);if(go&gt;0){if(dW&lt;-0.5&amp;&amp;(dI-dX*2)&lt;go)
                {dH+=" EM UP!";Vector3D dK=(nO as IMyShipController).GetNaturalGravity();bool dL=nZ("",dK,nO);jW(iX,
                100);dU=false;iJ=true;}else if(dI&lt;go){dO+=Math.Min(5f,(float)gi);dP+=Math.Min(5f,(float)gi);dQ+=Math.Min(5f,
                (float)gi);dH+=" UP! A"+dO.ToString("0.00");jW(iX,dO,jj);jW(iX,dP,jk);jW(iX,dQ,thrustion);}else if(dI
                &gt;(dY+go*1.25)){dH+=" SUPERHIGH";ka(iX,jm,true);Vector3D dK=(nO as IMyShipController).GetNaturalGravity();
                bool dL=nZ("",dK,nO);if(!dL){iJ=true;dU=false;}}else if(dI&gt;go*2){dH+=" HIGH";if(dW&gt;2){dH+=" ^";ka(iX,
                jm,true);}else if(dW&lt;-0.5){dH+=" v";if(dW&gt;(-Math.Min(15,gi))){dO-=Math.Max(25f,Math.Min(5f,(float)iM
                /2));dP-=Math.Max(25f,Math.Min(5f,(float)iM/2));dQ-=Math.Max(25f,Math.Min(5f,(float)iM/2));dH+=" DOWN! A"
                +dO.ToString("0.00");}else{dO+=Math.Max(100f,Math.Min(5f,(float)iM/2));dP+=Math.Max(100f,Math.Min(5f,
                (float)iM/2));dQ+=Math.Max(100f,Math.Min(5f,(float)iM/2));dH+=" 2FAST! A"+dO.ToString("0.00");Vector3D
                dK=(nO as IMyShipController).GetNaturalGravity();bool dL=nZ("",dK,nO);if(!dL){iJ=true;dU=false;}}}else
                {dH+=" -";dO-=5;dP-=5;dQ-=5;}jW(iX,dO,jj);jW(iX,dP,jk);jW(iX,dQ,thrustion);}else{ka(iX);}}}if(dU){Echo("Do Travel");
                lh(dR,(float)gj,200,170);}else{ka(iU);}}else if(current_state==170){iJ=true;Vector3D dR=gf;lc();lx(dR);
                current_state=172;}else if(current_state==171){iJ=false;}else if(current_state==172){Echo("Collision Avoid");
                eD("clear",er);eD("Collision Avoid",er);lh(lw,5.0f,160,173);}else if(current_state==173){if(bW.Type==
                MyDetectedEntityType.Asteroid||bW.Type==MyDetectedEntityType.LargeGrid||bW.Type==MyDetectedEntityType.SmallGrid)
                {current_state=174;}else current_state=170;iJ=true;}else if(current_state==174){lQ();lc();gh=DateTime.Now;
                current_state=175;iJ=true;}else if(current_state==175){DateTime dZ=gh.AddSeconds(5.0f);DateTime ea=DateTime.Now;
                if(DateTime.Compare(ea,dZ)&gt;0){gd(fq);ky();return;}if(lR()){Echo("ESCAPE!");current_state=180;}bWantMedium
                =true;}else if(current_state==180){lh(lw,1f,160,173);}else if(current_state==200){eD("clear",er);eD("Arrived at Target",
                er);dH+=" ARRIVED!";j();gg=false;mo(false);py();gd(fQ);if(gn){var eb=nJ&lt;IMyTerminalBlock&gt;("NAV:");for
                (int i1=0;i1&lt;eb.Count();i1++){if(eb[i1].CustomName.StartsWith("NAV:")){Echo("Found NAV: command:");eb[i1].CustomName
                ="NAV: C Arrived Target";}}}iJ=true;ky();}gv(dH);}void ec(float ed){if(dF){gB(ed);}else jW(iU,ed);}void
                ee(){ka(iT);gJ();}string ef="LOGGING";void eg(oo f){f.oP(ef,"TextPanelReport",ref sTextPanelReport,true);
                f.oP(ef,"StatusName",ref ek,true);f.oP(ef,"LongStatus",ref em,true);f.oP(ef,"RangeReport",ref ei,true);
                f.oP(ef,"SledReport",ref ssledReport,true);f.oP(ef,"GPSTag",ref eq,true);}ev eh=null;string ei="[RANGE]";
                ev ej=null;string ek="Wico Craft Status";ev el=null;string em="Wico Craft Log";ev en=null;string sTextPanelReport
                ="Craft Report";ev ep=null;string eq="[GPS]";ev er=null;string ssledReport="[SMREPORT]";bool et=false;
                bool eu=false;public class ev{Program cv;string ew="";List&lt;IMyTextPanel&gt;ex=new List&lt;IMyTextPanel&gt;();
                string ey="";string ez="";bool eA=false;bool eB=true;public ev(Program pg,string cp,bool eC=false){cv
                =pg;ew=cp;eA=eC;eB=true;ey="";ez="";ex.Clear();ex=cv.nL(ew);if(ex.Count&lt;1)ex=cv.nK(ew);}public void eD(string
                eE,bool eF=false){if(eE=="clear"){ey="";ez="X";eB=false;return;}if(eA&amp;&amp;eB){eB=false;if(ex.Count&gt;0){ey
                =ex[0].GetPublicText();ez="X";}}if(eF){ey=eE+"\n"+ey;}else ey+=eE+"\n";}public void eG(){if(ez!=ey){
                eB=true;foreach(var t in ex){t.WritePublicText(ey);}ez=ey;}}}void eH(){ej=eM(true);el=eJ(em,true);;en
                =eJ(sTextPanelReport);eh=eJ(ei);ep=eJ(eq,iy);er=eJ(ssledReport);et=true;}void eI(){if(ej!=null)ej.eG();
                if(el!=null)el.eG();if(en!=null)en.eG();if(eh!=null)eh.eG();if(ep!=null)ep.eG();if(er!=null)er.eG();
                }ev eJ(string stheName,bool bRefresh=false){ev eL=new ev(this,stheName,bRefresh);return eL;}ev eM(bool
                force_update=false){if((ej!=null||et)&amp;&amp;!force_update)return ej;ej=eJ(ek);return ej;}void eD(string text,
                ev wLog,bool bReverse=false){if(wLog==null)return;wLog.eD(text,bReverse);}void eP(string eE){eD(eE,eM());
                if(eu&amp;&amp;eE!="clear")Echo(eE);}string eQ(double eR){int eS=75;if(eR&lt;0)eR=0;int eT=(int)(eR*eS)/100;if(eT
                &gt;eS)eT=eS;string dl="["+new String('|',eT)+new String('\'',eS-eT)+"]";return dl;}void eU(string cp,Vector3D
                eV){string s1;s1="GPS:"+cp+":"+hX(eV)+":";eD(s1,ep);}string eW(string eX,string eY){string s;int eZ=
                eX.Length;int fa=eY.Length;if(eZ+fa&gt;32){if(fa&gt;31)return"INVALID";eZ=32-fa;}s=eX.Substring(0,eZ)+eY;s.Replace(":",
                "_");s.Replace(";","_");return s;}string fb(double thed){string fd="";if(thed&gt;1000){fd=thed.ToString("N0")
                +"km";}else if(thed&gt;10){fd=thed.ToString("0.0")+"m";}else{fd=thed.ToString("0.000")+"m";}return fd;}
                void fe(){}void ff(oo fg){mJ(fg);jr(fg);nS(fg);bY(fg);NavInitCustomData(fg);}string fh="";string fi=
                "";int fj=0;string fk(){nU=1;nY=0.09f;nT=0.75;Echo("Init:"+fj);if(fj==0){eD(DateTime.Now.ToString()+
                a+":"+b+":INIT",el,true);fh+=SerializeInit();dn();fh+=nl();fh+=DefaultOrientationBlockInit();eH();}else
                if(fj==1){fh+=js(nO);fh+=gA();fh+=pU(nO);fh+=pt();fh+=ci(nO);fh+=mK();}else if(fj==2){fh+=ol();l.A(nX);
                l.D(nO);fh+=pl();fh+=ci(nO);gM(nO);initShipDim(nO);fh+=fl();iH=true;}fj++;if(iH){fj=0;}eP(fh);return
                fh;}string fl(){return"&gt;";}int fm=0;const int fn=0;const int fo=1;const int fp=2;const int fq=3;const
                int fr=4;const int fs=5;const int ft=7;const int fu=8;const int fv=9;const int fw=13;const int fx=10;
                const int fy=11;const int fz=12;const int fA=14;const int fB=15;const int fC=16;const int fD=17;const
                int fE=18;const int fF=19;const int fG=20;const int fH=21;const int fI=22;const int fJ=23;const int fK
                =24;const int fL=25;const int fM=26;const int fN=27;const int fO=28;const int fP=29;const int fQ=30;
                const int fR=31;const int fS=50;const int fT=60;const int fU=111;const int fV=200;const int fW=210;const
                int fX=220;const int fY=290;const int fZ=400;const int ga=410;const int gb=500;const int gc=510;void
                gd(int newMode){if(fm==newMode)return;fm=newMode;current_state=0;ky();}Vector3D gf;bool gg=false;DateTime
                gh;double gi=100;double gj=50;bool gk=false;bool gl=true;bool gm=true;bool gn=true;float go=-1;bool bNavBeaconDebug
                =false;string sNavSection="NAV";void NavInitCustomData(oo iNIHolder){iNIHolder.oP(sNavSection,"DTMDebug",
                ref gk,true);iNIHolder.oP(sNavSection,"CameraCollision",ref gl,true);iNIHolder.oP(sNavSection,"SensorCollision",
                ref gm,true);iNIHolder.oP(sNavSection,"NAVEmulateOld",ref gn,true);iNIHolder.oP(sNavSection,"NAVGravityMinElevation",
                ref go,true);iNIHolder.oP(sNavSection,"NavBeaconDebug",ref bNavBeaconDebug,true);}void gs(oo f){f.pc(sNavSection,
                "vTarget",gf);f.pc(sNavSection,"ValidNavTarget",gg);f.pc(sNavSection,"dStartShip",gh);f.pc(sNavSection,
                "shipSpeedMax",gi);f.pc(sNavSection,"arrivalDistanceMin",gj);}void gt(oo f){f.oP(sNavSection,"vTarget",
                ref gf,true);f.oP(sNavSection,"ValidNavTarget",ref gg,true);f.oP(sNavSection,"dStartShip",ref gh,true);
                f.oP(sNavSection,"shipSpeedMax",ref gi,true);f.oP(sNavSection,"arrivalDistanceMin",ref gj,true);}List&lt;IMyBeacon&gt;
                gu=new List&lt;IMyBeacon&gt;();void gv(string gw){if(bNavBeaconDebug){if(gu.Count&lt;1)GridTerminalSystem.GetBlocksOfType(gu);
                foreach(var beacon in gu){beacon.CustomName=gw;}}}List&lt;IMyTerminalBlock&gt;gx=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;gy=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;gz=new List&lt;IMyTerminalBlock&gt;();
                string gA(){gx.Clear();gy.Clear();gz.Clear();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(gx,nz);
                for(int i=0;i&lt;gx.Count;i++){if(gx[i].CustomName.Contains("[LEFT]")||gx[i].CustomData.Contains("[LEFT]"))
                {gy.Add(gx[i]);}else if(gx[i].CustomName.Contains("[RIGHT]")||gx[i].CustomData.Contains("[RIGHT]")){
                gz.Add(gx[i]);}}return"NR:L"+gy.Count.ToString("0")+"R"+gz.Count.ToString("0");}bool gB(float gC){if
                (gy.Count&lt;1)return false;float gD=gy[0].GetMaximum&lt;float&gt;("Velocity");var gE=gy[0]as IMyMotorStator;
                float gF=gE.TargetVelocityRPM;float gG=(gF/gD*100);gG=Math.Abs(gG);if(gC&gt;(gG+5f))gC=gG+5;if(gC&lt;(gG-5))
                gC=gG-5;if(gC&lt;0f)gC=0f;if(gC&gt;100f)gC=100f;if(Math.Abs(gC)&gt;0){gB(gy,-gC);gB(gz,gC);return true;}else return
                false;}bool gB(List&lt;IMyTerminalBlock&gt;rotorList,float gC){for(int i=0;i&lt;rotorList.Count;i++){var gE=rotorList[i]
                as IMyMotorStator;float gD=gE.GetMaximum&lt;float&gt;("Velocity");if(!gE.Enabled)gE.Enabled=true;float gI=
                gD*(gC/100.0f);gE.TargetVelocityRPM=gI;}return true;}bool gJ(){gJ(gy);gJ(gz);return true;}bool gJ(List&lt;IMyTerminalBlock&gt;
                rotorList){for(int i=0;i&lt;rotorList.Count;i++){IMyMotorStator gE=rotorList[i]as IMyMotorStator;gE.TargetVelocityRPM
                =0;}return true;}bool gK(double bg){float gC;if(Math.Abs(bg)&gt;1.0){gC=50;}else if(Math.Abs(bg)&gt;.7){gC
                =50;}else if(Math.Abs(bg)&gt;0.5){gC=30;}else if(Math.Abs(bg)&gt;0.1){gC=20;}else if(Math.Abs(bg)&gt;0.01){gC
                =5;}else if(Math.Abs(bg)&gt;0.001){gC=0;}else gC=0;gC/=3;gC=gC*-Math.Sign(bg);if(Math.Abs(gC)&gt;0){gB(gy,
                gC);}if(Math.Abs(gC)&gt;0){gB(gz,gC);}if(Math.Abs(gC)&gt;0)return false;else return true;}public gO gL;void
                gM(IMyTerminalBlock sourceBlock=null){if(sourceBlock==null)sourceBlock=nO;gL=new gO(sourceBlock);}public
                struct gO{public Vector3D[]gP;Vector3D gQ;Vector3D gR;public Vector3D gS;static int[]gT={1,3,5,7};static
                int[]gU={0,2,4,6};static int[]gV={2,3,6,7};static int[]gW={0,1,4,5};static int[]gX={4,5,6,7};static int[]
                gY={0,1,2,3};static int[][]gZ={gT,gU,gV,gW,gX,gY};public const int ha=0;public const int hb=1;public
                const int hc=2;public const int hd=3;public const int he=4;public const int hf=5;public gO(IMyTerminalBlock
                hg){gP=new Vector3D[8];gR=new Vector3D(hg.CubeGrid.Min)-new Vector3D(0.5,0.5,0.5);gR*=hg.CubeGrid.GridSize;
                gQ=new Vector3D(hg.CubeGrid.Max)+new Vector3D(0.5,0.5,0.5);gQ*=hg.CubeGrid.GridSize;var hh=hg.WorldMatrix.GetOrientation();
                var hi=hg.CubeGrid.WorldMatrix.GetOrientation()*MatrixD.Transpose(hh);Vector3D.TransformNormal(ref gR,
                ref hi,out gR);Vector3D.TransformNormal(ref gQ,ref hi,out gQ);var hj=Vector3D.Min(gR,gQ);gQ=Vector3D.Max(gR,
                gQ);gR=hj;var hk=hg.CubeGrid.GetPosition();Vector3D hl;Vector3D hm;hl=gR;Vector3D.TransformNormal(ref
                hl,ref hh,out hl);hl+=hk;hm=gQ;Vector3D.TransformNormal(ref hm,ref hh,out hm);hm+=hk;BoundingBox bb=
                new BoundingBox(hl,hm);gS=bb.Center;Vector3D hn;for(int i=0;i&lt;8;i++){hn.X=((i&amp;1)==0?gR:gQ).X;hn.Y=((i
                &amp;2)==0?gR:gQ).Y;hn.Z=((i&amp;4)==0?gR:gQ).Z;Vector3D.TransformNormal(ref hn,ref hh,out hn);hn+=hk;gP[i]=
                hn;}}public void ho(int hp,Vector3D[]hq,int hr=0){hp%=gZ.Length;for(int i=0;i&lt;gZ[hp].Length;i++){hq[hr++]
                =gP[gZ[hp][i]];}}}bool hs(string ht){fi="";if(ht==""||ht=="timer"||ht=="wccs"||ht=="wcct"){if(sPassedArgument
                !=""&amp;&amp;sPassedArgument!="timer"){ht=sPassedArgument;}if(gn){var eb=nJ&lt;IMyTerminalBlock&gt;("NAV:");for(int
                i1=0;i1&lt;eb.Count();i1++){if(eb[i1].CustomName.StartsWith("NAV:")){Echo("Found NAV: command:");ht=eb[i1].CustomName.Substring("NAV:".Length);
                break;}}}}if(ht=="init"){fh="";iH=false;fj=0;fk();return false;}string[]hu=ht.Trim().Split(';');for(int
                hv=0;hv&lt;hu.Length;hv++){string[]hw=hu[hv].Trim().Split(' ');if(hw[0]=="timer"){}else if(hw[0]=="wccs")
                {}else if(hw[0]=="wcct"){}else if(hw[0]=="W"||hw[0]=="O"){Echo("Args:");for(int hx=0;hx&lt;hw.Length;hx++)
                Echo(hw[hx]);if(hw.Length&lt;1){Echo("Invalid Command:("+hu[hv]+")");continue;}string hy=hw[1].Trim();if
                (hw.Length&gt;2){hy=hw[1];for(int kk=2;kk&lt;hw.Length;kk++)hy+=" "+hw[kk];hy=hy.Trim();}string[]hz=hy.Split(',');
                if(hz.Length&lt;3){hz=hy.Split(':');}for(int hx=0;hx&lt;hz.Length;hx++)Echo(hz[hx]);if(hz.Length&lt;3){Echo("Invalid Command:("
                +hu[hv]+")");on();return false;}int hA=0;string hB="Waypoint";if(hz[0]=="GPS"){if(hz.Length&gt;4){hB=hz[1];
                hA=2;}else{Echo("Invalid Command");on();return false;}}double x,y,z;bool hC=double.TryParse(hz[hA++].Trim(),
                out x);bool hD=double.TryParse(hz[hA++].Trim(),out y);bool hE=double.TryParse(hz[hA++].Trim(),out z);
                if(!hC||!hD||!hE){Echo("Invalid Command:("+hu[hv]+")");continue;}gf=new Vector3D(x,y,z);gg=true;if(hw[0]
                =="W")dD=true;else dD=false;gd(ft);}else if(hw[0]=="S"){if(hw.Length&lt;1){Echo("Invalid Command:("+hu[hv]
                +")");continue;}double x;bool hC=double.TryParse(hw[1].Trim(),out x);if(hC){gi=x;Echo("Set speed to:"
                +gi.ToString("0.00"));}else{Echo("Invalid Command:("+hu[hv]+")");continue;}}else if(hw[0]=="D"){if(hw.Length
                &lt;1){Echo("Invalid Command:("+hu[hv]+")");continue;}double x;bool hC=double.TryParse(hw[1].Trim(),out
                x);if(hC){gj=x;Echo("Set arrival distance to:"+gj.ToString("0.00"));}else{Echo("Invalid Command:("+hu[hv]
                +")");continue;}}else if(hw[0]=="C"){if(hw.Length&lt;1){Echo("Invalid Command:("+hu[hv]+")");continue;}
                else{Echo(hu[hv]);}}else{int hF;if(iv.TryGetValue(hw[0].ToLower(),out hF)){fi="mode set to "+hF;gd(hF);
                }else{fi="Unknown argument:"+hw[0];}}}return false;}bool hG(string ht){return false;}void hH(){if(hO
                ==null)return;g(hO);hO.pc(hL,"Mode",fm.ToString());hO.pc(hL,"current_state",current_state.ToString());
                hO.pc(hL,"PassedArgument",sPassedArgument);hO.pc(hL,"AlertStates",hT.ToString());hO.pc(hL,"craft_operation",
                hR.ToString());hO.pc(hL,"PassedArgument",sPassedArgument);hO.pc(hL,"ReceivedMessage",hU);long hI=0;if
                (SaveFile!=null)hI=SaveFile.EntityId;hO.pc(hL,"SaveID",(long)hI);if(hO.oz){if(hO.oz){string hJ=hO.pg();
                if(SaveFile==null){Storage=hJ;}else{SaveFile.WritePublicText(hJ,false);}}}else{Echo("Not saving: Same");
                }}string hK="Wico Craft Save";string hL="WCCM2";void SerializeInitCustomData(oo iNIHolder){iNIHolder.oP(hL,
                "SAVE_FILE_NAME",ref hK,true);}IMyTextPanel SaveFile=null;oo hO;int current_state=0;long allBlocksCount
                =0;int hR=cZ;string sPassedArgument="";int hT=0;string hU="";string SerializeInit(){string fh="S";SaveFile
                =null;List&lt;IMyTerminalBlock&gt;bJ=new List&lt;IMyTerminalBlock&gt;();bJ=nN&lt;IMyTextPanel&gt;(hK);if(bJ.Count&gt;1)Echo("Multiple blocks found: \""
                +hK+"\"");else if(bJ.Count==0){bJ=nJ&lt;IMyTextPanel&gt;(hK);if(bJ.Count==1)SaveFile=bJ[0]as IMyTextPanel;
                else{bJ=nM&lt;IMyTextPanel&gt;(hK);if(bJ.Count==1)SaveFile=bJ[0]as IMyTextPanel;}}else SaveFile=bJ[0]as IMyTextPanel;
                hO=new oo(this,"");if(SaveFile==null){fh="-";Echo(hK+" (TextPanel) is missing or Named incorrectly. ");
                }return fh;}bool hW(){return SaveFile!=null;}string hX(Vector3D v){string s;s=v.X.ToString("0.00")+":"
                +v.Y.ToString("0.00")+":"+v.Z.ToString("0.00");return s;}bool hY(string hZ,out double x,out double y,
                out double z){string[]hz=hZ.Trim().Split(',');if(hz.Length&lt;3){hz=hZ.Trim().Split(':');}x=0;y=0;z=0;if
                (hz.Length&lt;3)return false;bool hC=double.TryParse(hz[0].Trim(),out x);bool hD=double.TryParse(hz[1].Trim(),
                out y);bool hE=double.TryParse(hz[2].Trim(),out z);if(!hC||!hD||!hE){return false;}return true;}ig ia;
                void initShipDim(IMyTerminalBlock cj){if(cj==null){cj=(IMyTerminalBlock)Me;}ia=new ig(this,cj);}const
                float ic=0.5f;const float id=2.5f;const double ie=0.5;const double@if=2.5;public class ig{private float
                ih,ii,ij;private double ik,il,im;private double@in;private Program cv;private gO gL;public ig(Program
                pg,IMyTerminalBlock cj){cv=pg;if(cv.Me.CubeGrid.GridSizeEnum.ToString().ToLower().Contains("small"))
                @in=ie;else@in=@if;gL=new gO(cj);Vector3D[]hq=new Vector3D[4];gL.ho(gO.hf,hq);il=(hq[0]-hq[1]).Length();
                im=(hq[0]-hq[2]).Length();gL.ho(0,hq);ik=(hq[0]-hq[2]).Length();ih=(float)(ik/@in);ii=(float)(il/@in);
                ij=(float)(im/@in);}public float io(){return ih;}public double ip(){return ik;}public float iq(){return
                ii;}public double ir(){return il;}public float@is(){return ij;}public double it(){return im;}public double
                iu(){return@in;}}Dictionary&lt;string,int&gt;iv=new Dictionary&lt;string,int&gt;();string iw="";UpdateFrequency ix
                =UpdateFrequency.Once;bool iy=true;float iz=100;string iA="WORLD";void iB(oo f){f.oP(iA,"MaxWorldMps",
                ref iz,true);}void iC(){oo fg=new oo(this,Me.CustomData);fg.oP(a,"EchoOn",ref iD,true);iB(fg);na(fg);
                eg(fg);ff(fg);if(fg.oz){Me.CustomData=fg.pg(true);}}bool iD=true;Action&lt;string&gt;iE;void iF(string iG)
                {if(iD)iE(iG);}public Program(){fe();iC();iE=Echo;Echo=iF;iw=a+":"+b+" V"+c+" ";iE(iw+"Creator");if(!Me.CustomName.Contains(b))
                Me.CustomName="PB "+a+" "+b;if(!Me.Enabled){Echo("I am turned OFF!");}}bool iH=false;bool iI=false;bool
                iJ=false;bool bWantMedium=false;bool bWorkingProjector=false;double iM=-1;double dGravity=-2;void Main(string
                ht,UpdateType ut){Echo(iw+ks());iJ=false;bWantMedium=false;bWorkingProjector=false;var iO=new List&lt;IMyTerminalBlock&gt;();
                GridTerminalSystem.GetBlocksOfType&lt;IMyProjector&gt;(iO,nz);for(int i=0;i&lt;iO.Count;i++){if(iO[i].IsWorking)
                {Echo("Projector:"+iO[i].CustomName);bWorkingProjector=true;}}if(bWorkingProjector)Echo("Working local Projector found!");
                if(ht!=""&amp;&amp;ht!="timer"&amp;&amp;ht!="wccs")Echo("Arg="+ht);if(ht=="init"){fh="";iH=false;}if(!iH){if(bWorkingProjector)
                {eD("clear",eJ(sTextPanelReport));eD(b+":Construction in Progress\nTurn off projector to continue",en);
                }iJ=true;fk();iI=true;}else{if(iI)eD(DateTime.Now.ToString()+" "+a+":"+fh,el,true);dn();if(nO is IMyShipController)
                {iM=((IMyShipController)nO).GetShipSpeed();Vector3D iP=((IMyShipController)nO).GetNaturalGravity();double
                iQ=iP.Length();dGravity=iQ/9.81;}if((ut&amp;(UpdateType.Trigger|UpdateType.Terminal))&gt;0){if(hs(ht)){hH();
                eI();return;}}else if((ut&amp;(UpdateType.Mod))&gt;0){if(hs(ht)){hH();eI();return;}}else if((ut&amp;(UpdateType.Script))
                &gt;0){if(hs(ht)){hH();eI();return;}}else if((ut&amp;(UpdateType.Antenna))&gt;0){if(!hG(ht)){mA(ht);}hH();ky();
                eI();return;}else{ht="";}my();mt();h();dA();}hH();if(iJ){Echo("FAST!");Runtime.UpdateFrequency|=ix;}
                else{Runtime.UpdateFrequency&amp;=~(ix);}if(bWantMedium){Echo("MEDIUM");Runtime.UpdateFrequency|=UpdateFrequency.Update10;
                }else{Runtime.UpdateFrequency&amp;=~(UpdateFrequency.Update10);}this.i();iI=false;eI();}void iR(string iw
                =null){float iS=0;iS=Runtime.CurrentInstructionCount/(float)Runtime.MaxInstructionCount;if(iw==null)
                iw="Instructions=";Echo(iw+" "+(iS*100).ToString("0.00")+"%");}List&lt;IMyTerminalBlock&gt;iT=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;iU=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;thrustBackwardList=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;iW=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;iX=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;thrustLeftList=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;iZ=new List&lt;IMyTerminalBlock&gt;();
                double ja=0;double jb=0;double jc=0;double jd=0;double je=0;double jf=0;int jg=0;int jh=0;int ji=0;const
                int jj=1;const int jk=2;const int thrustion=4;const int jm=0xff;Matrix jn=new Matrix(1,0,0,0,0,1,0,0,
                0,0,1,0,0,0,0,1);string jo="IGNORE";string jp="cutter";string jq="THRUSTERS";void jr(oo iNIHolder){iNIHolder.oP(jq,
                "IgnoreThruster",ref jo);iNIHolder.oP(jq,"CutterThruster",ref jp);}void js(IMyTerminalBlock cj,ref List&lt;IMyTerminalBlock&gt;
                iU,ref List&lt;IMyTerminalBlock&gt;iV,ref List&lt;IMyTerminalBlock&gt;iW,ref List&lt;IMyTerminalBlock&gt;iX,ref List&lt;IMyTerminalBlock&gt;
                iY,ref List&lt;IMyTerminalBlock&gt;iZ,int jt=jm){iU.Clear();iV.Clear();iW.Clear();iX.Clear();iY.Clear();iZ.Clear();
                iT.Clear();if(cj==null)return;var ju=new List&lt;IMyTerminalBlock&gt;();nG&lt;IMyThrust&gt;(ref ju);for(int i=0;
                i&lt;ju.Count;i++){if(ju[i].CustomName.ToLower().Contains(jp)||ju[i].CustomData.ToLower().Contains(jp))
                continue;if(ju[i].CustomName.ToLower().Contains(jo)||ju[i].CustomData.ToLower().Contains(jo))continue;
                iT.Add(ju[i]);}Matrix ck;cj.Orientation.GetMatrix(out ck);Matrix.Transpose(ref ck,out ck);ja=0;jb=0;
                jc=0;jd=0;je=0;jf=0;for(int i=0;i&lt;iT.Count;++i){var jv=iT[i]as IMyThrust;Matrix jw;jv.Orientation.GetMatrix(out
                jw);Vector3 cm=Vector3.Transform(jw.Backward,ck);int jx=jy(iT[i]);if(jx==jj)ji++;else if(jx==jk)jh++;
                else if(jx==thrustion)jg++;if(cm==jn.Left){je+=jA((IMyThrust)iT[i]);iY.Add(iT[i]);}else if(cm==jn.Right)
                {jf+=jA((IMyThrust)iT[i]);iZ.Add(iT[i]);}else if(cm==jn.Backward){jb+=jA((IMyThrust)iT[i]);iV.Add(iT[i]);
                }else if(cm==jn.Forward){ja+=jA((IMyThrust)iT[i]);iU.Add(iT[i]);}else if(cm==jn.Up){jd+=jA((IMyThrust)iT[i]);
                iX.Add(iT[i]);}else if(cm==jn.Down){jc+=jA((IMyThrust)iT[i]);iW.Add(iT[i]);}}}string js(IMyTerminalBlock
                cj){iU.Clear();thrustBackwardList.Clear();iW.Clear();iX.Clear();thrustLeftList.Clear();iZ.Clear();iT.Clear();
                if(cj==null)return"No Orientation Block";var ju=new List&lt;IMyTerminalBlock&gt;();nG&lt;IMyThrust&gt;(ref ju);for
                (int i=0;i&lt;ju.Count;i++){if(ju[i].CustomName.ToLower().Contains(jp)||ju[i].CustomData.ToLower().Contains(jp))
                continue;if(ju[i].CustomName.ToLower().Contains(jo)||ju[i].CustomData.ToLower().Contains(jo))continue;
                iT.Add(ju[i]);}Matrix ck;cj.Orientation.GetMatrix(out ck);Matrix.Transpose(ref ck,out ck);ja=0;jb=0;
                jc=0;jd=0;je=0;jf=0;for(int i=0;i&lt;iT.Count;++i){var jv=iT[i]as IMyThrust;Matrix jw;jv.Orientation.GetMatrix(out
                jw);Vector3 cm=Vector3.Transform(jw.Backward,ck);int jx=jy(iT[i]);if(jx==jj)ji++;else if(jx==jk)jh++;
                else if(jx==thrustion)jg++;if(cm==jn.Left){je+=jA((IMyThrust)iT[i]);thrustLeftList.Add(iT[i]);}else if
                (cm==jn.Right){jf+=jA((IMyThrust)iT[i]);iZ.Add(iT[i]);}else if(cm==jn.Backward){jb+=jA((IMyThrust)iT[i]);
                thrustBackwardList.Add(iT[i]);}else if(cm==jn.Forward){ja+=jA((IMyThrust)iT[i]);iU.Add(iT[i]);}else if
                (cm==jn.Up){jd+=jA((IMyThrust)iT[i]);iX.Add(iT[i]);}else if(cm==jn.Down){jc+=jA((IMyThrust)iT[i]);iW.Add(iT[i]);
                }}string s;s="&gt;";s+="F"+iU.Count.ToString("00");s+="B"+thrustBackwardList.Count.ToString("00");s+="D"
                +iW.Count.ToString("00");s+="U"+iX.Count.ToString("00");s+="L"+thrustLeftList.Count.ToString("00");s
                +="R"+iZ.Count.ToString("00");s+="&lt;";return s;}int jy(IMyTerminalBlock theBlock){if(theBlock is IMyThrust)
                {if(theBlock.BlockDefinition.SubtypeId.Contains("Atmo"))return jj;else if(theBlock.BlockDefinition.SubtypeId.Contains("Hydro"))
                return jk;else return thrustion;}return 0;}double jA(IMyThrust thruster){return thruster.MaxEffectiveThrust;
                }double jB(List&lt;IMyTerminalBlock&gt;jC,int jD=jm){double jE=0;for(int jF=0;jF&lt;jC.Count;jF++){int jG=jy(jC[jF]);
                if((jG&amp;jD)&gt;0){IMyThrust jv=jC[jF]as IMyThrust;double jH=jv.MaxEffectiveThrust;jE+=jH;}}return jE;}bool
                jI(List&lt;IMyTerminalBlock&gt;thrusters,out float jJ,out float jK,out float jL){jJ=0;jK=0;jL=0;double jM=
                jB(thrusters,thrustion);double jN=jB(thrusters,jj);double jO=jB(thrusters,jk);MyShipMass jP;jP=((IMyShipController)nO).CalculateShipMass();
                double jQ=0;jQ=jP.PhysicalMass*dGravity*9.810;if(jN&gt;0){if(jN&lt;jQ){jJ=100;jQ-=jN;}else{jJ=(float)(jQ/jN
                *100);if(jJ&gt;0)jQ-=(jN*jJ/100);}}if(jM&gt;0&amp;&amp;jQ&gt;0){if(jM&lt;jQ){jL=100;jQ-=jM;}else{jL=(float)(jQ/jM*100);if
                (jL&gt;0)jQ-=((jM*jL)/100);}}if(jO&gt;0&amp;&amp;jQ&gt;0){if(jO&lt;jQ){jK=100;jQ-=jO;}else{jK=(float)(jQ/jO*100);if(jK&gt;0)
                jQ-=((jO*jK)/100);;}}if(jQ&gt;0)return false;return true;}List&lt;IMyTerminalBlock&gt;jR(string jS){var jT=new
                List&lt;IMyTerminalBlock&gt;();var jU=new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(jU);for(int
                jV=0;jV&lt;jU.Count;jV++){if(jU[jV].Name==jS){List&lt;IMyTerminalBlock&gt;jC=null;jU[jV].GetBlocks(jC,nz);for
                (int jF=0;jF&lt;jC.Count;jF++){jT.Add(jC[jF]);}break;}}return jT;}int jW(List&lt;IMyTerminalBlock&gt;jC,float
                ed,int jD=jm){int jX=0;if(ed&gt;100)ed=100;if(ed&lt;0)ed=0;for(int jF=0;jF&lt;jC.Count;jF++){int jG=jy(jC[jF]);
                if((jG&amp;jD)&gt;0){IMyThrust jv=jC[jF]as IMyThrust;if(!jv.IsWorking){jv.Enabled=true;}jX+=1;jv.ThrustOverridePercentage
                =ed/100f;}}return jX;}int jW(List&lt;IMyTerminalBlock&gt;jC,int jY=100,int jD=jm){return jW(jC,(float)jY,jD);
                }bool jW(string jZ,int jY=100,int jD=jm){if(jY&gt;100)jY=100;var jU=new List&lt;IMyBlockGroup&gt;();GridTerminalSystem.GetBlockGroups(jU);
                for(int jV=0;jV&lt;jU.Count;jV++){if(jU[jV].Name==jZ){List&lt;IMyTerminalBlock&gt;jC=null;jU[jV].GetBlocks(jC,
                nz);return(jW(jC,jY,jD)&gt;0);}}return false;}int ka(List&lt;IMyTerminalBlock&gt;thrusters,int iTypes=jm,bool
                bForceOff=false){int jX=0;for(int jF=0;jF&lt;thrusters.Count;jF++){int jG=jy(thrusters[jF]);if((jG&amp;iTypes)
                &gt;0){jX++;IMyThrust jv=thrusters[jF]as IMyThrust;jv.ThrustOverride=0;if(jv.IsWorking&amp;&amp;bForceOff)jv.Enabled
                =false;else if(!jv.IsWorking&amp;&amp;!bForceOff)jv.Enabled=true;}}return jX;}bool ka(string jZ){var jU=new List&lt;IMyBlockGroup&gt;();
                GridTerminalSystem.GetBlockGroups(jU);for(int jV=0;jV&lt;jU.Count;jV++){if(jU[jV].Name==jZ){List&lt;IMyTerminalBlock&gt;
                jC=null;jU[jV].GetBlocks(jC,nz);return(ka(jC)&gt;0);}}return false;}bool jW(){return(jW(iU)&gt;0);}bool ka()
                {return(ka(iU)&gt;0);}double kc(List&lt;IMyTerminalBlock&gt;kd,int jD=jm){for(int i=0;i&lt;kd.Count;i++){int jG=
                jy(kd[i]);if((jG&amp;jD)&gt;0&amp;&amp;kd[i].IsWorking){var jv=kd[i]as IMyThrust;return jv.ThrustOverride;}}return 0;
                }bool ke(List&lt;IMyTerminalBlock&gt;kd,int jD=jm){for(int i=0;i&lt;kd.Count;i++){int jG=jy(kd[i]);if((jG&amp;jD)
                &gt;0&amp;&amp;kd[i].IsWorking){return true;}}return false;}int kf(List&lt;IMyTerminalBlock&gt;kd,int jD=jm){int jX=0;
                for(int i=0;i&lt;kd.Count;i++){int jG=jy(kd[i]);if((jG&amp;jD)&gt;0&amp;&amp;kd[i].IsWorking){jX++;}}return jX;}IMyThrust
                kg(List&lt;IMyTerminalBlock&gt;iO,int kh=jm){foreach(var thrust in iT){if(thrust is IMyThrust&amp;&amp;(jy(thrust)
                &amp;kh)&gt;0)return thrust as IMyThrust;}return null;}double ki(){if(ji&lt;1)return 0;var kj=kg(iT,jj);if(kj==
                null)return 0;return kj.MaxEffectiveThrust/kj.MaxThrust;}double kk(List&lt;IMyTerminalBlock&gt;iX,double kl,
                double km){var jP=((IMyShipController)nO).CalculateShipMass();double jQ=0;jQ=jP.PhysicalMass*km*9.810;
                double jA=jB(iX);double kn=(jA-jQ)/jP.TotalMass;double ko=kl/kn;double kp=kl/2*ko;return kp;}string[]
                kq={"-","\\","|","/","-","\\","|","/"};int kr=99;string ks(){kr++;if(kr&gt;=kq.Length)kr=0;return kq[kr];
                }const string kt="[WCCT]";const string ku="[WCCS]";const string kv="[WCCM]";Dictionary&lt;string,List&lt;IMyTerminalBlock&gt;&gt;
                kw=new Dictionary&lt;string,List&lt;IMyTerminalBlock&gt;&gt;();void kx(){kw.Clear();}void ky(){if(!kz(kt))kz(kv);
                }bool kz(string sKeyword="[WCCS]"){bool kB=false;List&lt;IMyTerminalBlock&gt;bJ=new List&lt;IMyTerminalBlock&gt;();
                IMyTimerBlock kC=null;if(kw.ContainsKey(sKeyword)){bJ=kw[sKeyword];}else{bJ=nJ&lt;IMyTerminalBlock&gt;(sKeyword);
                kw.Add(sKeyword,bJ);}for(int i=0;i&lt;bJ.Count;i++){kC=bJ[i]as IMyTimerBlock;if(kC!=null){kC.ApplyAction("TriggerNow");
                kB=true;}}return kB;}double kD=-1;double kE=0.50;double kF=-1;IMyShipController kG=null;double kH=85;
                List&lt;IMyTerminalBlock&gt;kI=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;kJ=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;kK=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;kL=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyTerminalBlock&gt;kM=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;kN=new List&lt;IMyTerminalBlock&gt;();
                IMySensorBlock kO=null;bool kP=false;bool kQ=false;bool kR=false;double kS=100;double kT=50;double kU
                =15;double kV=100;double kW=100*0.5;double kX=100*0.25;double kY=5;float kZ=50f;bool la=false;bool lb
                =false;void lc(){kG=null;py();nY=0.01f;kF=0;kD=-1;}void ld(Vector3D dR,double maxSpeed,IMyTerminalBlock
                lf,int jx=jm){kH=maxSpeed;if(kH&gt;iz)kH=iz;if((hR&amp;da)&gt;0){lb=true;pW();}else lb=false;if((hR&amp;db)&gt;0){la=
                true;}else la=false;kG=lf as IMyShipController;Vector3D dS=dR-kG.CenterOfMass;double dT=dS.Length();
                js(kG,ref kJ,ref kI,ref kN,ref kM,ref kK,ref kL,jx);py();if(po.Count&gt;0){kO=po[0];if(la||lb)kO.DetectAsteroids
                =false;else kO.DetectAsteroids=true;kO.DetectEnemy=true;kO.DetectLargeShips=true;kO.DetectSmallShips
                =true;kO.DetectStations=true;kO.DetectPlayers=false;kZ=kO.GetMaximum&lt;float&gt;("Front");}else{kO=null;kZ
                =0;}kP=false;kQ=false;kR=false;double lg=kH;if(!lb&amp;&amp;!la)lg=lu(kI,dT);if(lg&lt;kH)kH=lg;fh+="\nDistance="
                +fb(dT)+" OptimalV="+lg;kV=kH;kW=kH*0.50;kX=kH*0.25;if(kX&lt;5)kX=5;if(kX&gt;kW)kW=kX;if(kX&gt;kV)kV=kX;kU=kk(kI,
                kX+(kW-kX)/2,0);kT=kk(kI,kW+(kV-kW)/2,0);kS=kk(kI,kV,0);kD=-1;kF=0;nY=0.01f;}void lh(Vector3D dR,float
                arrivalDistance,int lj,int colDetectState,bool ll=false){if(gk)Echo("dTM:"+current_state+"-&gt;"+lj+"-C&gt;"
                +colDetectState);if(kG==null){ld(dR,gi,nO);}if(kD&gt;=0)kD+=Runtime.TimeSinceLastRun.TotalMilliseconds;
                if(kF&gt;=0)kF+=Runtime.TimeSinceLastRun.TotalMilliseconds;Vector3D dS=dR-kG.CenterOfMass;double dT=dS.Length();
                if(gk){Echo("dTM:distance="+fb(dT));Echo("dTM:velocity="+iM.ToString("0.00"));Echo("dTM:tmMaxSpeed="
                +kH.ToString("0.00"));}if(dT&lt;arrivalDistance){j();current_state=lj;lc();iJ=true;return;}eU("TargetLocation",
                dR);List&lt;IMySensorBlock&gt;lm=null;double ln=kk(kI,iM,0);Echo("StoppingD="+fb(ln));if(po.Count&gt;0){float
                lo=Math.Min(50f,(float)ln*1.5f);pA(kO,0,0,0,0,lo,0);}else Echo("No Sensors for Travel movement");bool
                dN=false;Vector3D dK=(nO as IMyShipController).GetNaturalGravity();if(lb||la){double dM=-999;dM=bd(dR,
                nO);Echo("yawangle="+dM.ToString());if(lb){Echo("Sled");bB(dM,"Yaw");}else if(la){Echo("Rotor");gK(dM);
                }dN=Math.Abs(dM)&lt;.05;}else{if(dK.Length()&gt;0){bool lp=nZ("",dK,nO);{double dM=bd(dR,nO);bB(dM,"Yaw");
                dN=Math.Abs(dM)&lt;.05;}}else{dN=nZ("forward",dS,nO);}}kG.DampenersOverride=true;if((dT-ln)&lt;arrivalDistance)
                {nY=0.005f;Echo("Waiting for stop");if(!dN)iJ=true;j();return;}if(dN){bWantMedium=true;Echo("Aimed");
                on();if(gm&amp;&amp;(kF&gt;pq||kF&lt;0)){kF=0;lm=pw();if(lm.Count&gt;0){var lq=new List&lt;MyDetectedEntityInfo&gt;();string
                s="";for(int i1=0;i1&lt;lm.Count;i1++){lm[i1].DetectedEntities(lq);int j1=0;bool lr=false;if(lq.Count&gt;0)
                lr=true;for(;j1&lt;lq.Count;j1++){s="\nSensor TRIGGER!";s+="\nName: "+lq[j1].Name;s+="\nType: "+lq[j1].Type;
                s+="\nRelationship: "+lq[j1].Relationship;s+="\n";if(gk){Echo(s);eD(s,el);}if(lq[j1].Type==MyDetectedEntityType.Planet)
                {lr=false;}if(lq[j1].Type==MyDetectedEntityType.LargeGrid||lq[j1].Type==MyDetectedEntityType.SmallGrid)
                {if(lq[j1].BoundingBox.Contains(dR)!=ContainmentType.Disjoint){if(gk)Echo("Ignoring collision because we want to be INSIDE");
                lr=false;}}if(lr)break;}if(lr){bW=lq[j1];lc();current_state=colDetectState;iJ=true;j();return;}}}else
                bW=new MyDetectedEntityInfo();}double ls=ln*2;{if(ls&lt;100)if(dT&lt;1000)ls=dT;else ls=1000;ls=Math.Min(dT,
                ls);}if(gl){Echo("Scanning distance="+ls);}if(gl&amp;&amp;(kD&gt;kE||kD&lt;0)&amp;&amp;dT&gt;kZ){if(bZ(bO,ls)){kD=0;if(!bW.IsEmpty())
                {bool lr=true;if(ll){if(bW.Type==MyDetectedEntityType.Asteroid){if(bW.BoundingBox.Contains(dR)!=ContainmentType.Disjoint)
                {lr=false;double lt=((Vector3D)bW.HitPosition-nO.GetPosition()).Length();if((lt-ln)&lt;arrivalDistance)
                {j();current_state=lj;lc();return;}}}else if(bW.Type==MyDetectedEntityType.Planet){lr=false;}else{}}
                if(gk){Echo("raycast hit:"+bW.Type.ToString());eD("Camera Trigger collision",el);}if(lr){lc();current_state
                =colDetectState;iJ=true;j();return;}}else{if(gk){eD("Camera Scan Clear",el);}}}else{if(gk){eD("No Scan Available",
                el);}}}else Echo("Raycast delay");if(gk)Echo("dtmFar="+fb(kS));if(gk)Echo("dtmApproach="+fb(kT));if(gk)
                Echo("dtmPrecision="+fb(kU));if(dT&gt;kS&amp;&amp;!kP){Echo("dtmFar");lW(kV,100f);}else if(dT&gt;kT&amp;&amp;!kQ){Echo("Approach");
                kP=true;lW(kW,100f);}else if(dT&gt;kU&amp;&amp;!kR){Echo("Precision");if(!kQ)nY=0.005f;kQ=true;lW(kX,55f);}else
                {Echo("Close");if(!kR)nY=0.005f;kR=true;lW(kY,55f);}}else{if(gk)Echo("Aiming");iJ=true;kG.DampenersOverride
                =true;if(iM&lt;5){ka(iT);}else{ka(kI,jm,true);}}}double lu(List&lt;IMyTerminalBlock&gt;lv,double dT){Echo("#thrusters="
                +lv.Count.ToString());if(lv.Count&lt;1)return iz;MyShipMass jP;jP=((IMyShipController)nO).CalculateShipMass();
                double jA=jB(lv);double kn=jA/jP.PhysicalMass;double lg,ko,kp;lg=((dT*.75)/2)/(kn);Echo("COS");do{Echo("COS:DO");
                ko=lg/kn;kp=lg/2*ko;if(kp&gt;dT){lg*=0.85;}Echo("stoppingM="+kp.ToString("F1")+" distance="+dT.ToString("N1"));
                }while(kp&gt;dT);Echo("COS:X");return lg;}Vector3D lw;void lx(Vector3D dR){if(kD&gt;=0)kD+=Runtime.TimeSinceLastRun.TotalMilliseconds;
                if(kF&gt;=0)kF+=Runtime.TimeSinceLastRun.TotalMilliseconds;Vector3D ly;if(bW.HitPosition.HasValue){ly=(Vector3D)bW.HitPosition;
                }else{ly=nO.GetPosition();}Vector3D bj=bW.Position;Vector3D dS=(bj-ly);dS.Normalize();Vector3D lz=bW.BoundingBox.Min;
                Vector3D lA=bW.BoundingBox.Max;double lB=(bj-lz).Length();double lC=lB+ia.ir()*5;Vector3D lD;lD=Vector3D.Cross(dR,
                ly);lD.Normalize();lD=ly+lD*lC;lw=lD;}bool lE=true;bool lF=true;bool lG=true;bool lH=true;bool lI=true;
                bool lJ=true;MyDetectedEntityInfo lK=new MyDetectedEntityInfo();MyDetectedEntityInfo lL=new MyDetectedEntityInfo();
                MyDetectedEntityInfo lM=new MyDetectedEntityInfo();MyDetectedEntityInfo lN=new MyDetectedEntityInfo();
                MyDetectedEntityInfo lO=new MyDetectedEntityInfo();MyDetectedEntityInfo lP=new MyDetectedEntityInfo();
                void lQ(){if(kD&gt;=0)kD+=Runtime.TimeSinceLastRun.TotalMilliseconds;if(kF&gt;=0)kF+=Runtime.TimeSinceLastRun.TotalMilliseconds;
                lE=true;lF=true;lG=true;lH=true;lI=false;lJ=true;lK=new MyDetectedEntityInfo();lL=new MyDetectedEntityInfo();
                lM=new MyDetectedEntityInfo();lN=new MyDetectedEntityInfo();lO=new MyDetectedEntityInfo();lP=new MyDetectedEntityInfo();
                if(bW.Type==MyDetectedEntityType.LargeGrid||bW.Type==MyDetectedEntityType.SmallGrid){}if(bS.Count&lt;1)
                lE=false;if(bT.Count&lt;1)lF=false;if(bR.Count&lt;1)lG=false;if(bQ.Count&lt;1)lH=false;if(bO.Count&lt;1)lJ=false;
                if(bP.Count&lt;1)lI=false;}bool lR(){if(kD&gt;=0)kD+=Runtime.TimeSinceLastRun.TotalMilliseconds;if(kF&gt;=0)kF
                +=Runtime.TimeSinceLastRun.TotalMilliseconds;MatrixD lS=nO.WorldMatrix;Vector3D dS=lS.Forward;Echo("ScanEscape()");
                if(lE){if(bZ(bS,200)){lE=false;lK=bW;if(bW.IsEmpty()){dS=lS.Left;dS.Normalize();lw=nO.GetPosition()+
                dS*200;return true;}}}if(lF){if(bZ(bT,200)){lF=false;lL=bW;if(bW.IsEmpty()){dS=lS.Right;dS.Normalize();
                lw=nO.GetPosition()+dS*200;return true;}}}if(lG){if(bZ(bR,200)){lM=bW;lG=false;if(bW.IsEmpty()){dS=lS.Up;
                dS.Normalize();lw=nO.GetPosition()+dS*200;return true;}}}if(lH){if(bZ(bQ,200)){lN=bW;lH=false;if(bW.IsEmpty())
                {dS=lS.Down;dS.Normalize();lw=nO.GetPosition()+dS*200;return true;}}}if(lI){if(bZ(bP,200)){lO=bW;lI=
                false;if(bW.IsEmpty()){dS=lS.Backward;dS.Normalize();lw=nO.GetPosition()+dS*200;return true;}}}if(lJ)
                {if(bZ(bO,200)){lJ=false;if(bW.IsEmpty()){dS=lS.Forward;dS.Normalize();lw=nO.GetPosition()+dS*200;return
                true;}}}if(lJ||lI||lG||lH||lE||lF){Echo("More scans");return false;}Echo("Scans done. Choose longest");
                MyDetectedEntityInfo lT=lO;Vector3D lU=nO.GetPosition();dS=lS.Backward;if(lT.HitPosition==null||lK.HitPosition
                !=null&amp;&amp;Vector3D.DistanceSquared(lU,(Vector3D)lT.HitPosition)&lt;Vector3D.DistanceSquared(lU,(Vector3D)lK.HitPosition))
                {dS=lS.Left;lT=lK;}if(lT.HitPosition==null||lL.HitPosition!=null&amp;&amp;Vector3D.DistanceSquared(lU,(Vector3D)lT.HitPosition)
                &lt;Vector3D.DistanceSquared(lU,(Vector3D)lL.HitPosition)){dS=lS.Right;lT=lL;}if(lT.HitPosition==null||
                lM.HitPosition!=null&amp;&amp;Vector3D.DistanceSquared(lU,(Vector3D)lT.HitPosition)&lt;Vector3D.DistanceSquared(lU,
                (Vector3D)lM.HitPosition)){dS=lS.Up;lT=lM;}if(lT.HitPosition==null||lN.HitPosition!=null&amp;&amp;Vector3D.DistanceSquared(lU,
                (Vector3D)lT.HitPosition)&lt;Vector3D.DistanceSquared(lU,(Vector3D)lN.HitPosition)){dS=lS.Down;lT=lN;}if
                (lT.HitPosition==null||lP.HitPosition!=null&amp;&amp;Vector3D.DistanceSquared(lU,(Vector3D)lT.HitPosition)&lt;Vector3D.DistanceSquared(lU,
                (Vector3D)lP.HitPosition)){dS=lS.Forward;lT=lP;}if(lT.HitPosition==null)return false;double dT=Vector3D.Distance(lU,
                (Vector3D)lT.HitPosition);Echo("Distance="+fb(dT));dS.Normalize();lw=nO.GetPosition()+dS*dT/2;if(dT&gt;
                4){return true;}return false;}void lV(float ed){if(la){gB(ed);}else jW(kJ,ed);}void lW(double maxSpeed,
                float maxThrust){if(!la){if(iM&lt;1)jW(kJ,maxThrust);else if(iM&lt;maxSpeed*.75)jW(kJ,25f);else if(iM&lt;maxSpeed
                *.85)jW(kJ,15f);else if(iM&lt;=maxSpeed*.98){jW(kJ,1f);}else if(iM&gt;=maxSpeed*1.02){ka(iT);}else{ka(iT);
                ka(kI,jm,true);}}else{lV(maxThrust);}}bool lX=false;List&lt;IMyRadioAntenna&gt;lY=new List&lt;IMyRadioAntenna&gt;();
                List&lt;IMyLaserAntenna&gt;lZ=new List&lt;IMyLaserAntenna&gt;();string ma(){lY.Clear();lZ.Clear();nG&lt;IMyRadioAntenna&gt;(ref
                lY);nG&lt;IMyLaserAntenna&gt;(ref lZ);for(int i1=0;i1&lt;lY.Count;++i1){if(lY[i1].CustomName.Contains("unused")
                ||lY[i1].CustomData.Contains("unused"))continue;if(!lX){a="Wico "+lY[i1].CustomName.Split('!')[0].Trim();
                lX=true;}}return"A"+lY.Count.ToString("0");}void mb(){for(int i=0;i&lt;lY.Count;i++){lY[i].Enabled=true;
                }}string mc="";void md(){if(hU!=""){if(mc==hU){hU="";}mc=hU;}else mc="";}void me(){}void mf(){float mg
                =0;int mh=-1;for(int i=0;i&lt;lY.Count;i++){if(lY[i].AttachedProgrammableBlock==Me.EntityId){mh=i;break;
                }if(lY[i].Radius&gt;mg&amp;&amp;lY[i].AttachedProgrammableBlock==0){mh=i;mg=lY[i].Radius;}}if(mh&gt;=0){if(lY[mh].AttachedProgrammableBlock
                !=Me.EntityId)fh+="\nSetting Antenna PB";lY[mh].AttachedProgrammableBlock=Me.EntityId;}else{}}void mi(bool
                mj=false){if(lY.Count&lt;1)ma();foreach(var a in lY){a.Radius=200;if(a.AttachedProgrammableBlock&gt;0||mj)
                {a.Enabled=true;}}}void mk(float ml=200,bool mj=false){if(lY.Count&lt;1)ma();foreach(var a1 in lY){if(a1.AttachedProgrammableBlock
                &gt;0||mj){a1.Radius=ml;a1.Enabled=true;}}}Vector3D mm(){if(lY.Count&lt;1)ma();foreach(var a1 in lY){if(a1.AttachedProgrammableBlock
                ==Me.EntityId){return a1.GetPosition();}}foreach(var a1 in lY){return a1.GetPosition();}Vector3D mn=
                new Vector3D();return mn;}void mo(bool mj=false,float mp=float.MaxValue){if(lY==null||lY.Count&lt;1)ma();
                if(mp&lt;200)mp=200;foreach(var a in lY){if(a.AttachedProgrammableBlock&gt;0||mj){float mq=a.GetMaximum&lt;float&gt;("Radius");
                if(mp&lt;mq)mq=mp;a.Radius=mq;a.Enabled=true;}}}int mr(){if(lY.Count&lt;1)ma();return(lY.Count);}List&lt;string&gt;
                ms=new List&lt;string&gt;();void mt(){if(ms.Count&gt;0){mu(ms[0]);ms.RemoveAt(0);}if(ms.Count&gt;0)iJ=true;}void
                mu(string mv){bool mw=false;if(lY.Count&lt;1)ma();for(int i=0;i&lt;lY.Count;i++){mw=lY[i].TransmitMessage(mv);
                if(mw)break;}if(!mw){if(mr()&gt;0){ms.Add(mv);iJ=true;}}}List&lt;string&gt;mx=new List&lt;string&gt;();void my(bool
                mz=false){if(mx.Count&gt;0){if(hU==""){hU=mx[0];mx.RemoveAt(0);if(mz){iJ=true;}else{ky();}}}if(mx.Count
                &gt;0){}}void mA(string mv){mx.Add(mv);my();}void mB(){if(lY.Count&gt;0){Echo(mx.Count+" Pending Incoming Messages");
                for(int i=0;i&lt;mx.Count;i++)Echo(i+":"+mx[i]);}else Echo("No antennas found");}List&lt;IMyTerminalBlock&gt;
                mC=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;mD=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                mE=new List&lt;IMyTerminalBlock&gt;();bool mF=false;string mG="[BASE]";string mH="[DOCK]";string mI="CONNECTORS";
                void mJ(oo iNIHolder){iNIHolder.oP(mI,"BaseConnector",ref mG,true);iNIHolder.oP(mI,"DockConnector",ref
                mH,true);}string mK(){mF=false;mC.Clear();mD.Clear();mE.Clear();mL();return"CL"+mC.Count.ToString()+
                "CD"+mD.Count.ToString()+"CB"+mE.Count.ToString();}void mL(){if(mC.Count&lt;1&amp;&amp;!mF)mC=nG&lt;IMyShipConnector&gt;();
                if(mD.Count&lt;1&amp;&amp;!mF)mD=nJ&lt;IMyShipConnector&gt;(mH);if(mD.Count&lt;1&amp;&amp;!mF)mD=mC;if(mE.Count&lt;1&amp;&amp;!mF)mE=nJ&lt;IMyShipConnector&gt;(mG);
                mF=true;return;}bool mM(){mL();for(int i=0;i&lt;mD.Count;i++){var mN=mD[i]as IMyShipConnector;if(mN==null)
                continue;if(mN.Status==MyShipConnectorStatus.Connectable)return true;}return false;}bool mO(){mL();for
                (int i=0;i&lt;mD.Count;i++){var mN=mD[i]as IMyShipConnector;if(mN==null)continue;if(mN.Status==MyShipConnectorStatus.Connected)
                {var mP=mN.OtherConnector;if(mP.CubeGrid==mN.CubeGrid){continue;}else return true;}}return false;}IMyTerminalBlock
                mQ(){mL();if(mD.Count&gt;0){return mD[0];}return null;}IMyTerminalBlock mR(bool mS=false){mL();for(int i
                =0;i&lt;mD.Count;i++){var mN=mD[i]as IMyShipConnector;if(mN==null)continue;if(mN.Status==MyShipConnectorStatus.Connected)
                {var mP=mN.OtherConnector;if(mP.CubeGrid==mN.CubeGrid){continue;}else{if(!mS){return mN.OtherConnector;
                }else{return mD[i];}}}}return null;}void mT(bool mU=true,bool bK=true){mL();for(int i=0;i&lt;mD.Count;i++)
                {var mN=mD[i]as IMyShipConnector;if(mN==null)continue;if(mN.Status==MyShipConnectorStatus.Connected)
                {var mP=mN.OtherConnector;if(mP.CubeGrid==mN.CubeGrid){continue;}}if(mU){if(mN.Status==MyShipConnectorStatus.Connectable)
                mN.ApplyAction("SwitchLock");}else{if(mN.Status==MyShipConnectorStatus.Connected)mN.ApplyAction("SwitchLock");
                }mN.Enabled=bK;}return;}string mV="NOFOLLOW";string mW="!WCC";string mX="[NAV]";string mY="Craft Remote Control";
                string mZ="GRIDS";void na(oo iNIHolder){iNIHolder.oP(mZ,"NoFollow",ref mV,true);iNIHolder.oP(mZ,"BlockIgnore",
                ref mW,true);iNIHolder.oP(mZ,"OrientationBlockContains",ref mX,true);iNIHolder.oP(mZ,"OrientationBlockNamed",
                ref mY,true);}List&lt;IMyTerminalBlock&gt;nb=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTextPanel&gt;nc=new List&lt;IMyTextPanel&gt;();
                List&lt;IMyTextPanel&gt;nd=new List&lt;IMyTextPanel&gt;();List&lt;IMyTerminalBlock&gt;ne=new List&lt;IMyTerminalBlock&gt;();
                List&lt;IMyCubeGrid&gt;nf=new List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;ng=new List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;
                nh=new List&lt;IMyCubeGrid&gt;();List&lt;IMyCubeGrid&gt;ni=new List&lt;IMyCubeGrid&gt;();bool nj(){List&lt;IMyTerminalBlock&gt;
                nk=new List&lt;IMyTerminalBlock&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyTerminalBlock&gt;(nk);if(allBlocksCount
                !=nk.Count){return true;}return false;}string nl(){nb.Clear();ni.Clear();nf.Clear();ng.Clear();nh.Clear();
                nc.Clear();nd.Clear();GridTerminalSystem.GetBlocksOfType&lt;IMyTerminalBlock&gt;(nb);allBlocksCount=nb.Count;
                foreach(var block in nb){var bu=block.CubeGrid;if(!ni.Contains(bu)){ni.Add(bu);}}no(Me.CubeGrid);foreach
                (var grid in ni){if(nf.Contains(grid))continue;bool nm=false;List&lt;IMyShipConnector&gt;nn=new List&lt;IMyShipConnector&gt;();
                GridTerminalSystem.GetBlocksOfType&lt;IMyShipConnector&gt;(nn,(x1=&gt;x1.CubeGrid==grid));foreach(var connector
                in nn){if(connector.Status==MyShipConnectorStatus.Connected){if(nf.Contains(connector.OtherConnector.CubeGrid)
                ||ng.Contains(connector.OtherConnector.CubeGrid)){continue;}if(nf.Contains(connector.OtherConnector.CubeGrid))
                nm=true;else nm=false;}}if(nm){if(!nh.Contains(grid)){nh.Add(grid);}}if(!ng.Contains(grid)){ng.Add(grid);
                }}string s="";s+="B"+nb.Count.ToString();s+="G"+ni.Count.ToString();s+="L"+nf.Count.ToString();s+="D"
                +nh.Count.ToString();s+="R"+ng.Count.ToString();return s;}void no(IMyCubeGrid bu){if(bu==null)return;
                if(!nf.Contains(bu)){nf.Add(bu);np(bu);ns(bu);nu(bu);nw(bu);}}void np(IMyCubeGrid grid){List&lt;IMyMotorStator&gt;
                nq=new List&lt;IMyMotorStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(nq,(x=&gt;x.TopGrid==grid));
                foreach(var rotor in nq){if(rotor.CustomName.Contains(mV)||rotor.CustomData.Contains(mV))continue;no(rotor.CubeGrid);
                }List&lt;IMyMotorAdvancedStator&gt;nr=new List&lt;IMyMotorAdvancedStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorAdvancedStator&gt;(nr,
                (x=&gt;x.TopGrid==grid));foreach(var rotor in nr){if(rotor.CustomName.Contains(mV)||rotor.CustomData.Contains(mV))
                continue;no(rotor.CubeGrid);}}void ns(IMyCubeGrid grid){List&lt;IMyPistonBase&gt;nt=new List&lt;IMyPistonBase&gt;();
                GridTerminalSystem.GetBlocksOfType&lt;IMyPistonBase&gt;(nt,(x=&gt;x.TopGrid==grid));foreach(var piston in nt)
                {no(piston.CubeGrid);}}void nu(IMyCubeGrid grid){List&lt;IMyMotorStator&gt;nq=new List&lt;IMyMotorStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorStator&gt;(nq,
                (x1=&gt;x1.CubeGrid==grid));foreach(var rotor in nq){if(rotor.CustomName.Contains(mV)||rotor.CustomData.Contains(mV))
                continue;IMyCubeGrid nv=rotor.TopGrid;if(nv!=null&amp;&amp;nv!=grid){no(nv);}}nq.Clear();List&lt;IMyMotorAdvancedStator&gt;
                nr=new List&lt;IMyMotorAdvancedStator&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyMotorAdvancedStator&gt;(nr,
                (x1=&gt;x1.CubeGrid==grid));foreach(var rotor in nr){if(rotor.CustomName.Contains(mV)||rotor.CustomData.Contains(mV))
                continue;IMyCubeGrid nv=rotor.TopGrid;if(nv!=null&amp;&amp;nv!=grid){no(nv);}}}void nw(IMyCubeGrid grid){List&lt;IMyPistonBase&gt;
                nt=new List&lt;IMyPistonBase&gt;();GridTerminalSystem.GetBlocksOfType&lt;IMyPistonBase&gt;(nt,(x1=&gt;x1.CubeGrid==
                grid));foreach(var piston in nt){IMyCubeGrid nv=piston.TopGrid;if(nv!=null&amp;&amp;nv!=grid){if(!nf.Contains(nv))
                {no(nv);}}}}List&lt;IMyCubeGrid&gt;nx(){if(nf.Count&lt;1){nl();}return nf;}List&lt;IMyCubeGrid&gt;ny(){if(nf.Count&lt;
                1){nl();}return nh;}bool nz(IMyTerminalBlock block){return nx().Contains(block.CubeGrid);}bool nA(long
                nB){for(int i1=0;i1&lt;nf.Count;i1++){if((long)nf[i1].EntityId==nB)return true;}return false;}bool nA(IMyCubeGrid
                nB){return nx().Contains(nB);}bool nC(IMyTerminalBlock hg){var g1=ny();if(g1==null)return false;return
                g1.Contains(hg.CubeGrid);}void nD(){if(nb.Count&lt;1)nl();ne.Clear();foreach(var b1 in nb){if(nz(b1)&amp;&amp;!(b1.CustomName.Contains(mW)
                ||b1.CustomData.Contains(mW)))ne.Add(b1);}}IMyTerminalBlock nE(string nF){IMyTerminalBlock hg;hg=(IMyTerminalBlock)GridTerminalSystem.GetBlockWithName(nF);
                if(hg==null)throw new Exception(nF+" Not Found");return hg;}public List&lt;T&gt;nG&lt;T&gt;(ref List&lt;T&gt;nH,string
                nI=null)where T:class{if(nH==null)nH=new List&lt;T&gt;();else nH.Clear();if(ne.Count&lt;1)nD();for(int e1=0;e1
                &lt;ne.Count;e1++){if(ne[e1]is T&amp;&amp;((nI==null)||(nI!=null&amp;&amp;ne[e1].CustomName.StartsWith(nI)))){nH.Add((T)ne[e1]);
                }}return nH;}public List&lt;IMyTerminalBlock&gt;nG&lt;T&gt;(ref List&lt;IMyTerminalBlock&gt;nH,string nI=null)where T:
                class{if(nb.Count&lt;1)nl();if(nH==null)nH=new List&lt;IMyTerminalBlock&gt;();else nH.Clear();if(ne.Count&lt;1)nD();
                for(int e1=0;e1&lt;ne.Count;e1++){if(ne[e1]is T&amp;&amp;((nI==null)||(nI!=null&amp;&amp;ne[e1].CustomName.StartsWith(nI))))
                {nH.Add(ne[e1]);}}return nH;}public List&lt;IMyTerminalBlock&gt;nG&lt;T&gt;(string nI=null)where T:class{var nH=
                new List&lt;IMyTerminalBlock&gt;();nG&lt;T&gt;(ref nH,nI);return nH;}public List&lt;IMyTerminalBlock&gt;nJ&lt;T&gt;(string Keyword
                =null)where T:class{var nH=new List&lt;IMyTerminalBlock&gt;();if(ne.Count&lt;1)nD();for(int e1=0;e1&lt;ne.Count;
                e1++){if(ne[e1]is T&amp;&amp;Keyword!=null&amp;&amp;(ne[e1].CustomName.Contains(Keyword)||ne[e1].CustomData.Contains(Keyword)))
                {nH.Add(ne[e1]);}}return nH;}public List&lt;IMyTextPanel&gt;nK(string nI=null){if(nb.Count&lt;1)nl();var nH=new
                List&lt;IMyTextPanel&gt;();if(nc.Count&gt;1){foreach(var t1 in nc){if(nI!=null&amp;&amp;(t1.CustomName.Contains(nI)||
                t1.CustomData.Contains(nI)))nH.Add(t1);}}else{foreach(var t1 in nb){if(t1 is IMyTextPanel&amp;&amp;nz(t1)&amp;&amp;!(t1.CustomName.Contains(mW)
                ||t1.CustomData.Contains(mW))){if(nI!=null&amp;&amp;(t1.CustomName.Contains(nI)||t1.CustomData.Contains(nI)))
                nH.Add(t1 as IMyTextPanel);nc.Add(t1 as IMyTextPanel);}}}return nH;}public List&lt;IMyTextPanel&gt;nL(string
                nI=null){if(ne.Count&lt;1)nD();var nH=new List&lt;IMyTextPanel&gt;();if(nd.Count&gt;1){foreach(var t1 in nd){if(nI
                !=null&amp;&amp;(t1.CustomName.Contains(nI)||t1.CustomData.Contains(nI)))nH.Add(t1);}}else{foreach(var t1 in
                ne){if(t1 is IMyTextPanel&amp;&amp;Me.CubeGrid==t1.CubeGrid){if(nI!=null&amp;&amp;(t1.CustomName.Contains(nI)||t1.CustomData.Contains(nI)))
                nH.Add(t1 as IMyTextPanel);nd.Add(t1 as IMyTextPanel);}}}return nH;}public List&lt;IMyTerminalBlock&gt;nM&lt;T&gt;(string
                nI=null)where T:class{if(ne.Count&lt;1)nD();var nH=new List&lt;IMyTerminalBlock&gt;();for(int e1=0;e1&lt;ne.Count;
                e1++){if(ne[e1]is T&amp;&amp;Me.CubeGrid==ne[e1].CubeGrid&amp;&amp;nI!=null&amp;&amp;(ne[e1].CustomName.Contains(nI)||ne[e1].CustomData.Contains(nI)))
                {nH.Add(ne[e1]);}}return nH;}public List&lt;IMyTerminalBlock&gt;nN&lt;T&gt;(string nI=null)where T:class{if(ne.Count
                &lt;1)nD();var nH=new List&lt;IMyTerminalBlock&gt;();for(int e1=0;e1&lt;ne.Count;e1++){if(ne[e1]is T&amp;&amp;nI!=null&amp;&amp;
                ne[e1].CustomName==nI){nH.Add(ne[e1]);}}return nH;}IMyTerminalBlock nO=null;string DefaultOrientationBlockInit()
                {string sInitResults="";var centerSearch=new List&lt;IMyTerminalBlock&gt;();nG&lt;IMyTerminalBlock&gt;(ref centerSearch,
                mY);if(centerSearch.Count==0){centerSearch=nJ&lt;IMyRemoteControl&gt;(mX);if(centerSearch.Count==0){nG&lt;IMyRemoteControl&gt;(ref
                centerSearch);if(centerSearch.Count==0){nG&lt;IMyCockpit&gt;(ref centerSearch);int i=0;for(;i&lt;centerSearch.Count;
                i++){Echo("Checking Controller:"+centerSearch[i].CustomName);if(centerSearch[i]is IMyCryoChamber)continue;
                break;}if(i&gt;=centerSearch.Count){sInitResults+="!!NO valid Controller";Echo("No Controller found");}
                else{sInitResults+="S";Echo("Using good ship Controller: "+centerSearch[i].CustomName);}}else{sInitResults
                +="R";Echo("Using First Remote control found: "+centerSearch[0].CustomName);}}}else{sInitResults+="N";
                Echo("Using Named: "+centerSearch[0].CustomName);}if(centerSearch.Count&gt;0)nO=centerSearch[0];return sInitResults;
                }string nR="!NAV";void nS(oo f){f.oP(mZ,"GyroIgnore",ref nR,true);f.oP(mZ,"LIMIT_GYROS",ref nU,true);
                f.oP(mZ,"LEAVE_GYROS",ref nV,true);f.oP(mZ,"CTRL_COEFF",ref nT,true);}double nT=0.9;int nU=3;int nV=
                -1;IMyShipController nW;List&lt;IMyGyro&gt;nX;float nY=0.01f;bool GyroMain(string argument){if(nW==null)ol();
                if(nW is IMyShipController){Vector3D dK=(nW as IMyShipController).GetNaturalGravity();return nZ(argument,
                dK,nO);}else{Echo("No Controller for gravity");}return true;}bool nZ(string oa,Vector3D ob,IMyTerminalBlock
                oc){bool dL=true;if(nW==null)ol();Matrix or;oc.Orientation.GetMatrix(out or);Vector3D od;oa=oa.ToLower();
                if(oa.Contains("rocket"))od=or.Backward;else if(oa.Contains("up"))od=or.Up;else if(oa.Contains("backward"))
                od=or.Backward;else if(oa.Contains("forward"))od=or.Forward;else od=or.Down;ob.Normalize();for(int i
                =0;i&lt;nX.Count;++i){var g=nX[i];g.Orientation.GetMatrix(out or);var oe=Vector3D.Transform(od,MatrixD.Transpose(or));
                var of=Vector3D.Transform(ob,MatrixD.Transpose(g.WorldMatrix.GetOrientation()));var og=Vector3D.Cross(oe,
                of);double oh=Vector3D.Dot(oe,of);double oi=og.Length();oi=Math.Atan2(oi,Math.Sqrt(Math.Max(0.0,1.0-
                oi*oi)));if(oh&lt;0)oi=Math.PI-oi;if(oi&lt;nY){g.GyroOverride=false;continue;}float oj=g.GetMaximum&lt;float&gt;("Yaw");
                double ok=oj*(oi/Math.PI)*nT;ok=Math.Min(oj,ok);ok=Math.Max(0.01,ok);og.Normalize();og*=ok;float Z=-(float)og.X;
                g.Pitch=Z;float X=-(float)og.Y;g.Yaw=X;float bb=-(float)og.Z;g.Roll=bb;g.GyroOverride=true;dL=false;
                }return dL;}string ol(){string s="";var l=new List&lt;IMyTerminalBlock&gt;();nW=nO as IMyShipController;if
                (nW==null){if(l.Count&lt;1)return"No RC!";}on();GridTerminalSystem.GetBlocksOfType&lt;IMyGyro&gt;(l,x=&gt;x.CubeGrid
                ==nO.CubeGrid);var l2=new List&lt;IMyTerminalBlock&gt;();int om=0;for(int i=0;i&lt;l.Count;i++){if(l[i].CustomName.Contains(nR)
                ||l[i].CustomData.Contains(nR)){om++;continue;}l2.Add(l[i]);}nX=l2.ConvertAll(x=&gt;(IMyGyro)x);if(nU&gt;0)
                {if(nX.Count&gt;nU){nX.RemoveRange(nU,nX.Count-nU);}else{if((nV-om)&gt;0){int hr=nX.Count-(nV-om);nX.RemoveRange(hr,
                (nV-om));}}}on();s+="GYRO#"+nX.Count.ToString("00")+"#";return s;}void on(){if(nX!=null){for(int i=0;
                i&lt;nX.Count;++i){nX[i].GyroOverride=false;nX[i].Enabled=true;}}}public class oo{Dictionary&lt;string,string&gt;
                op;Dictionary&lt;string,string[]&gt;oq;Dictionary&lt;string,Dictionary&lt;string,string&gt;&gt;or;char os='[';char ot=
                ']';string ou="";MyGridProgram cv;string ov="";static string[]ow={"true","yes","on","1"};const StringComparison
                ox=StringComparison.OrdinalIgnoreCase;const char oy='=';public bool oz{get;private set;}=false;public
                oo(MyGridProgram pg,string hJ){cv=pg;op=new Dictionary&lt;string,string&gt;();oq=new Dictionary&lt;string,string[]&gt;();
                or=new Dictionary&lt;string,Dictionary&lt;string,string&gt;&gt;();oA(hJ);}public int oA(string hJ){hJ.TrimEnd();
                if(ov==hJ){return op.Count;}op.Clear();oq.Clear();or.Clear();ou="";oz=false;ov=hJ;string[]oB=hJ.Split('\n');
                for(int oC=0;oC&lt;oB.Count();oC++){string oD="";oB[oC].Trim();if(oB[oC].StartsWith(os.ToString())){string
                cp="";for(int oE=1;oE&lt;oB[oC].Length;oE++)if(oB[oC][oE]==ot)break;else cp+=oB[oC][oE];if(cp!=""){oD=cp.ToUpper();
                }else continue;oC++;string oF="";var oG=new string[oB.Count()-oC];int oH=0;var oI=new Dictionary&lt;string,
                string&gt;();for(;oC&lt;oB.Count();oC++){oB[oC].Trim();if(oB[oC].StartsWith(os.ToString())){oC--;break;}oF
                +=oB[oC]+"\n";oG[oH++]=oB[oC];if(oB[oC].Contains(oy)){string[]oJ=oB[oC].Split('=');if(oJ.Count()&gt;1){
                string oK=oJ[0];string J="";for(int i1=1;i1&lt;oJ.Count();i1++){J+=oJ[i1];if(i1+1&lt;oJ.Count())J+=oy;}oI.Add(oK,
                J);}}}if(!or.ContainsKey(oD))or.Add(oD,oI);if(!oq.ContainsKey(oD))oq.Add(oD,oG);if(!op.ContainsKey(oD))
                op.Add(oD,oF);}else{ou+=oB[oC]+"\n";}}return op.Count;}public string oL(string oM){string oF="";if(op.ContainsKey(oM))
                oF=op[oM];return oF;}public string[]oN(string oM){string[]oO={""};if(oq.ContainsKey(oM))oO=oq[oM];return
                oO;}public bool oP(string oM,string oK,ref string oQ,bool oR=false){oM=oM.ToUpper();if(or.ContainsKey(oM))
                {var oS=or[oM];if(oS.ContainsKey(oK)){oQ=oS[oK];return true;}}if(oR)pc(oM,oK,oQ);return false;}public
                bool oP(string oM,string oK,ref long oT,bool oR=false){string oU="";if(!oP(oM,oK,ref oU)){if(oR){pc(oM,
                oK,oT);}return false;}oT=Convert.ToInt64(oU);return true;}public bool oP(string oM,string oK,ref int
                oV,bool oR=false){string oU="";if(!oP(oM,oK,ref oU)){if(oR){pc(oM,oK,oV);}return false;}oV=Convert.ToInt32(oU);
                return true;}public bool oP(string oM,string oK,ref double oW,bool oR=false){string oU="";if(!oP(oM,
                oK,ref oU)){if(oR){pc(oM,oK,oW);}return false;}bool oX=double.TryParse(oU,out oW);return true;}public
                bool oP(string oM,string oK,ref float oY,bool oR=false){string oU="";if(!oP(oM,oK,ref oU)){if(oR){pc(oM,
                oK,oY.ToString());}return false;}bool oX=float.TryParse(oU,out oY);return true;}public bool oP(string
                oM,string oK,ref DateTime oZ,bool oR=false){string oU="";if(!oP(oM,oK,ref oU)){if(oR){pc(oM,oK,oZ);}
                return false;}oZ=DateTime.Parse(oU);return true;}public bool oP(string oM,string oK,ref Vector3D pa,
                bool oR=false){string oU="";if(!oP(oM,oK,ref oU)){if(oR){pc(oM,oK,pa);}return false;}double x1,y1,z1;
                hY(oU,out x1,out y1,out z1);pa.X=x1;pa.Y=y1;pa.Z=z1;return true;}public bool oP(string oM,string oK,
                ref bool pb,bool oR=false){string oU="";if(!oP(oM,oK,ref oU)){if(oR){pc(oM,oK,pb);}return false;}pb=
                ow.Any(c=&gt;string.Equals(oU,c,ox));return true;}public bool pc(string section,string key,string oU){if
                (op.ContainsKey(section)){op[section]="";}else{op.Add(section,"");oz=true;}if(or.ContainsKey(section))
                {var oI=new Dictionary&lt;string,string&gt;();var oS=or[section];if(oS.ContainsKey(key)){if(oS[key]==oU)return
                false;oS[key]=oU;}else{oS.Add(key,oU);}oz=true;}else{var oI=new Dictionary&lt;string,string&gt;();oI.Add(key,
                oU);or.Add(section,oI);oz=true;}return true;}public bool pc(string oM,string oK,Vector3D pa){pc(oM,oK,
                hX(pa));return true;}public bool pc(string oM,string oK,bool pb){pc(oM,oK,pb.ToString());return true;
                }public bool pc(string oM,string oK,int pd){pc(oM,oK,pd.ToString());return true;}public bool pc(string
                oM,string oK,long pe){pc(oM,oK,pe.ToString());return true;}public bool pc(string oM,string oK,DateTime
                oZ){pc(oM,oK,oZ.ToString());return true;}public bool pc(string oM,string oK,float oY){pc(oM,oK,oY.ToString());
                return true;}public bool pc(string oM,string oK,double oW){pc(oM,oK,oW.ToString());return true;}public
                void pf(string oM,string oF){oF.TrimEnd();oM=oM.ToUpper();if(op.ContainsKey(oM)){if(op[oM]!=oF){op[oM]
                =oF;oz=true;}}else{oz=true;op.Add(oM,oF);}}public string pg(bool ph=true){string pi="";string s1=ou.Trim();
                if(s1!="")pi=s1+"\n";foreach(var kv in op){pi+=os+kv.Key.Trim()+ot+"\n";if(kv.Value.TrimEnd()==""){string
                pj="";if(or.ContainsKey(kv.Key)){foreach(var dk in or[kv.Key]){pj+=dk.Key+oy+dk.Value+"\n";}}pj+="\n";
                pi+=pj;}else{pi+=kv.Value.Trim()+"\n\n";}}if(ph){oz=false;ov=pi;}return pi;}bool hY(string hZ,out double
                x,out double y,out double z){string[]hz=hZ.Trim().Split(',');if(hz.Length&lt;3){hz=hZ.Trim().Split(':');
                }x=0;y=0;z=0;if(hz.Length&lt;3)return false;bool hC=double.TryParse(hz[0].Trim(),out x);bool hD=double.TryParse(hz[1].Trim(),
                out y);bool hE=double.TryParse(hz[2].Trim(),out z);if(!hC||!hD||!hE){return false;}return true;}string
                hX(Vector3D v){string s;s=v.X.ToString("0.00")+":"+v.Y.ToString("0.00")+":"+v.Z.ToString("0.00");return
                s;}}List&lt;IMyTerminalBlock&gt;pk=new List&lt;IMyTerminalBlock&gt;();string pl(){pk.Clear();pk=nG&lt;IMyLightingBlock&gt;();
                return"L"+pk.Count.ToString("00");}void pm(List&lt;IMyTerminalBlock&gt;pk,Color c){for(int i=0;i&lt;pk.Count;
                i++){var pn=pk[i]as IMyLightingBlock;if(pn==null)continue;if(pn.Color.Equals(c)&amp;&amp;pn.Enabled){continue;
                }pn.Color=c;}}List&lt;IMySensorBlock&gt;po=new List&lt;IMySensorBlock&gt;();string pp="[WICO]";double pq=0.125;const
                string pr="SENSORS";void ps(oo f){f.oP(pr,"SensorUse",ref pp,true);f.oP(pr,"SensorSettleWaitMS",ref pq,
                true);}string pt(bool pu=true){po.Clear();List&lt;IMyTerminalBlock&gt;pv=nJ&lt;IMySensorBlock&gt;(pp);foreach(var
                sb1 in pv){po.Add(sb1 as IMySensorBlock);}if(pu)py();return"S"+po.Count.ToString("00");}List&lt;IMySensorBlock&gt;
                pw(string px=null){List&lt;IMySensorBlock&gt;pw=new List&lt;IMySensorBlock&gt;();for(int i1=0;i1&lt;po.Count;i1++){
                IMySensorBlock s=po[i1]as IMySensorBlock;if(s==null)continue;if(s.IsActive&amp;&amp;s.Enabled&amp;&amp;!s.LastDetectedEntity.IsEmpty())
                {pw.Add(po[i1]);}}return pw;}void py(){for(int i1=0;i1&lt;po.Count;i1++){IMySensorBlock pz=po[i1]as IMySensorBlock;
                if(pz==null)continue;pz.LeftExtend=pz.RightExtend=pz.TopExtend=pz.BottomExtend=pz.FrontExtend=pz.BackExtend
                =1;pz.Enabled=false;}}void pA(IMyTerminalBlock tb,float pB,float pC,float pD,float pE,float pF,float
                pG){IMySensorBlock pz=tb as IMySensorBlock;if(pz==null)return;float pH=pz.Position.X*0.5f;float pI=pz.Position.Y
                *0.5f;float pJ=pz.Position.Z*0.5f;Echo("SB.x.y.z="+pH.ToString("0.0")+":"+pI.ToString("0.0")+":"+pJ.ToString("0.0"));
                Echo("MIN="+Me.CubeGrid.Min.ToString()+"\nMAX:"+Me.CubeGrid.Max.ToString());float pK;pK=(float)(ia.ir()
                /2-pH+pB);pz.LeftExtend=Math.Max(pK,1.0f);pK=(float)(ia.ir()/2+pH+pC);pz.RightExtend=Math.Max(pK,1.0f);
                pK=(float)(ia.it()/2-pI+pD);pz.TopExtend=Math.Max(pK,1.0f);pK=(float)(ia.it()/2+pI+pE);pz.BottomExtend
                =Math.Max(pK,1.0f);pK=(float)(ia.ip()+pJ+pF);pz.FrontExtend=Math.Max(pK,1.0f);pK=(float)(ia.ip()-pJ+
                pG);pz.BackExtend=Math.Max(pK,1.0f);pz.Enabled=true;}bool pL(IMySensorBlock s1,ref bool pM,ref bool pN,
                ref bool pO){pM=false;pN=false;pO=false;if(s1!=null&amp;&amp;s1.IsActive&amp;&amp;s1.Enabled&amp;&amp;!s1.LastDetectedEntity.IsEmpty())
                {List&lt;MyDetectedEntityInfo&gt;pP=new List&lt;MyDetectedEntityInfo&gt;();s1.DetectedEntities(pP);for(int j1=0;
                j1&lt;pP.Count;j1++){if(pP[j1].Type==MyDetectedEntityType.Asteroid){pM=true;}else if(pP[j1].Type==MyDetectedEntityType.LargeGrid)
                {pN=true;}else if(pP[j1].Type==MyDetectedEntityType.SmallGrid){pO=true;}}}return pM||pN||pO;}List&lt;IMyTerminalBlock&gt;
                pQ=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;pR=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;
                pS=new List&lt;IMyTerminalBlock&gt;();List&lt;IMyTerminalBlock&gt;pT=new List&lt;IMyTerminalBlock&gt;();string pU(IMyTerminalBlock
                cj){pQ.Clear();pR.Clear();pS.Clear();pT.Clear();nG&lt;IMyMotorSuspension&gt;(ref pQ);for(int i=0;i&lt;pQ.Count;
                i++){if(pQ[i].CustomName.Contains("[SLED]")||pQ[i].CustomData.Contains("[SLED]")){pR.Add(pQ[i]);if(pQ[i].CustomName.Contains("[REAR]")
                ||pQ[i].CustomData.Contains("[FRONT]")){pS.Add(pQ[i]);}if(pQ[i].CustomName.Contains("[FRONT]")||pQ[i].CustomData.Contains("[FRONT]"))
                {pT.Add(pQ[i]);}}}return"W"+pQ.Count.ToString("0")+"WS"+pR.Count.ToString("0")+"SR"+pS.Count.ToString("0")
                +"SF"+pT.Count.ToString("0");}bool pV(){if(pR.Count&gt;0)return true;return false;}void pW(){for(int i1
                =0;i1&lt;pR.Count;i1++){var w1=pR[i1]as IMyMotorSuspension;w1.SetValueFloat("Friction",0);}}
              </Program>
              <Storage />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="0" y="7" z="-3" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_RemoteControl">
              <SubtypeName>SmallBlockRemoteControl</SubtypeName>
              <EntityId>80108720240481781</EntityId>
              <Min x="0" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Remote Control</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <UseSingleWeaponMode>false</UseSingleWeaponMode>
              <Toolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots>
                  <Slot>
                    <Index>0</Index>
                    <Item />
                    <Data xsi:type="MyObjectBuilder_ToolbarItemTerminalBlock">
                      <Action>View</Action>
                      <BlockEntityId>75821339999657987</BlockEntityId>
                    </Data>
                  </Slot>
                </Slots>
              </Toolbar>
              <SelectedGunId xsi:nil="true" />
              <BuildToolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots />
              </BuildToolbar>
              <PreviousControlledEntityId xsi:nil="true" />
              <AutoPilotEnabled>false</AutoPilotEnabled>
              <FlightMode>2</FlightMode>
              <BindedCamera>0</BindedCamera>
              <CurrentWaypointIndex>-1</CurrentWaypointIndex>
              <Waypoints />
              <Direction>0</Direction>
              <DockingModeEnabled>false</DockingModeEnabled>
              <CollisionAvoidance>false</CollisionAvoidance>
              <Coords />
              <Names />
              <WaypointThresholdDistance>0</WaypointThresholdDistance>
              <IsMainRemoteControl>false</IsMainRemoteControl>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCornerInv</SubtypeName>
              <Min x="-1" y="6" z="-2" />
              <BlockOrientation Forward="Backward" Up="Right" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Gyro">
              <SubtypeName>SmallBlockGyro</SubtypeName>
              <EntityId>107010565854799887</EntityId>
              <Min x="1" y="5" z="-3" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyModStorageComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_ModStorageComponent">
                      <Storage>
                        <dictionary>
                          <item>
                            <Key>74de02b3-27f9-4960-b1c4-27351f2b06d1</Key>
                            <Value>NAV: C test;D 80;S 10;W 10031.54:60388.83:4714.83:</Value>
                          </item>
                        </dictionary>
                      </Storage>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Gyro</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <GyroPower>0.158608809</GyroPower>
              <TargetAngularVelocity x="0.005108488" y="-0.0144461272" z="0" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="4" z="-2" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_TextPanel">
              <SubtypeName>SmallTextPanel</SubtypeName>
              <EntityId>85257959908831425</EntityId>
              <Min x="-1" y="5" z="-3" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Wico Craft Save</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Description />
              <Title>Title</Title>
              <AccessFlag>READ_AND_WRITE_FACTION</AccessFlag>
              <ChangeInterval>0</ChangeInterval>
              <SelectedImages />
              <Font Type="MyObjectBuilder_FontDefinition" Subtype="Debug" />
              <FontSize>1</FontSize>
              <PublicDescription>
                [WCCM2]
                Mode=0
                current_state=0
                PassedArgument=
                AlertStates=0
                craft_operation=0
                ReceivedMessage=
                SaveID=76536456195904552

                [NAV]
                vTarget=0.00:0.00:0.00
                ValidNavTarget=False
                dStartShip=01/01/0001 00:00:00
                shipSpeedMax=100
                arrivalDistanceMin=50

              </PublicDescription>
              <PublicTitle>Public title</PublicTitle>
              <ShowText>NONE</ShowText>
              <FontColor>
                <PackedValue>4294967295</PackedValue>
                <X>255</X>
                <Y>255</Y>
                <Z>255</Z>
                <R>255</R>
                <G>255</G>
                <B>255</B>
                <A>255</A>
              </FontColor>
              <BackgroundColor>
                <PackedValue>4278190080</PackedValue>
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R>0</R>
                <G>0</G>
                <B>0</B>
                <A>255</A>
              </BackgroundColor>
              <CurrentShownTexture>0</CurrentShownTexture>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="4" z="-2" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="3" y="4" z="-2" />
              <BlockOrientation Forward="Left" Up="Backward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCornerInv</SubtypeName>
              <Min x="1" y="6" z="-2" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="0" y="7" z="-2" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="2" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-2" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="3" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-3" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="4" z="-3" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="4" z="-3" />
              <ColorMaskHSV x="0" y="-0.95" z="0.4" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="6" z="-3" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="6" z="-3" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="3" y="6" z="-3" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-3" y="6" z="-3" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="3" y="4" z="-3" />
              <BlockOrientation Forward="Left" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-3" y="4" z="-3" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="4" z="-3" />
              <BlockOrientation Forward="Left" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="4" z="-3" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="5" z="-4" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_ReflectorLight">
              <SubtypeName>SmallBlockFrontLight</SubtypeName>
              <EntityId>83618464039701789</EntityId>
              <Min x="-4" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Spotlight 4</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Radius>10</Radius>
              <ReflectorRadius>120</ReflectorRadius>
              <ColorRed>0.215686277</ColorRed>
              <ColorGreen>0.270588249</ColorGreen>
              <Falloff>0.3</Falloff>
              <Intensity>3</Intensity>
              <BlinkIntervalSeconds>0</BlinkIntervalSeconds>
              <BlinkLenght>10</BlinkLenght>
              <BlinkOffset>0</BlinkOffset>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="2" y="4" z="-4" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="-2" y="4" z="-4" />
              <BlockOrientation Forward="Up" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="1" y="4" z="-4" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="-1" y="4" z="-4" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="0" y="4" z="-4" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="5" z="-4" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="5" z="-4" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="2" y="6" z="-4" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Base</SubtypeName>
              <Min x="-2" y="6" z="-4" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CameraBlock">
              <SubtypeName>SmallCameraBlock</SubtypeName>
              <EntityId>75821339999657987</EntityId>
              <Min x="0" y="5" z="-5" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Camera [VIEW]</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <IsActive>false</IsActive>
              <Fov>0.9065726</Fov>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="0" y="6" z="-4" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="3" y="6" z="-4" />
              <BlockOrientation Forward="Left" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="-3" y="6" z="-4" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="3" y="4" z="-4" />
              <BlockOrientation Forward="Left" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorCorner2Tip</SubtypeName>
              <Min x="-3" y="4" z="-4" />
              <BlockOrientation Forward="Right" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="2" y="5" z="-4" />
              <BlockOrientation Forward="Left" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="-2" y="5" z="-4" />
              <BlockOrientation Forward="Right" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="3" y="5" z="-4" />
              <BlockOrientation Forward="Left" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="-3" y="5" z="-4" />
              <BlockOrientation Forward="Right" Up="Forward" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="1" y="6" z="-4" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="-1" y="6" z="-4" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_ReflectorLight">
              <SubtypeName>SmallBlockFrontLight</SubtypeName>
              <EntityId>85234815499342095</EntityId>
              <Min x="4" y="5" z="-3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Spotlight 3</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Radius>10</Radius>
              <ReflectorRadius>120</ReflectorRadius>
              <ColorRed>0.215686277</ColorRed>
              <ColorGreen>0.270588249</ColorGreen>
              <Falloff>0.3</Falloff>
              <Intensity>3</Intensity>
              <BlinkIntervalSeconds>0</BlinkIntervalSeconds>
              <BlinkLenght>10</BlinkLenght>
              <BlinkOffset>0</BlinkOffset>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="0" y="7" z="4" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_ReflectorLight">
              <SubtypeName>SmallBlockFrontLight</SubtypeName>
              <EntityId>117483250497116255</EntityId>
              <Min x="-2" y="5" z="3" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Spotlight 6</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Radius>10</Radius>
              <ReflectorRadius>120</ReflectorRadius>
              <ColorRed>0.215686277</ColorRed>
              <ColorGreen>0.270588249</ColorGreen>
              <Falloff>0.3</Falloff>
              <Intensity>3</Intensity>
              <BlinkIntervalSeconds>0</BlinkIntervalSeconds>
              <BlinkLenght>10</BlinkLenght>
              <BlinkOffset>0</BlinkOffset>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>124815419740814040</EntityId>
              <Min x="1" y="3" z="-4" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Atmospheric Thrusters 4</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>100839089234260402</EntityId>
              <Min x="-1" y="3" z="-4" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Atmospheric Thrusters 5</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>90503928698670846</EntityId>
              <Min x="-3" y="4" z="5" />
              <BlockOrientation Forward="Left" Up="Down" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Atmospheric Thrusters 12</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>107060500810852545</EntityId>
              <Min x="1" y="4" z="5" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Atmospheric Thrusters 11</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_TextPanel">
              <SubtypeName>SmallTextPanel</SubtypeName>
              <EntityId>106015933653645420</EntityId>
              <Min x="0" y="5" z="10" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Text panel</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Description />
              <Title>Title</Title>
              <AccessFlag>READ_AND_WRITE_FACTION</AccessFlag>
              <ChangeInterval>0</ChangeInterval>
              <SelectedImages>
                <string>Galactic Corporation Logo</string>
              </SelectedImages>
              <Font Type="MyObjectBuilder_FontDefinition" Subtype="Debug" />
              <FontSize>1</FontSize>
              <PublicDescription />
              <PublicTitle>Public title</PublicTitle>
              <ShowText>NONE</ShowText>
              <FontColor>
                <PackedValue>4294967295</PackedValue>
                <X>255</X>
                <Y>255</Y>
                <Z>255</Z>
                <R>255</R>
                <G>255</G>
                <B>255</B>
                <A>255</A>
              </FontColor>
              <BackgroundColor>
                <PackedValue>4278190080</PackedValue>
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R>0</R>
                <G>0</G>
                <B>0</B>
                <A>255</A>
              </BackgroundColor>
              <CurrentShownTexture>0</CurrentShownTexture>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>116004560203560917</EntityId>
              <Min x="2" y="4" z="4" />
              <BlockOrientation Forward="Up" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Atmospheric Thrusters 10</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="4" z="5" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Tip</SubtypeName>
              <Min x="0" y="3" z="5" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope2Base</SubtypeName>
              <Min x="0" y="3" z="4" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="3" z="3" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="3" z="2" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="3" z="1" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="3" z="0" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="3" z="-1" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="3" z="-2" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="0" y="3" z="-3" />
              <BlockOrientation Forward="Backward" Up="Down" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="0" y="6" z="5" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Beacon">
              <SubtypeName>SmallBlockBeacon</SubtypeName>
              <EntityId>139796881236947954</EntityId>
              <Min x="0" y="6" z="-3" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Beacon</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <BroadcastRadius>100</BroadcastRadius>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_LargeGatlingTurret">
              <SubtypeName>SmallGatlingTurret</SubtypeName>
              <EntityId>83433276878042169</EntityId>
              <Min x="-2" y="7" z="-1" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyInventoryBase</TypeId>
                    <Component xsi:type="MyObjectBuilder_Inventory">
                      <Items>
                        <MyObjectBuilder_InventoryItem>
                          <Amount>20</Amount>
                          <PhysicalContent xsi:type="MyObjectBuilder_AmmoMagazine">
                            <SubtypeName>NATO_25x184mm</SubtypeName>
                            <ProjectilesCount>0</ProjectilesCount>
                          </PhysicalContent>
                          <ItemId>0</ItemId>
                        </MyObjectBuilder_InventoryItem>
                      </Items>
                      <nextItemId>1</nextItemId>
                      <Volume>0.084</Volume>
                      <Mass>9223372036854.775807</Mass>
                      <MaxItemCount>2147483647</MaxItemCount>
                      <Size xsi:nil="true" />
                      <InventoryFlags>CanReceive</InventoryFlags>
                      <RemoveEntityOnEmpty>false</RemoveEntityOnEmpty>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Gatling Turret</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <IsShooting>false</IsShooting>
              <IsShootingFromTerminal>false</IsShootingFromTerminal>
              <IsLargeTurret>true</IsLargeTurret>
              <MinFov>0.1</MinFov>
              <MaxFov>1.04719758</MaxFov>
              <Inventory>
                <Items>
                  <MyObjectBuilder_InventoryItem>
                    <Amount>20</Amount>
                    <PhysicalContent xsi:type="MyObjectBuilder_AmmoMagazine">
                      <SubtypeName>NATO_25x184mm</SubtypeName>
                      <ProjectilesCount>0</ProjectilesCount>
                    </PhysicalContent>
                    <ItemId>0</ItemId>
                  </MyObjectBuilder_InventoryItem>
                </Items>
                <nextItemId>1</nextItemId>
                <Volume>0.084</Volume>
                <Mass>9223372036854.775807</Mass>
                <MaxItemCount>2147483647</MaxItemCount>
                <Size xsi:nil="true" />
                <InventoryFlags>CanReceive</InventoryFlags>
                <RemoveEntityOnEmpty>false</RemoveEntityOnEmpty>
              </Inventory>
              <RemainingAmmo>0</RemainingAmmo>
              <Target>0</Target>
              <IsPotentialTarget>true</IsPotentialTarget>
              <PreviousControlledEntityId xsi:nil="true" />
              <Rotation>0</Rotation>
              <Elevation>0</Elevation>
              <GunBase>
                <CurrentAmmoMagazineName>NATO_25x184mm</CurrentAmmoMagazineName>
                <RemainingAmmosList />
                <LastShootTime>0</LastShootTime>
              </GunBase>
              <EnableIdleRotation>true</EnableIdleRotation>
              <PreviousIdleRotationState>true</PreviousIdleRotationState>
              <TargetCharacters>true</TargetCharacters>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="3" y="7" z="1" />
              <BlockOrientation Forward="Down" Up="Right" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorSlope</SubtypeName>
              <Min x="-3" y="7" z="1" />
              <BlockOrientation Forward="Down" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_ReflectorLight">
              <SubtypeName>SmallBlockFrontLight</SubtypeName>
              <EntityId>76090927589919924</EntityId>
              <Min x="2" y="5" z="3" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.575" y="-0.8" z="0.61" />
              <CustomName>Spotlight 5</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Radius>10</Radius>
              <ReflectorRadius>120</ReflectorRadius>
              <ColorRed>0.215686277</ColorRed>
              <ColorGreen>0.270588249</ColorGreen>
              <Falloff>0.3</Falloff>
              <Intensity>3</Intensity>
              <BlinkIntervalSeconds>0</BlinkIntervalSeconds>
              <BlinkLenght>10</BlinkLenght>
              <BlinkOffset>0</BlinkOffset>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>101565486631893781</EntityId>
              <Min x="-2" y="4" z="4" />
              <BlockOrientation Forward="Up" Up="Left" />
              <ColorMaskHSV x="0.594444454" y="0.11" z="-0.34" />
              <CustomName>Atmospheric Thrusters 9</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
          </CubeBlocks>
          <XMirroxPlane x="0" y="5" z="1" />
          <ConveyorLines>
            <MyObjectBuilder_ConveyorLine>
              <StartPosition x="0" y="5" z="2" />
              <StartDirection>Forward</StartDirection>
              <EndPosition x="0" y="5" z="1" />
              <EndDirection>Backward</EndDirection>
              <Sections />
              <ConveyorLineType>LARGE_LINE</ConveyorLineType>
            </MyObjectBuilder_ConveyorLine>
          </ConveyorLines>
          <DisplayName>Envoy</DisplayName>
          <DestructibleBlocks>true</DestructibleBlocks>
          <CreatePhysics>false</CreatePhysics>
          <EnableSmallToLargeConnections>false</EnableSmallToLargeConnections>
          <IsRespawnGrid>false</IsRespawnGrid>
          <LocalCoordSys>0</LocalCoordSys>
          <TargetingTargets />
        </CubeGrid>
      </CubeGrids>
    </Prefab>
  </Prefabs>
</Definitions>
